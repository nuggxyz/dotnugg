{
  "language": "Solidity",
  "sources": {
    "src/_test/Event.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport '../libraries/Uint.sol';\n\n\n\nlibrary Event {\n    function log(uint256 val, string memory name) internal view {\n\n\n\n    }\n\n    function log(\n        uint256 val0,\n        string memory name0,\n        uint256 val1,\n        string memory name1,\n        uint256 val2,\n        string memory name2\n    ) internal view {\n\n\n\n\n    }\n\n    function log(\n        uint256 val0,\n        string memory name0,\n        uint256 val1,\n        string memory name1\n    ) internal view {\n\n\n\n    }\n\n    function log(\n        uint256 val0,\n        string memory name0,\n        uint256 val1,\n        string memory name1,\n        uint256 val2,\n        string memory name2,\n        uint256 val3,\n        string memory name3\n    ) internal view {\n\n\n\n\n\n    }\n\n    function log(uint256[] memory arr, string memory name) internal view {\n\n\n        for (uint256 i = 0; i < arr.length; i++) {\n\n        }\n    }\n}\n\n// library Event {\n//     function log(uint256 val, string memory name) internal view {}\n\n//     function log(\n//         uint256 val0,\n//         string memory name0,\n//         uint256 val1,\n//         string memory name1,\n//         uint256 val2,\n//         string memory name2\n//     ) internal view {}\n\n//     function log(uint256[] memory arr, string memory name) internal view {}\n// }\n"
    },
    "src/libraries/Uint.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\n/*\n * @dev Uint operations.\n */\nlibrary Uint8 {\n    function toByte(uint8 u) internal pure returns (bytes1 res) {\n        res = bytes1(u);\n    }\n\n    function toString(uint8 u) internal pure returns (string memory res) {\n        res = Uint256.toString(uint256(u));\n    }\n}\n\n/*\n * @dev Uint operations.\n */\nlibrary Uint256 {\n    bytes16 private constant ALPHABET = '0123456789abcdef';\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toAscii(uint256 value) internal pure returns (bytes memory buffer) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return '0';\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n\n        buffer = new bytes(digits);\n\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return buffer;\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        return string(toAscii(value));\n    }\n\n    /// @notice Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n    /// @dev Credit to Open Zeppelin under MIT license https://github.com/OpenZeppelin/openzeppelin-contracts/blob/243adff49ce1700e0ecb99fe522fb16cff1d1ddc/contracts/utils/Strings.sol#L55\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = '0';\n        buffer[1] = 'x';\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = ALPHABET[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, 'Strings: hex length insufficient');\n        return string(buffer);\n    }\n\n    function toHexStringNoPrefix(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length);\n        for (uint256 i = buffer.length; i > 0; i--) {\n            buffer[i - 1] = ALPHABET[value & 0xf];\n            value >>= 4;\n        }\n        return string(buffer);\n    }\n}\n"
    },
    "src/logic/Svg.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport '../libraries/Uint.sol';\n\nlibrary Svg {\n    using Uint256 for uint256;\n\n    function getPixelAt(\n        uint256[] memory file,\n        uint256 x,\n        uint256 y,\n        uint256 width\n    ) internal pure returns (uint256 res) {\n        uint256 index = x + (y * width);\n\n        res = (file[index / 6] >> (40 * (index % 6))) & 0xffffffff;\n    }\n\n    function buildSvg(\n        uint256[] memory file,\n        uint256 width,\n        uint256 height,\n        uint8 zoom\n    ) internal pure returns (bytes memory res) {\n        bytes memory header = abi.encodePacked(\n            hex'3c7376672076696577426f783d2730203020', //\"<svg Box='0 0 \",\n            (zoom * width).toString(),\n            hex'20', // ' ',\n            (zoom * width).toString(),\n            hex'20272077696474683d27', //\"' width='\",\n            (zoom * width).toString(),\n            hex'27206865696768743d27', //  \"' height='\",\n            (zoom * width).toString(),\n            hex'2720786d6c6e733d27687474703a2f2f7777772e77332e6f72672f323030302f7376672720786d6c6e733a786c696e6b3d27687474703a2f2f7777772e77332e6f72672f313939392f786c696e6b273e5c6e' // \"' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'>\\n\"\n        );\n\n        bytes memory footer = hex'3c2f7376673e';\n\n        uint256 last = getPixelAt(file, 0, 0, width);\n        uint256 count = 1;\n\n        // bytes[] memory rects = new bytes[](35);\n        bytes memory body;\n\n        for (uint256 y = 0; y < height; y++) {\n            for (uint256 x = 0; x < height; x++) {\n                if (y == 0 && x == 0) x++;\n                uint256 curr = getPixelAt(file, x, y, width);\n                if (curr == last) {\n                    count++;\n                    continue;\n                } else {\n                    // curr.log('yup');\n                    // rects[index++] = getRekt(last, x - count, y, count, 1);\n                    body = abi.encodePacked(body, getRekt(last, (x - count) * zoom, y * zoom, 1 * zoom, count * zoom));\n                    last = curr;\n                    count = 1;\n                }\n            }\n            // rects[index++] = getRekt(last, 33 - count, y, count, 1);\n            body = abi.encodePacked(body, getRekt(last, (width - count) * zoom, y * zoom, 1 * zoom, count * zoom));\n            last = 0;\n            count = 0;\n        }\n\n        res = abi.encodePacked(header, body, footer);\n    }\n\n    function getRekt(\n        uint256 pixel,\n        uint256 x,\n        uint256 y,\n        uint256 xlen,\n        uint256 ylen\n    ) internal pure returns (bytes memory res) {\n        if (pixel & 0xff == 0) return '';\n\n        res = abi.encodePacked(\n            \"\\t<rect fill='#\",\n            pixel.toHexStringNoPrefix(4),\n            hex'2720783d27',\n            x.toAscii(),\n            hex'2720793d27',\n            y.toAscii(),\n            hex'27206865696768743d27',\n            xlen.toAscii(),\n            hex'272077696474683d27',\n            ylen.toAscii(),\n            \"'/>\\n\"\n        );\n    }\n}\n"
    },
    "src/dotnuggV1Processer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport './interfaces/IdotnuggV1.sol';\n\nimport './logic/Calculator.sol';\nimport './logic/Matrix.sol';\nimport './logic/Svg.sol';\n\nimport './libraries/Base64.sol';\n\nimport './types/Version.sol';\n\n/// @title dotnugg Processor V1 - onchain encoder/decoder protocol for dotnugg files\n/// @author nugg.xyz - danny7even & dub6ix\n/// @notice yoU CAN'T HaVe ImAgES oN THe BlOCkcHAIn\n/// @dev hold my margarita\ncontract dotnuggV1Processor is IdotnuggV1Processor {\n    function process(\n        address implementer,\n        uint256 tokenId,\n        uint8 width\n    ) public view override returns (uint256[] memory resp, IdotnuggV1Data.Data memory dat) {\n        (uint256[][] memory files, IdotnuggV1Data.Data memory data) = IdotnuggV1Implementer(implementer).prepareFiles(tokenId);\n        dat = data;\n        resp = processCore(files, data, width);\n    }\n\n    function processCore(\n        uint256[][] memory files,\n        IdotnuggV1Data.Data memory data,\n        uint8 width\n    ) public view override returns (uint256[] memory resp) {\n        require(data.version == 1, 'V1');\n\n        require(width < 64 && width % 2 == 1, 'V1:SIZE');\n\n        Version.Memory[][] memory versions = Version.parse(files, data.xovers, data.yovers);\n\n        Types.Matrix memory old = Calculator.combine(8, width, versions);\n\n        resp = Version.bigMatrixWithData(old.version);\n    }\n\n    function resolveRaw(\n        uint256[] memory file,\n        IdotnuggV1Data.Data memory,\n        uint8\n    ) public pure override returns (uint256[] memory res) {\n        res = file;\n    }\n\n    function resolveBytes(\n        uint256[] memory file,\n        IdotnuggV1Data.Data memory data,\n        uint8\n    ) public pure override returns (bytes memory res) {\n        res = abi.encode(file, data);\n    }\n\n    function resolveData(\n        uint256[] memory,\n        IdotnuggV1Data.Data memory data,\n        uint8\n    ) public pure override returns (IdotnuggV1Data.Data memory res) {\n        res = data;\n    }\n\n    function resolveString(\n        uint256[] memory file,\n        IdotnuggV1Data.Data memory data,\n        uint8 zoom\n    ) public pure override returns (string memory) {\n        uint256 width = (file[file.length - 1] >> 63) & ShiftLib.mask(6);\n        uint256 height = (file[file.length - 1] >> 69) & ShiftLib.mask(6);\n\n        bytes memory working = Svg.buildSvg(file, width, height, zoom);\n\n        working = Base64._encode(working);\n\n        working = abi.encodePacked(\n            Base64.PREFIX_JSON,\n            Base64._encode(\n                bytes(\n                    abi.encodePacked(\n                        '{\"name\":\"',\n                        data.name,\n                        '\",\"description\":\"',\n                        data.desc,\n                        '\",\"dotnuggVersion\":\"',\n                        Uint256.toString(data.version),\n                        '\",\"tokenId\":\"',\n                        Uint256.toString(data.tokenId),\n                        '\",\"proof\":\"',\n                        Uint256.toHexString(data.proof, 32),\n                        '\",\"owner\":\"',\n                        Uint256.toHexString(uint160(data.owner), 20),\n                        '\", \"image\": \"',\n                        Base64.PREFIX_SVG,\n                        working,\n                        '\"}'\n                    )\n                )\n            )\n        );\n\n        return string(working);\n    }\n\n    function dotnuggToRaw(\n        address implementer,\n        uint256 tokenId,\n        address resolver,\n        uint8 width,\n        uint8 zoom\n    ) public view override returns (uint256[] memory res) {\n        (uint256[] memory file, IdotnuggV1Data.Data memory data) = process(implementer, tokenId, width);\n\n        if (resolver != address(0)) {\n            res = IdotnuggV1Processor(resolver).resolveRaw(res, data, zoom);\n        } else {\n            res = file;\n        }\n    }\n\n    function dotnuggToBytes(\n        address implementer,\n        uint256 tokenId,\n        address resolver,\n        uint8 width,\n        uint8 zoom\n    ) public view override returns (bytes memory res) {\n        (uint256[] memory file, IdotnuggV1Data.Data memory data) = process(implementer, tokenId, width);\n\n        res = IdotnuggV1Processor(resolver).resolveBytes(file, data, zoom);\n    }\n\n    function dotnuggToString(\n        address implementer,\n        uint256 tokenId,\n        address resolver,\n        uint8 width,\n        uint8 zoom\n    ) public view override returns (string memory res) {\n        (uint256[] memory file, IdotnuggV1Data.Data memory data) = process(implementer, tokenId, width);\n\n        res = IdotnuggV1Processor(resolver).resolveString(file, data, zoom);\n    }\n\n    function dotnuggToData(\n        address implementer,\n        uint256 tokenId,\n        address resolver,\n        uint8 width,\n        uint8 zoom\n    ) public view override returns (IdotnuggV1Data.Data memory res) {\n        (uint256[] memory file, IdotnuggV1Data.Data memory data) = process(implementer, tokenId, width);\n\n        res = IdotnuggV1Processor(resolver).resolveData(file, data, zoom);\n    }\n}\n"
    },
    "src/interfaces/IdotnuggV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IdotnuggV1Data {\n    struct Data {\n        uint256 version;\n        uint256 renderedAt;\n        string name;\n        string desc;\n        address owner;\n        uint256 tokenId;\n        uint256 proof;\n        uint8[] ids;\n        uint8[] extras;\n        uint8[] xovers;\n        uint8[] yovers;\n    }\n}\n\ninterface IdotnuggV1Resolver {\n    function resolveBytes(\n        uint256[] memory file,\n        IdotnuggV1Data.Data memory data,\n        uint8 zoom\n    ) external view returns (bytes memory res);\n\n    function resolveRaw(\n        uint256[] memory file,\n        IdotnuggV1Data.Data memory data,\n        uint8 zoom\n    ) external view returns (uint256[] memory res);\n\n    function resolveData(\n        uint256[] memory file,\n        IdotnuggV1Data.Data memory data,\n        uint8 zoom\n    ) external view returns (IdotnuggV1Data.Data memory res);\n\n    function resolveString(\n        uint256[] memory file,\n        IdotnuggV1Data.Data memory data,\n        uint8 zoom\n    ) external view returns (string memory res);\n}\n\ninterface IdotnuggV1Processor is IdotnuggV1Resolver {\n    function dotnuggToBytes(\n        address implementer,\n        uint256 tokenId,\n        address resolver,\n        uint8 width,\n        uint8 zoom\n    ) external view returns (bytes memory res);\n\n    function dotnuggToRaw(\n        address implementer,\n        uint256 tokenId,\n        address resolver,\n        uint8 width,\n        uint8 zoom\n    ) external view returns (uint256[] memory res);\n\n    function dotnuggToData(\n        address implementer,\n        uint256 tokenId,\n        address resolver,\n        uint8 width,\n        uint8 zoom\n    ) external view returns (IdotnuggV1Data.Data memory res);\n\n    function dotnuggToString(\n        address implementer,\n        uint256 tokenId,\n        address resolver,\n        uint8 width,\n        uint8 zoom\n    ) external view returns (string memory res);\n\n    function process(\n        address implementer,\n        uint256 tokenId,\n        uint8 width\n    ) external view returns (uint256[] memory file, IdotnuggV1Data.Data memory dat);\n\n    function processCore(\n        uint256[][] memory files,\n        IdotnuggV1Data.Data memory data,\n        uint8 width\n    ) external view returns (uint256[] memory file);\n}\n\ninterface IdotnuggV1Implementer {\n    function setResolver(uint256 tokenId, address to) external;\n\n    function resolverOf(uint256 tokenId) external view returns (address resolver);\n\n    function prepareFiles(uint256 tokenId) external view returns (uint256[][] memory file, IdotnuggV1Data.Data memory data);\n}\n"
    },
    "src/logic/Calculator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport './Matrix.sol';\nimport './Rgba.sol';\nimport './Anchor.sol';\n\nimport '../types/Descriptor.sol';\nimport '../types/Version.sol';\nimport '../types/Pixel.sol';\n\nimport '../types/Types.sol';\n\nlibrary Calculator {\n    using Rgba for Types.Rgba;\n    using Matrix for Types.Matrix;\n    using Pixel for uint256;\n\n    function combine(\n        uint256 featureLen,\n        uint8 width,\n        Version.Memory[][] memory versions\n    ) internal view returns (Types.Matrix memory resa) {\n        Types.Canvas memory canvas;\n        canvas.matrix = Matrix.create(width, width);\n        canvas.receivers = new Types.Anchor[](featureLen);\n        Types.Coordinate memory coord;\n        coord.a = width / 2 + 1;\n        coord.b = width / 2 + 1;\n        coord.exists = true;\n        Types.Rlud memory r;\n        for (uint8 i = 0; i < featureLen; i++) {\n            canvas.receivers[i] = Types.Anchor({coordinate: coord, radii: r});\n        }\n        canvas.matrix.width = width;\n        canvas.matrix.height = width;\n\n        Types.Mix memory mix;\n        mix.matrix = Matrix.create(width, width);\n        mix.receivers = new Types.Anchor[](featureLen);\n\n        // Types.Item[] memory items = Decoder.parseItems(inputs, featureLen);\n\n        for (uint8 i = 0; i < versions.length; i++) {\n            if (versions[i].length > 0) {\n                setMix(mix, versions[i], pickVersionIndex(canvas, versions[i]));\n\n                formatForCanvas(canvas, mix);\n\n                postionForCanvas(canvas, mix);\n\n                mergeToCanvas(canvas, mix);\n\n                calculateReceivers(mix);\n\n                updateReceivers(canvas, mix);\n            }\n        }\n\n        return canvas.matrix;\n    }\n\n    /**\n     * @notice\n     * @devg\n     */\n    function postionForCanvas(Types.Canvas memory canvas, Types.Mix memory mix) internal view {\n        Types.Anchor memory receiver = canvas.receivers[mix.feature];\n        Types.Anchor memory anchor = mix.version.anchor;\n\n        // (bool overExists, uint256 overX, uint256 overY) = Descriptor.receiverOverride(descriptor, mix.feature);\n\n        // if (overExists) {\n        //     receiver.coordinate.a = uint8(overX);\n        //     receiver.coordinate.b = uint8(overY);\n        // }\n\n        // uint256(mix.feature).log('mix.feature');\n\n        // uint256(anchor.coordinate.a).log(\n        //     'anchor.coordinate.a',\n        //     anchor.coordinate.b,\n        //     'anchor.coordinate.b',\n        //     receiver.coordinate.a,\n        //     'receiver.coordinate.a',\n        //     receiver.coordinate.b,\n        //     'receiver.coordinate.b'\n        // );\n        // (bool overrides, uint8 overrideX, uint8 overrideY) = Version.getOverrides(mix.matrix.version);\n\n        // if (overrides && overrideX < canvas.matrix.width && overrideY < canvas.matrix.height) {\n        //     mix.xoffset = overrideX;\n        //     mix.yoffset = overrideY;\n        // } else {\n        mix.xoffset = receiver.coordinate.a > anchor.coordinate.a ? receiver.coordinate.a - anchor.coordinate.a : 0;\n        mix.yoffset = receiver.coordinate.b > anchor.coordinate.b ? receiver.coordinate.b - anchor.coordinate.b : 0;\n        // }\n\n        canvas.matrix.moveTo(mix.xoffset, mix.yoffset, mix.matrix.width, mix.matrix.height);\n    }\n\n    /**\n     * @notice\n     * @dev\n     */\n    function formatForCanvas(Types.Canvas memory canvas, Types.Mix memory mix) internal pure {\n        Types.Anchor memory receiver = canvas.receivers[mix.feature];\n        Types.Anchor memory anchor = mix.version.anchor;\n\n        if (mix.version.expanders.l != 0 && anchor.radii.l != 0 && anchor.radii.l <= receiver.radii.l) {\n            uint8 amount = receiver.radii.l - anchor.radii.l;\n            mix.matrix.addColumnsAt(mix.version.expanders.l - 1, amount);\n            anchor.coordinate.a += amount;\n            if (mix.version.expanders.r > 0) mix.version.expanders.r += amount;\n        }\n        if (mix.version.expanders.r != 0 && anchor.radii.r != 0 && anchor.radii.r <= receiver.radii.r) {\n            mix.matrix.addColumnsAt(mix.version.expanders.r - 1, receiver.radii.r - anchor.radii.r);\n        }\n        if (mix.version.expanders.d != 0 && anchor.radii.d != 0 && anchor.radii.d <= receiver.radii.d) {\n            uint8 amount = receiver.radii.d - anchor.radii.d;\n            mix.matrix.addRowsAt(mix.version.expanders.d, amount);\n            anchor.coordinate.b += amount;\n            if (mix.version.expanders.u > 0) mix.version.expanders.u += amount;\n        }\n        if (mix.version.expanders.u != 0 && anchor.radii.u != 0 && anchor.radii.u <= receiver.radii.u) {\n            mix.matrix.addRowsAt(mix.version.expanders.u, receiver.radii.u - anchor.radii.u);\n        }\n    }\n\n    /**\n     * @notice\n     * @dev\n     * makes the sorts versions\n     */\n    function pickVersionIndex(Types.Canvas memory canvas, Version.Memory[] memory versions) internal pure returns (uint8) {\n        require(versions.length > 0, 'CALC:PVI:0');\n        if (versions.length == 1) {\n            return 0;\n        }\n        uint8 index = uint8(versions.length) - 1;\n\n        uint256 feature = (versions[0].data >> 75) & ShiftLib.mask(3);\n\n        while (index > 0) {\n            uint256 bits = (versions[index].data >> 27) & ShiftLib.mask(24);\n            Types.Rlud memory anchorRadii = Types.Rlud({\n                r: uint8((bits >> 18) & ShiftLib.mask(6)),\n                l: uint8((bits >> 12) & ShiftLib.mask(6)),\n                u: uint8((bits >> 6) & ShiftLib.mask(6)),\n                d: uint8((bits) & ShiftLib.mask(6)),\n                exists: true\n            });\n\n            if (checkRluds(anchorRadii, canvas.receivers[feature].radii)) {\n                return index;\n            }\n            index = index - 1;\n        }\n\n        return 0;\n    }\n\n    function checkRluds(Types.Rlud memory r1, Types.Rlud memory r2) internal pure returns (bool) {\n        return (r1.r <= r2.r && r1.l <= r2.l) || (r1.u <= r2.u && r1.d <= r2.d);\n    }\n\n    /**\n     * @notice\n     * @dev done\n     * makes the sorts versions\n     */\n    function setMix(\n        Types.Mix memory res,\n        Version.Memory[] memory versions,\n        uint8 versionIndex\n    ) internal view {\n        uint256 radiiBits = (versions[versionIndex].data >> 27) & ShiftLib.mask(24);\n        uint256 expanderBits = (versions[versionIndex].data >> 3) & ShiftLib.mask(24);\n\n        (uint256 x, uint256 y) = Version.getAnchor(versions[versionIndex]);\n\n        (uint256 width, uint256 height) = Version.getWidth(versions[versionIndex]);\n\n        res.version.width = uint8(width);\n        res.version.height = uint8(height);\n        res.version.anchor = Types.Anchor({\n            radii: Types.Rlud({\n                r: uint8((radiiBits >> 18) & ShiftLib.mask(6)),\n                l: uint8((radiiBits >> 12) & ShiftLib.mask(6)),\n                u: uint8((radiiBits >> 6) & ShiftLib.mask(6)),\n                d: uint8((radiiBits >> 0) & ShiftLib.mask(6)),\n                exists: true\n            }),\n            coordinate: Types.Coordinate({a: uint8(x), b: uint8(y), exists: true})\n        });\n        res.version.expanders = Types.Rlud({\n            r: uint8((expanderBits >> 18) & ShiftLib.mask(6)),\n            l: uint8((expanderBits >> 12) & ShiftLib.mask(6)),\n            u: uint8((expanderBits >> 6) & ShiftLib.mask(6)),\n            d: uint8((expanderBits >> 0) & ShiftLib.mask(6)),\n            exists: true\n        });\n        res.version.calculatedReceivers = new Types.Coordinate[](8);\n\n        res.version.staticReceivers = new Types.Coordinate[](8);\n\n        for (uint256 i = 0; i < 8; i++) {\n            (uint256 _x, uint256 _y, bool exists) = Version.getReceiverAt(versions[versionIndex], i, false);\n            if (exists) {\n                res.version.staticReceivers[i].a = uint8(_x);\n                res.version.staticReceivers[i].b = uint8(_y);\n                res.version.staticReceivers[i].exists = true;\n            }\n        }\n\n        for (uint256 i = 0; i < 8; i++) {\n            (uint256 _x, uint256 _y, bool exists) = Version.getReceiverAt(versions[versionIndex], i, true);\n            if (exists) {\n                res.version.calculatedReceivers[i].a = uint8(_x);\n                res.version.calculatedReceivers[i].b = uint8(_y);\n                res.version.calculatedReceivers[i].exists = true;\n            }\n        }\n\n        // TODO - receivers?\n        res.xoffset = 0;\n        res.yoffset = 0;\n        res.receivers = new Types.Anchor[](res.receivers.length);\n        res.feature = uint8((versions[versionIndex].data >> 75) & ShiftLib.mask(3));\n        res.matrix.set(versions[versionIndex], width, height);\n    }\n\n    /**\n     * @notice done\n     * @dev\n     */\n    function updateReceivers(Types.Canvas memory canvas, Types.Mix memory mix) internal pure {\n        for (uint8 i = 0; i < mix.receivers.length; i++) {\n            Types.Anchor memory m = mix.receivers[i];\n            if (m.coordinate.exists) {\n                m.coordinate.a += mix.xoffset;\n                m.coordinate.b += mix.yoffset;\n                canvas.receivers[i] = m;\n            }\n        }\n    }\n\n    /**\n     * @notice done\n     * @dev\n     */\n    function mergeToCanvas(Types.Canvas memory canvas, Types.Mix memory mix) internal view {\n        // uint256 count;\n        // uint256 count;\n        while (canvas.matrix.next() && mix.matrix.next()) {\n            uint256 canvasPixel = canvas.matrix.current();\n            uint256 mixPixel = mix.matrix.current();\n\n            // if (mixPixel != 0 || canvasPixel != 0) {\n            //     // assert(count++ < 100);\n            //     // mixPixel.log('mixPixel', mixPixel.z(), 'mixPixel.z()', canvasPixel.z(), 'canvasPixel.z()');\n            //     // canvasPixel.log('canvasPixel');\n            // }\n            // assert(mixPixel.e() && mixPixel.z() >= canvasPixel.z());\n\n            if (mixPixel.e() && mixPixel.z() >= canvasPixel.z()) {\n                // canvasPixel.z() = mixPixel.z();\n\n                canvas.matrix.setCurrent(Rgba.combine(canvasPixel, mixPixel));\n            }\n        }\n        canvas.matrix.moveBack();\n        canvas.matrix.resetIterator();\n        mix.matrix.resetIterator();\n    }\n\n    /**\n     * @notice poop\n     * @dev\n     */\n    function calculateReceivers(Types.Mix memory mix) internal pure {\n        Anchor.convertReceiversToAnchors(mix);\n    }\n\n    // you combine one by one, and as you combine, child refs get overridden\n\n    // function add(Combinable comb, )\n}\n// add parent refs, if any - will use remys algo only for the canvas\n// the canvas will always be defined as the first, so if it isnt (will not happen for dotnugg), we define the center as all the child refs\n//  pick best version\n// figure out offset\n\n// function merge(Canvas memory canvas, Matrix memory versionMatrix) internal pure {\n//     for (int8 y = (canvas.matrix.data.length / 2) * -1; y <= canvas.matrix.data.length / 2; y++) {\n//         for (int8 x = (canvas.matrix.width / 2) * -1; x <= canvas.matrix[j].width / 2; x++) {\n//             Pixel memory canvas = canvas.matrix.at(x, y);\n//             Pixel memory addr = combinable.matrix.at(x, y);\n\n//             if (addr != 0 && addr.layer > canvas.layer) {\n//                 canvas.layer = addr.layer;\n//                 canvas.rgba = Colors.combine(canvas.rgba, add.rgba);\n//             }\n//         }\n//     }\n// }\n// Oh my god\n// Becky, look at her butt\n// Its so big\n// She looks like one of those rap guys girlfriends\n// Who understands those rap guys\n// They only talk to her because she looks like a total prostitute\n// I mean her butt\n// It's just so big\n// I can't believe it's so round\n// It's just out there\n// I mean, it's gross\n// Look, she's just so black\n\n// *rap*\n// I like big butts and I can not lie\n// You other brothers can't deny\n// That when a girl walks in with an itty bitty waist\n// And a round thing in your face\n// You get sprung\n// Wanna pull up tough\n// Cuz you notice that butt was stuffed\n// Deep in the jeans she's wearing\n// I'm hooked and I can't stop staring\n// Oh, baby I wanna get with ya\n// And take your picture\n// My homeboys tried to warn me\n// But that butt you got\n// Make Me so horney\n// Ooh, rump of smooth skin\n// You say you wanna get in my benz\n// Well use me use me cuz you aint that average groupy\n\n// I've seen them dancin'\n// The hell with romancin'\n// She's Sweat,Wet, got it goin like a turbo vette\n\n// I'm tired of magazines\n// Saying flat butts are the thing\n// Take the average black man and ask him that\n// She gotta pack much back\n\n// So Fellas (yeah) Fellas(yeah)\n// Has your girlfriend got the butt (hell yeah)\n// Well shake it, shake it, shake it, shake it, shake that healthy butt\n// Baby got back\n\n// (LA face with Oakland booty)\n\n// I like'em round and big\n// And when I'm throwin a gig\n// I just can't help myself\n// I'm actin like an animal\n// Now here's my scandal\n\n// I wanna get you home\n// And UH, double up UH UH\n// I aint talkin bout playboy\n// Cuz silicone parts were made for toys\n// I wannem real thick and juicy\n// So find that juicy double\n// Mixalot's in trouble\n// Beggin for a piece of that bubble\n// So I'm lookin' at rock videos\n// Knockin these bimbos walkin like hoes\n// You can have them bimbos\n// I'll keep my women like Flo Jo\n// A word to the thick soul sistas\n// I wanna get with ya\n// I won't cus or hit ya\n// But I gotta be straight when I say I wanna --\n// Til the break of dawn\n// Baby Got it goin on\n// Alot of pimps won't like this song\n// Cuz them punks lie to hit it and quit it\n// But I'd rather stay and play\n// Cuz I'm long and I'm strong\n// And I'm down to get the friction on\n\n// So ladies (yeah), Ladies (yeah)\n// Do you wanna roll in my Mercedes (yeah)\n// Then turn around\n// Stick it out\n// Even white boys got to shout\n// Baby got back\n\n// (LA face with the Oakland booty)\n\n// Yeah baby\n// When it comes to females\n// Cosmo ain't got nothin to do with my selection\n// 36-24-36\n// Only if she's 5'3\"\n\n// So your girlfriend throws a Honda\n// Playin workout tapes by Fonda\n// But Fonda ain't got a motor in the back of her Honda\n// My anaconda don't want none unless you've got buns hun\n// You can do side bends or sit-ups, but please don't lose that butt\n// Some brothers wanna play that hard role\n// And tell you that the butt ain't gold\n// So they toss it and leave it\n// And I pull up quick to retrieve it\n// So cosmo says you're fat\n// Well I ain't down with that\n// Cuz your waste is small and your curves are kickin\n// And I'm thinkin bout stickin\n// To the beanpole dames in the magazines\n// You aint it miss thing\n// Give me a sista I can't resist her\n// Red beans and rice did miss her\n// Some knucklehead tried to dis\n// Cuz his girls were on my list\n// He had game but he chose to hit 'em\n// And pulled up quick to get with 'em\n// So ladies if the butt is round\n// And you wanna triple X throw down\n// Dial 1-900-MIXALOT and kick them nasty thoughts\n// Baby got back\n// Baby got back\n// Little in tha middle but she got much back x4\n"
    },
    "src/logic/Matrix.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {Types} from '../types/Types.sol';\n\nimport '../logic/Rgba.sol';\n\nimport '../types/Version.sol';\n\nlibrary Matrix {\n    using Rgba for Types.Rgba;\n    using Version for Version.Memory;\n\n    function create(uint8 width, uint8 height) internal pure returns (Types.Matrix memory res) {\n        require(width % 2 == 1 && height % 2 == 1, 'ML:C:0');\n\n        Version.initBigMatrix(res.version, width);\n        res.version.setWidth(width, height);\n\n        // res.data = new Types.Pixel[][](height);\n        // for (uint8 i = 0; i < height; i++) {\n        //     res.data[i] = new Types.Pixel[](width);\n        // }\n    }\n\n    function moveTo(\n        Types.Matrix memory matrix,\n        uint8 xoffset,\n        uint8 yoffset,\n        uint8 width,\n        uint8 height\n    ) internal pure {\n        matrix.currentUnsetX = xoffset;\n        matrix.currentUnsetY = yoffset;\n        matrix.startX = xoffset;\n        matrix.width = width + xoffset;\n        matrix.height = height + yoffset;\n    }\n\n    function next(Types.Matrix memory matrix) internal pure returns (bool res) {\n        res = next(matrix, matrix.width);\n    }\n\n    function next(Types.Matrix memory matrix, uint8 width) internal pure returns (bool res) {\n        if (matrix.init) {\n            if (width <= matrix.currentUnsetX + 1) {\n                if (matrix.height == matrix.currentUnsetY + 1) {\n                    return false;\n                }\n                matrix.currentUnsetX = matrix.startX; // 0 by default\n                matrix.currentUnsetY++;\n            } else {\n                matrix.currentUnsetX++;\n            }\n        } else {\n            matrix.init = true;\n        }\n        res = true;\n    }\n\n    function current(Types.Matrix memory matrix) internal pure returns (uint256 res) {\n        res = matrix.version.getBigMatrixPixelAt(matrix.currentUnsetX, matrix.currentUnsetY);\n    }\n\n    function setCurrent(Types.Matrix memory matrix, uint256 pixel) internal pure {\n        matrix.version.setBigMatrixPixelAt(matrix.currentUnsetX, matrix.currentUnsetY, pixel);\n    }\n\n    function resetIterator(Types.Matrix memory matrix) internal pure {\n        matrix.currentUnsetX = 0;\n        matrix.currentUnsetY = 0;\n        matrix.startX = 0;\n        matrix.init = false;\n    }\n\n    function moveBack(Types.Matrix memory matrix) internal pure {\n        (uint256 width, uint256 height) = matrix.version.getWidth();\n        matrix.width = uint8(width);\n        matrix.height = uint8(height);\n    }\n\n    function set(\n        Types.Matrix memory matrix,\n        Version.Memory memory data,\n        uint256 groupWidth,\n        uint256 groupHeight\n    ) internal view {\n        matrix.height = uint8(groupHeight);\n        uint256 feature = data.getFeature();\n\n        for (uint256 y = 0; y < groupHeight; y++) {\n            for (uint256 x = 0; x < groupWidth; x++) {\n                next(matrix, uint8(groupWidth));\n                uint256 col = Version.getPixelAt(data, x, y);\n                if (col != 0) {\n                    (, uint256 color, uint256 zindex) = Version.getPalletColorAt(data, col);\n                    // (zindex).log('zindex', (zindex << 32), '<< 32', (feature << 36) | (zindex << 32) | color, 'whole');\n                    setCurrent(matrix, (feature << 36) | (zindex << 32) | color);\n                } else {\n                    setCurrent(matrix, 0x0000000000);\n                }\n            }\n        }\n\n        // require(totalLength % groupWidth == 0, 'MTRX:SET:0');\n        // require(totalLength / groupWidth == groupHeight, 'MTRX:SET:1');\n\n        matrix.width = uint8(groupWidth);\n        // // matrix.height = uint8(totalLength / groupWidth);\n\n        resetIterator(matrix);\n    }\n\n    function addRowsAt(\n        Types.Matrix memory matrix, /// cowboy hat\n        uint8 index,\n        uint8 amount\n    ) internal pure {\n        // require(index < matrix.data[0].length, 'MAT:ACA:0');\n        for (uint256 i = 0; i < matrix.height; i++) {\n            for (uint256 j = matrix.height; j > index; j--) {\n                if (j < index) break;\n                matrix.version.setBigMatrixPixelAt(i, j + amount, matrix.version.getBigMatrixPixelAt(i, j));\n            }\n            // \"<=\" is because this loop needs to run [amount] times\n            for (uint256 j = index + 1; j <= index + amount; j++) {\n                matrix.version.setBigMatrixPixelAt(i, j, matrix.version.getBigMatrixPixelAt(i, index));\n            }\n        }\n        matrix.height += amount;\n    }\n\n    function addColumnsAt(\n        Types.Matrix memory matrix, /// cowboy hat\n        uint8 index,\n        uint8 amount\n    ) internal pure {\n        // require(index < matrix.data[0].length, 'MAT:ACA:0');\n        for (uint256 i = 0; i < matrix.width; i++) {\n            for (uint256 j = matrix.width; j > index; j--) {\n                if (j < index) break;\n                matrix.version.setBigMatrixPixelAt(j + amount, i, matrix.version.getBigMatrixPixelAt(j, i));\n            }\n            // \"<=\" is because this loop needs to run [amount] times\n            for (uint256 j = index + 1; j <= index + amount; j++) {\n                matrix.version.setBigMatrixPixelAt(j, i, matrix.version.getBigMatrixPixelAt(index, i));\n            }\n        }\n        matrix.width += amount;\n    }\n}\n"
    },
    "src/libraries/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\n/**\n * @title Base64\n * @author Nugg Labs - @danny7even & @dub6ix\n * @notice library for encoding bytes into base64\n */\nlibrary Base64 {\n    string internal constant _TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    string internal constant PREFIX_JSON = 'data:application/json;base64,';\n    string internal constant PREFIX_DOTNUGG = 'data:image/dotnugg;base64,';\n    string internal constant PREFIX_SVG = 'data:image/svg+xml;base64,';\n\n    /**\n     * @notice wrapper for _encode for svg data\n     * @param data bytes to encode\n     * @return base64 string representation of input bytes, prefixed with json base64 prefix\n     */\n    function encode(bytes memory data, string memory file) internal pure returns (string memory) {\n        return string(abi.encodePacked('data:', file, ';base64,', _encode(data)));\n    }\n\n    /**\n     * @notice Encodes some bytes in base64\n     * @param data bytes to encode\n     * @return base64 string representation of input bytes\n     * @dev Credit to Brecht Devos - <brecht@loopring.org> - under MIT license https://github.com/Brechtpd/base64/blob/main/base64.sol\n     * @dev modified for solidity v8\n     */\n    function _encode(bytes memory data) internal pure returns (bytes memory) {\n        if (data.length == 0) return '';\n\n        // load the table into memory\n        string memory table = _TABLE;\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n\n        // add some extra buffer at the end required for the writing\n        bytes memory result = new bytes(encodedLen + 32);\n\n        assembly {\n            // set the actual output length\n            mstore(result, encodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 3 bytes at a time\n            for {\n\n            } lt(dataPtr, endPtr) {\n\n            } {\n                dataPtr := add(dataPtr, 3)\n\n                // read 3 bytes\n                let input := mload(dataPtr)\n\n                // write 4 characters\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(6, input), 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(input, 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n            }\n\n            // padding with '='\n            switch mod(mload(data), 3)\n            case 1 {\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\n            }\n            case 2 {\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\n            }\n        }\n\n        return result;\n    }\n}\n"
    },
    "src/types/Version.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {ShiftLib} from '../libraries/ShiftLib.sol';\nimport {BitReader} from '../libraries/BitReader.sol';\nimport {SafeCastLib} from '../libraries/SafeCastLib.sol';\n\nlibrary Version {\n    using BitReader for BitReader.Memory;\n    using SafeCastLib for uint256;\n\n    struct Memory {\n        uint256[] pallet;\n        uint256[] minimatrix;\n        uint256[] bigmatrix;\n        uint256 receivers;\n        uint256 data;\n    }\n\n    function parse(\n        uint256[][] memory data,\n        uint8[] memory xovers,\n        uint8[] memory yovers\n    ) internal view returns (Memory[][] memory m) {\n        m = new Memory[][](data.length);\n\n        for (uint256 j = 0; j < data.length; j++) {\n            (bool empty, BitReader.Memory memory reader) = BitReader.init(data[j]);\n\n            if (empty) continue;\n\n            // 32 bits: NUGG\n            require(reader.select(32) == 0x4e554747, 'DEC:PI:0');\n\n            uint256 feature = reader.select(3);\n\n            uint256[] memory pallet = parsePallet(reader);\n\n            uint256 versionLength = reader.select(2) + 1;\n\n            m[j] = new Memory[](versionLength);\n\n            for (uint256 i = 0; i < versionLength; i++) {\n                m[j][i].data = parseData(reader, feature, xovers, yovers);\n\n                m[j][i].receivers = parseReceivers(reader);\n\n                (uint256 width, uint256 height) = getWidth(m[j][i]);\n\n                m[j][i].minimatrix = parseMiniMatrix(reader, width, height);\n\n                m[j][i].pallet = pallet;\n\n                // (uint256 ancX, uint256 ancY) = getAnchor(m[j][i]);\n                // (, , uint256 ancZ) = getPalletColorAt(m[j][i], getPixelAt(m[j][i], ancX, ancY));\n\n                // setZ(m[j][i], ancZ);\n            }\n        }\n    }\n\n    function parsePallet(BitReader.Memory memory reader) internal pure returns (uint256[] memory res) {\n        uint256 palletLength = reader.select(4) + 1;\n\n        res = new uint256[](palletLength + 1);\n\n        for (uint256 i = 0; i < palletLength; i++) {\n            uint256 working = 0;\n            // 4 bits: zindex\n            working |= (reader.select(4) << 32);\n\n            uint256 color;\n            uint256 selecta = reader.select(1);\n            if (selecta == 1) {\n                color = 0x000000;\n            } else {\n                uint256 r = reader.select(8);\n                uint256 g = reader.select(8);\n                uint256 b = reader.select(8);\n\n                color = (r << 16) | (g << 8) | b;\n            }\n\n            // // 1 or 25 bits: rgb\n            working |= color << 8;\n\n            // // 1 or 8 bits: a\n            working |= (reader.select(1) == 0x1 ? 0xff : reader.select(8));\n\n            res[i + 1] = working;\n        }\n    }\n\n    function parseData(\n        BitReader.Memory memory reader,\n        uint256 feature,\n        uint8[] memory xovers,\n        uint8[] memory yovers\n    ) internal pure returns (uint256 res) {\n        // 12 bits: coordinate - anchor x and y\n\n        // if (xovers.length == 8 && yovers.length == 8 && (xovers[feature] != 0 || yovers[feature] != 0)) {\n        //     res |= uint256(uint256(yovers[feature]).safe6()) << 84;\n        //     res |= uint256(uint256(xovers[feature]).safe6()) << 78;\n        // }\n\n        res |= feature << 75;\n\n        uint256 width = reader.select(6);\n        uint256 height = reader.select(6);\n\n        res |= height << 69; // heighth and width\n        res |= width << 63;\n\n        uint256 anchorX = reader.select(6);\n        uint256 anchorY = reader.select(6);\n\n        if (xovers.length == 8 && yovers.length == 8 && (xovers[feature] != 0 || yovers[feature] != 0)) {\n            res |= uint256(yovers[feature]) << 57;\n            res |= uint256(xovers[feature]) << 51;\n        } else {\n            // 12 bits: coordinate - anchor x and y\n            res |= anchorX << 51;\n            res |= anchorY << 57;\n        }\n\n        // 1 or 25 bits: rlud - radii\n        res |= (reader.select(1) == 0x1 ? 0x000000 : reader.select(24)) << 27;\n\n        // 1 or 25 bits: rlud - expanders\n        res |= (reader.select(1) == 0x1 ? 0x000000 : reader.select(24)) << 3;\n    }\n\n    function parseReceivers(BitReader.Memory memory reader) internal pure returns (uint256 res) {\n        uint256 receiversLength = reader.select(1) == 0x1 ? 0x1 : reader.select(4);\n\n        for (uint256 j = 0; j < receiversLength; j++) {\n            uint256 receiver = 0;\n\n            uint256 yOrYOffset = reader.select(6);\n\n            uint256 xOrPreset = reader.select(6);\n\n            // rFeature\n            uint256 rFeature = reader.select(3);\n\n            uint256 calculated = reader.select(1);\n\n            if (calculated == 0x1) {\n                receiver |= yOrYOffset << 6;\n                receiver |= xOrPreset;\n            } else {\n                receiver |= xOrPreset << 6;\n                receiver |= yOrYOffset;\n            }\n\n            receiver <<= ((rFeature * 12) + (calculated == 0x1 ? 128 : 0));\n\n            res |= receiver;\n        }\n    }\n\n    function parseMiniMatrix(\n        BitReader.Memory memory reader,\n        uint256 height,\n        uint256 width\n    ) internal pure returns (uint256[] memory res) {\n        uint256 groupsLength = reader.select(1) == 0x1 ? reader.select(8) + 1 : reader.select(16) + 1;\n\n        res = new uint256[]((height * width) / 64 + 1);\n\n        uint256 index = 0;\n\n        for (uint256 a = 0; a < groupsLength; a++) {\n            uint256 len = reader.select(2) + 1;\n\n            if (len == 4) len = reader.select(4) + 4;\n\n            uint256 key = reader.select(4);\n\n            for (uint256 i = 0; i < len; i++) {\n                res[index / 64] |= (key << (4 * (index % 64)));\n                index++;\n            }\n        }\n    }\n\n    function getReceiverAt(\n        Memory memory m,\n        uint256 index,\n        bool calculated\n    )\n        internal\n        pure\n        returns (\n            uint256 x,\n            uint256 y,\n            bool exists\n        )\n    {\n        uint256 data = m.receivers >> (index * 12 + (calculated ? 128 : 0));\n\n        data &= ShiftLib.mask(12);\n\n        x = data & ShiftLib.mask(6);\n        y = data >> 6;\n\n        exists = x != 0 || y != 0;\n    }\n\n    function setReceiverAt(\n        Memory memory m,\n        uint256 index,\n        bool calculated,\n        uint256 x,\n        uint256 y\n    ) internal pure returns (uint256 res) {\n        // yOrYOffset\n        res |= y << 6;\n\n        //xOrPreset\n        res |= x;\n\n        m.receivers |= res << ((index * 12) + (calculated ? 128 : 0));\n    }\n\n    function setOffset(\n        Memory memory m,\n        bool negX,\n        uint256 diffX,\n        bool negY,\n        uint256 diffY\n    ) internal pure {\n        m.data |= ((((diffX & 0xff) << 1) | (((negX ? 0x1 : 0x0)))) << 85);\n        m.data |= ((((diffY & 0xff) << 1) | ((((negY ? 0x1 : 0x0))))) << 94);\n    }\n\n    function getOffset(Memory memory m)\n        internal\n        pure\n        returns (\n            bool negX,\n            uint256 diffX,\n            bool negY,\n            uint256 diffY\n        )\n    {\n        uint256 data = m.data;\n        negX = (data >> 85) & 0x1 == 1;\n        diffX = (data >> 86) & 0xff;\n        negY = (data >> 94) & 0x1 == 1;\n        diffY = (data >> 95) & 0xff;\n    }\n\n    function setZ(Memory memory m, uint256 z) internal pure {\n        require(z <= 0xf, 'VERS:SETZ:0');\n        m.data |= z << 78;\n    }\n\n    function getZ(Memory memory m) internal pure returns (uint256 res) {\n        res = (m.data >> 78) & 0xf;\n    }\n\n    function setFeature(Memory memory m, uint256 z) internal pure {\n        require(z <= ShiftLib.mask(3), 'VERS:SETF:0');\n        m.data &= ShiftLib.fullsubmask(3, 75);\n        m.data |= (z << 75);\n    }\n\n    function getFeature(Memory memory m) internal pure returns (uint256 res) {\n        res = (m.data >> 75) & ShiftLib.mask(3);\n    }\n\n    function getWidth(Memory memory m) internal pure returns (uint256 width, uint256 height) {\n        // yOrYOffset\n        width = (m.data >> 63) & ShiftLib.mask(6);\n        height = (m.data >> 69) & ShiftLib.mask(6);\n    }\n\n    function setWidth(\n        Memory memory m,\n        uint256 w,\n        uint256 h\n    ) internal pure {\n        require(w <= ShiftLib.mask(6), 'VERS:SETW:0');\n        require(h <= ShiftLib.mask(6), 'VERS:SETW:1');\n\n        m.data &= ShiftLib.fullsubmask(12, 63);\n\n        m.data |= (w << 63);\n        m.data |= (h << 69);\n    }\n\n    function getAnchor(Memory memory m) internal pure returns (uint256 x, uint256 y) {\n        // yOrYOffset\n        x = (m.data >> 51) & ShiftLib.mask(6);\n        y = (m.data >> 57) & ShiftLib.mask(6);\n    }\n\n    function getOverrides(Memory memory m)\n        internal\n        pure\n        returns (\n            bool shouldOverride,\n            uint8 x,\n            uint8 y\n        )\n    {\n        // yOrYOffset\n        x = uint8((m.data >> 78) & ShiftLib.mask(6));\n        y = uint8((m.data >> 84) & ShiftLib.mask(6));\n\n        shouldOverride = x != 0 && y != 0;\n    }\n\n    function getPixelAt(\n        Memory memory m,\n        uint256 x,\n        uint256 y\n    ) internal pure returns (uint256 palletKey) {\n        (uint256 width, ) = getWidth(m);\n        uint256 index = x + (y * width);\n\n        if (index / 64 >= m.minimatrix.length) return 0x0;\n\n        palletKey = (m.minimatrix[index / 64] >> (4 * (index % 64))) & 0xf;\n    }\n\n    function getPalletColorAt(Memory memory m, uint256 index)\n        internal\n        pure\n        returns (\n            uint256 res,\n            uint256 color,\n            uint256 zindex\n        )\n    {\n        // res = (m.pallet[index / 7] >> (36 * (index % 7))) & ShiftLib.mask(36);\n        res = m.pallet[index];\n\n        color = res & 0xffffffff;\n\n        zindex = (res >> 32) & 0xf;\n    }\n\n    // function getDiffOfReceiverAt(Memory memory base, Memory memory mix)\n    //     internal\n    //     pure\n    //     returns (\n    //         bool negX,\n    //         uint256 diffX,\n    //         bool negY,\n    //         uint256 diffY\n    //     )\n    // {\n    //     (uint256 recX, uint256 recY, ) = getReceiverAt(base, (mix.data >> 75) & ShiftLib.mask(3), false);\n    //     (uint256 ancX, uint256 ancY, ) = getAnchor(mix);\n\n    //     negX = recX < ancX;\n    //     diffX = negX ? ancX - recX : recX - ancX;\n    //     negY = recY < ancY;\n    //     diffY = negY ? ancY - recY : recY - ancY;\n    // }\n\n    function initBigMatrix(Memory memory m, uint256 width) internal pure {\n        m.bigmatrix = new uint256[](((width * width) / 6) + 2);\n    }\n\n    function setBigMatrixPixelAt(\n        Memory memory m,\n        uint256 x,\n        uint256 y,\n        uint256 color\n    ) internal pure {\n        (uint256 width, ) = getWidth(m);\n\n        uint256 index = x + (y * width);\n\n        // m.bigmatrix[index / 6] |= (color << (40 * (index % 6)));\n\n        setBigMatrixPixelAt(m, index, color);\n    }\n\n    function setBigMatrixPixelAt(\n        Memory memory m,\n        uint256 index,\n        uint256 color\n    ) internal pure {\n        // require(m.bigmatrix.length > index / 6, 'VERS:SBM:0');\n\n        if (m.bigmatrix.length > index / 6) {\n            uint8 offset = (40 * (index % 6)).safe8();\n            m.bigmatrix[index / 6] &= ShiftLib.fullsubmask(40, offset);\n            m.bigmatrix[index / 6] |= (color << offset);\n        }\n    }\n\n    function getBigMatrixPixelAt(\n        Memory memory m,\n        uint256 x,\n        uint256 y\n    ) internal pure returns (uint256 res) {\n        (uint256 width, ) = getWidth(m);\n\n        uint256 index = x + (y * width);\n\n        if (index / 6 >= m.bigmatrix.length) return 0x0000000000;\n\n        res = (m.bigmatrix[index / 6] >> (40 * (index % 6))) & 0xffffffffff;\n    }\n\n    function bigMatrixHasPixelAt(\n        Memory memory m,\n        uint256 x,\n        uint256 y\n    ) internal pure returns (bool res) {\n        uint256 pix = getBigMatrixPixelAt(m, x, y);\n\n        res = pix & 0xff != 0x00;\n    }\n\n    function bigMatrixWithData(Memory memory m) internal pure returns (uint256[] memory res) {\n        res = m.bigmatrix;\n        res[res.length - 1] = m.data;\n    }\n}\n"
    },
    "src/logic/Rgba.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {Types} from '../types/Types.sol';\n\nimport '../types/Pixel.sol';\n\nlibrary Rgba {\n    using Pixel for uint256;\n\n    function combine(uint256 base, uint256 mix) internal pure returns (uint256 res) {\n        if (mix.a() == 255 || base.a() == 0) {\n            res = mix;\n            return res;\n        }\n\n        res |= uint256((base.r() * (255 - mix.a()) + mix.r() * mix.a()) / 255) << 24;\n        res |= uint256((base.g() * (255 - mix.a()) + mix.g() * mix.a()) / 255) << 16;\n        res |= uint256((base.b() * (255 - mix.a()) + mix.b() * mix.a()) / 255) << 8;\n        res |= 255;\n    }\n}\n"
    },
    "src/logic/Anchor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport '../types/Types.sol';\nimport './Matrix.sol';\n\nlibrary Anchor {\n    using Matrix for Types.Matrix;\n    using Version for Version.Memory;\n\n    function convertReceiversToAnchors(Types.Mix memory mix) internal pure {\n        Types.Coordinate[] memory anchors;\n        uint8 stat = 0;\n        uint8 cal = 0;\n\n        for (uint8 i = 0; i < mix.version.staticReceivers.length; i++) {\n            Types.Coordinate memory coordinate;\n            if (mix.version.staticReceivers[i].exists) {\n                stat++;\n                coordinate = mix.version.staticReceivers[i];\n                mix.receivers[i].coordinate.a = coordinate.b;\n                mix.receivers[i].coordinate.b = coordinate.a;\n                mix.receivers[i].coordinate.exists = true;\n            } else if (mix.version.calculatedReceivers[i].exists) {\n                // if (mix.feature != 0) continue;\n\n                cal++;\n                if (anchors.length == 0) anchors = getAnchors(mix.matrix);\n                coordinate = calculateReceiverCoordinate(mix, mix.version.calculatedReceivers[i], anchors);\n                fledgeOutTheRluds(mix, coordinate, i);\n            }\n        }\n    }\n\n    function fledgeOutTheRluds(\n        Types.Mix memory mix,\n        Types.Coordinate memory coordinate,\n        uint8 index\n    ) internal pure {\n        Types.Rlud memory radii;\n\n        while (coordinate.a < mix.matrix.width - 1 && mix.matrix.version.bigMatrixHasPixelAt(coordinate.a + (radii.r + 1), coordinate.b)) {\n            radii.r++;\n        }\n        while (coordinate.a != 0 && coordinate.a >= (radii.l + 1) && mix.matrix.version.bigMatrixHasPixelAt(coordinate.a - (radii.l + 1), coordinate.b)) {\n            radii.l++;\n        }\n        while (coordinate.b != 0 && coordinate.b >= (radii.u + 1) && mix.matrix.version.bigMatrixHasPixelAt(coordinate.a, coordinate.b - (radii.u + 1))) {\n            radii.u++;\n        }\n        while (coordinate.b < mix.matrix.height - 1 && mix.matrix.version.bigMatrixHasPixelAt(coordinate.a, coordinate.b + (radii.d + 1))) {\n            radii.d++;\n        }\n\n        if (!mix.receivers[index].coordinate.exists) {\n            mix.receivers[index] = Types.Anchor({radii: radii, coordinate: coordinate});\n        }\n    }\n\n    function calculateReceiverCoordinate(\n        Types.Mix memory mix,\n        Types.Coordinate memory calculatedReceiver,\n        Types.Coordinate[] memory anchors\n    ) internal pure returns (Types.Coordinate memory coordinate) {\n        coordinate.a = anchors[calculatedReceiver.a].a;\n        coordinate.b = anchors[calculatedReceiver.a].b;\n        coordinate.exists = true;\n\n        if (calculatedReceiver.b < 32) {\n            coordinate.b = coordinate.b - calculatedReceiver.b;\n        } else {\n            coordinate.b = coordinate.b + (calculatedReceiver.b - 32);\n        }\n\n        while (!mix.matrix.version.bigMatrixHasPixelAt(coordinate.a, coordinate.b)) {\n            if (anchors[0].b > coordinate.b) {\n                coordinate.b++;\n            } else {\n                coordinate.b--;\n            }\n        }\n        return coordinate;\n    }\n\n    function getAnchors(Types.Matrix memory matrix) internal pure returns (Types.Coordinate[] memory anchors) {\n        (uint8 topOffset, uint8 bottomOffset, Types.Coordinate memory center) = getBox(matrix);\n\n        anchors = new Types.Coordinate[](5);\n\n        anchors[0] = center; // center\n\n        anchors[1] = Types.Coordinate({a: center.a, b: center.b - topOffset, exists: true}); // top\n\n        uint8 upperOffset = topOffset;\n        if (upperOffset % 2 != 0) {\n            upperOffset++;\n        }\n        anchors[2] = Types.Coordinate({a: center.a, b: center.b - (upperOffset / 2), exists: true}); // inner top\n\n        uint8 lowerOffset = bottomOffset;\n        if (lowerOffset % 2 != 0) {\n            lowerOffset++;\n        }\n        anchors[3] = Types.Coordinate({a: center.a, b: center.b + (lowerOffset / 2), exists: true}); // inner bottom\n\n        anchors[4] = Types.Coordinate({a: center.a, b: center.b + bottomOffset, exists: true}); // bottom\n    }\n\n    function getBox(Types.Matrix memory matrix)\n        internal\n        pure\n        returns (\n            uint8 topOffset,\n            uint8 bottomOffset,\n            Types.Coordinate memory center\n        )\n    {\n        center.a = (matrix.width) / 2;\n        center.b = (matrix.height) / 2;\n        center.exists = true;\n\n        bool topFound = false;\n        bool bottomFound = false;\n        bool sideFound = false;\n        bool shouldExpandSide = true;\n\n        topOffset = 1;\n        bottomOffset = 1;\n        uint8 sideOffset = 1;\n\n        bool allFound = false;\n\n        while (!allFound) {\n            if (shouldExpandSide = !shouldExpandSide && !sideFound) {\n                if (\n                    matrix.version.bigMatrixHasPixelAt(center.a - (sideOffset + 1), center.b - topOffset) &&\n                    // potential top left\n                    matrix.version.bigMatrixHasPixelAt(center.a + (sideOffset + 1), center.b - topOffset) &&\n                    // potential top right\n                    matrix.version.bigMatrixHasPixelAt(center.a - (sideOffset + 1), center.b + bottomOffset) &&\n                    // potential bot left\n                    matrix.version.bigMatrixHasPixelAt(center.a + (sideOffset + 1), center.b + bottomOffset)\n                    // potential bot right\n                ) {\n                    sideOffset++;\n                } else {\n                    sideFound = true;\n                }\n            }\n            if (!topFound) {\n                if (\n                    center.b - topOffset > 0 &&\n                    matrix.version.bigMatrixHasPixelAt(center.a - sideOffset, center.b - (topOffset + 1)) &&\n                    // potential top left\n                    matrix.version.bigMatrixHasPixelAt(center.a + sideOffset, center.b - (topOffset + 1))\n                    // potential top right\n                ) {\n                    topOffset++;\n                } else {\n                    topFound = true;\n                }\n            }\n            if (!bottomFound) {\n                if (\n                    center.b + bottomOffset < matrix.height - 1 &&\n                    matrix.version.bigMatrixHasPixelAt(center.a - sideOffset, center.b + (bottomOffset + 1)) &&\n                    // potential bot left\n                    matrix.version.bigMatrixHasPixelAt(center.a + sideOffset, center.b + (bottomOffset + 1))\n                    // potenetial bot right\n                ) {\n                    bottomOffset++;\n                } else {\n                    bottomFound = true;\n                }\n            }\n            if (bottomFound && topFound && sideFound) allFound = true;\n        }\n\n        if (topOffset != bottomOffset) {\n            uint8 newHeight = topOffset + bottomOffset + 1;\n            uint8 relativeCenter = (newHeight % 2 == 0 ? newHeight : newHeight + 1) / 2;\n            uint8 newCenter = relativeCenter + center.b - 1 - topOffset;\n            if (newCenter > center.b) {\n                uint8 diff = newCenter - center.b;\n                topOffset += diff;\n                bottomOffset > diff ? bottomOffset = bottomOffset - diff : bottomOffset = diff - bottomOffset;\n            } else {\n                uint8 diff = center.b - newCenter;\n                topOffset > diff ? topOffset = topOffset - diff : topOffset = diff - topOffset;\n                bottomOffset += diff;\n            }\n            center.b = newCenter;\n        }\n    }\n}\n"
    },
    "src/types/Descriptor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// 1.5 x each feature for a coordinate (0.75 x 2)\n// 2 byte each feature for expanders coordinate (16, 16, 16, 16)\n// 1 byte each feature for expanders amount (4, 4, 4, 4)\n\n// 3 | 1/2 bytes - base ---- 8 | .5 --- 8 | .5   ---- 1 vars\n\n// 8 | 1 bytes - head\n// 8 | 1 bytes - eyes\n// 8 | 1 bytes - mouth\n// 8 | 1 bytes - back\n// 8 | 1 bytes - hair\n// 8 | 1 bytes - neck ---- 48 | 6 --- 51 | 6.5    ----- 6 vars\n\n// 8 | 1 bytes - head\n// 8 | 1 bytes - eyes\n// 8 | 1 bytes - mouth\n// 8 | 1 bytes - back\n// 8 | 1 bytes - hair\n// 8 | 1 bytes - neck ---- 48 | 6  -- 99 | 12.5 ---- 6 vars\n\n// 12 | 1.5 bytes - head coordinate\n// 12 | 1.5 bytes - eyes coordinate\n// 12 | 1.5 bytes - mouth coordinate\n// 12 | 1.5 bytes - back coordinate\n// 12 | 1.5 bytes - hair coordinate\n// 12 | 1.5 bytes - neck coordinate ---- 159-    ----- 12 vars\n\n// 3            - expander 3 feat      ------- 3 vars\n\n// 3            - expander 1 feat\n// 24 | 3 bytes - expander 1\n// 3            - expander 2 feat\n// 24 | 3 bytes - expander 2\n// 24 | 3 bytes - expander 3       - 24 vars\n\nlibrary Descriptor {\n    // struct Memory {\n    //     IDotNugg.Rlud[] expanderOffset; // 0 - 8\n    //     IDotNugg.Rlud[] expanderOffsetDirection; // 0 - 1\n    //     IDotNugg.Rlud[] expanderAmount; // 0 - 3\n    //     IDotNugg.Coordinate[] anchors; // 0 - 63\n    // }\n\n    // function parse(uint256 input) internal pure returns (Memory memory m) {\n    //     m.expanderOffset = new IDotNugg.Rlud[](8);\n    //     m.expanderOffsetDirection = new IDotNugg.Rlud[](8);\n    //     m.expanderAmount = new IDotNugg.Rlud[](8);\n    //     m.anchors = new IDotNugg.Coordinate[](8);\n\n    //     uint256[] memory tmp = new uint256[](2);\n    //     tmp[0] = 1;\n    //     tmp[1] = input;\n\n    //     (, BitReader.Memory memory reader) = BitReader.init(tmp);\n\n    //     reader.select(99);\n\n    //     for (uint256 i = 1; i < 7; i++) {\n    //         m.anchors[i].a = uint8(reader.select(6));\n    //         m.anchors[i].b = uint8(reader.select(6));\n    //         m.anchors[i].exists = m.anchors[i].a != 0 || m.anchors[i].b != 0;\n    //     }\n    // }\n\n    function receiverOverride(uint256 input, uint256 feature)\n        internal\n        pure\n        returns (\n            bool exists,\n            uint256 x,\n            uint256 y\n        )\n    {\n        return (false, 15, 15);\n    }\n}\n"
    },
    "src/types/Pixel.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nlibrary Pixel {\n    function r(uint256 input) internal pure returns (uint256 res) {\n        res = (input >> 24) & 0xff;\n    }\n\n    function g(uint256 input) internal pure returns (uint256 res) {\n        res = (input >> 16) & 0xff;\n    }\n\n    function b(uint256 input) internal pure returns (uint256 res) {\n        res = (input >> 8) & 0xff;\n    }\n\n    function a(uint256 input) internal pure returns (uint256 res) {\n        res = input & 0xff;\n    }\n\n    function z(uint256 input) internal pure returns (uint256 res) {\n        res = (input >> 32) & 0xf;\n    }\n\n    function f(uint256 input) internal pure returns (uint256 res) {\n        res = (input >> 36) & 0xf;\n    }\n\n    function e(uint256 input) internal pure returns (bool res) {\n        res = input != 0x00;\n    }\n}\n"
    },
    "src/types/Types.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {Version as NewVersion} from '../types/Version.sol';\n\nlibrary Types {\n    struct Rlud {\n        bool exists;\n        uint8 r;\n        uint8 l;\n        uint8 u;\n        uint8 d;\n    }\n\n    struct Rgba {\n        uint8 r;\n        uint8 g;\n        uint8 b;\n        uint8 a;\n    }\n\n    struct Anchor {\n        Rlud radii;\n        Coordinate coordinate;\n    }\n\n    struct Coordinate {\n        uint8 a; // anchorId\n        uint8 b; // yoffset\n        bool exists;\n    }\n\n    struct Version {\n        uint8 width;\n        uint8 height;\n        Anchor anchor;\n        // these must be in same order as canvas receivers, respectively\n        Coordinate[] calculatedReceivers; // can be empty\n        Coordinate[] staticReceivers; // can be empty\n        Rlud expanders;\n        bytes data;\n    }\n\n    struct Canvas {\n        Matrix matrix;\n        Anchor[] receivers;\n    }\n\n    struct Mix {\n        uint8 feature;\n        Version version;\n        Matrix matrix;\n        Anchor[] receivers;\n        uint8 yoffset;\n        uint8 xoffset;\n    }\n\n    struct Matrix {\n        uint8 width;\n        uint8 height;\n        NewVersion.Memory version;\n        uint8 currentUnsetX;\n        uint8 currentUnsetY;\n        bool init;\n        uint8 startX;\n    }\n}\n"
    },
    "src/libraries/ShiftLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {SafeCastLib} from './SafeCastLib.sol';\n\nlibrary ShiftLib {\n    using SafeCastLib for uint256;\n\n    /// @notice creates a bit mask\n    /// @dev res = (2 ^ bits) - 1\n    /// @param bits d\n    /// @return res d\n    /// @dev no need to check if \"bits\" is < 256 as anything greater than 255 will be treated the same\n    function mask(uint8 bits) internal pure returns (uint256 res) {\n        assembly {\n            res := sub(shl(bits, 1), 1)\n        }\n    }\n\n    function fullsubmask(uint8 bits, uint8 pos) internal pure returns (uint256 res) {\n        res = ~(mask(bits) << pos);\n    }\n\n    function set(\n        uint256 preStore,\n        uint8 bits,\n        uint8 pos,\n        uint256 value\n    ) internal pure returns (uint256 postStore) {\n        postStore = preStore & fullsubmask(bits, pos);\n\n        assembly {\n            value := shl(pos, value)\n        }\n\n        postStore |= value;\n    }\n\n    function get(\n        uint256 store,\n        uint8 bits,\n        uint8 pos\n    ) internal pure returns (uint256 value) {\n        assembly {\n            value := shr(pos, store)\n        }\n        value &= mask(bits);\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                ARRAYS\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function getArray(uint256 store, uint8 pos) internal pure returns (uint8[] memory arr) {\n        store = get(store, 64, pos);\n\n        arr = new uint8[](8);\n        for (uint256 i = 0; i < 8; i++) {\n            arr[i] = uint8(store & 0xff);\n            store >>= 8;\n        }\n    }\n\n    function setArray(\n        uint256 store,\n        uint8 pos,\n        uint8[] memory arr\n    ) internal pure returns (uint256 res) {\n        for (uint256 i = 8; i > 0; i--) {\n            res |= uint256(arr[i - 1]) << ((8 * (i - 1)));\n        }\n\n        res = set(store, 64, pos, res);\n    }\n}\n"
    },
    "src/libraries/BitReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport '../libraries/ShiftLib.sol';\n\nlibrary BitReader {\n    using ShiftLib for uint256;\n\n    struct Memory {\n        uint256[] dat;\n        uint256 moves;\n        uint256 pos;\n    }\n\n    function init(uint256[] memory input) internal pure returns (bool err, Memory memory m) {\n        if (input.length == 0) return (true, m);\n\n        m.dat = input;\n\n        m.moves = 2;\n\n        m.dat = new uint256[](input.length);\n\n        for (uint256 i = input.length; i > 0; i--) {\n            m.dat[i - 1] = input[input.length - i];\n        }\n    }\n\n    function peek(Memory memory m, uint8 bits) internal pure returns (uint256 res) {\n        res = m.dat[0] & ShiftLib.mask(bits);\n    }\n\n    function select(Memory memory m, uint8 bits) internal pure returns (uint256 res) {\n        res = m.dat[0] & ShiftLib.mask(bits);\n\n        m.dat[0] = m.dat[0] >> bits;\n\n        m.pos += bits;\n\n        if (m.pos >= 128) {\n            uint256 ptr = (m.moves / 2);\n            if (ptr < m.dat.length) {\n                m.dat[0] <<= m.pos - 128;\n                uint256 move = m.dat[ptr] & ShiftLib.mask(128);\n                m.dat[ptr] >>= 128;\n                m.dat[0] |= (move << 128);\n                m.dat[0] >>= (m.pos - 128);\n                m.moves++;\n                m.pos -= 128;\n            }\n        }\n    }\n}\n"
    },
    "src/libraries/SafeCastLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\n// OK\n/// @notice Safe unsigned integer casting library that reverts on overflow.\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\nlibrary SafeCastLib {\n    function safe160(uint256 x) internal pure returns (uint160 y) {\n        require(x <= type(uint160).max);\n        y = uint160(x);\n    }\n\n    function safe96(uint256 x) internal pure returns (uint96 y) {\n        require(x <= type(uint96).max);\n        y = uint96(x);\n    }\n\n    function safe64(uint256 x) internal pure returns (uint64 y) {\n        require(x <= type(uint64).max);\n        y = uint64(x);\n    }\n\n    function safe32(uint256 x) internal pure returns (uint32 y) {\n        require(x <= type(uint32).max);\n        y = uint32(x);\n    }\n\n    function safe16(uint256 x) internal pure returns (uint16 y) {\n        require(x <= type(uint16).max);\n        y = uint16(x);\n    }\n\n    function safe8(uint256 x) internal pure returns (uint8 y) {\n        require(x <= type(uint8).max);\n        y = uint8(x);\n    }\n\n    function safe6(uint256 x) internal pure returns (uint8 y) {\n        require(x <= 0xf7);\n        y = uint8(x);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}