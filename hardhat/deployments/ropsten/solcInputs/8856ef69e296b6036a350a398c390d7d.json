{
  "language": "Solidity",
  "sources": {
    "src/_mock/MockDotnuggV1Implementer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IDotnuggV1Processor} from './../interfaces/IDotnuggV1Processor.sol';\nimport {IDotnuggV1Implementer} from './../interfaces/IDotnuggV1Implementer.sol';\nimport {IDotnuggV1Data} from './../interfaces/IDotnuggV1Data.sol';\n\ncontract MockDotnuggV1Implementer is IDotnuggV1Implementer {\n    IDotnuggV1Processor p;\n\n    constructor(IDotnuggV1Processor processor) {\n        p = processor;\n    }\n\n    function dotnuggV1Callback(uint256 tokenId) external pure override returns (IDotnuggV1Data.Data memory data) {\n        data.name = 'name';\n        data.desc = 'desc';\n        data.version = 1;\n        data.tokenId = 0;\n        data.proof = 0;\n        data.owner = address(0);\n\n        data.ids = new uint8[](8);\n\n        data.ids[0] = 1;\n        data.ids[1] = 1;\n        data.ids[2] = 1;\n        data.ids[3] = 1;\n    }\n\n    function dotnuggV1StoreFiles(uint256[][] calldata data, uint8 feature) external override {\n        p.storeFiles(feature, data);\n    }\n}\n"
    },
    "src/interfaces/IDotnuggV1Processor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IDotnuggV1Data} from './IDotnuggV1Data.sol';\nimport {IDotnuggV1Resolver} from './IDotnuggV1Resolver.sol';\nimport {IDotnuggV1Storage} from './IDotnuggV1Storage.sol';\n\ninterface IDotnuggV1Processor is IDotnuggV1Storage, IDotnuggV1Resolver {\n    function dotnuggToBytes(\n        address implementer,\n        uint256 tokenId,\n        address resolver,\n        uint8 width,\n        uint8 zoom\n    ) external view returns (address resolvedBy, bytes memory res);\n\n    function dotnuggToRaw(\n        address implementer,\n        uint256 tokenId,\n        address resolver,\n        uint8 width,\n        uint8 zoom\n    ) external view returns (address resolvedBy, uint256[] memory res);\n\n    function dotnuggToData(\n        address implementer,\n        uint256 tokenId,\n        address resolver,\n        uint8 width,\n        uint8 zoom\n    ) external view returns (address resolvedBy, IDotnuggV1Data.Data memory res);\n\n    function dotnuggToString(\n        address implementer,\n        uint256 tokenId,\n        address resolver,\n        uint8 width,\n        uint8 zoom\n    ) external view returns (address resolvedBy, string memory res);\n\n    function dotnuggToUri(\n        address implementer,\n        uint256 tokenId,\n        address resolver,\n        uint8 width,\n        uint8 zoom\n    ) external view returns (address resolvedBy, string memory res);\n\n    function process(\n        address implementer,\n        uint256 tokenId,\n        uint8 width\n    ) external view returns (uint256[] memory file, IDotnuggV1Data.Data memory dat);\n\n    function processCore(\n        uint256[][] memory files,\n        IDotnuggV1Data.Data memory data,\n        uint8 width\n    ) external view returns (uint256[] memory file);\n}\n"
    },
    "src/interfaces/IDotnuggV1Implementer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IDotnuggV1Data} from './IDotnuggV1Data.sol';\n\ninterface IDotnuggV1Implementer {\n    function dotnuggV1Callback(uint256 tokenId) external view returns (IDotnuggV1Data.Data memory data);\n\n    function dotnuggV1StoreFiles(uint256[][] calldata data, uint8 feature) external;\n}\n"
    },
    "src/interfaces/IDotnuggV1Data.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IDotnuggV1Data {\n    struct Data {\n        uint256 version;\n        uint256 renderedAt;\n        string name;\n        string desc;\n        address owner;\n        uint256 tokenId;\n        uint256 proof;\n        uint8[] ids;\n        uint8[] extras;\n        uint8[] xovers;\n        uint8[] yovers;\n    }\n}\n"
    },
    "src/interfaces/IDotnuggV1Resolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IDotnuggV1Data} from './IDotnuggV1Data.sol';\n\ninterface IDotnuggV1Resolver {\n    function resolveBytes(\n        uint256[] memory file,\n        IDotnuggV1Data.Data memory data,\n        uint8 zoom\n    ) external view returns (bytes memory res);\n\n    function resolveRaw(\n        uint256[] memory file,\n        IDotnuggV1Data.Data memory data,\n        uint8 zoom\n    ) external view returns (uint256[] memory res);\n\n    function resolveData(\n        uint256[] memory file,\n        IDotnuggV1Data.Data memory data,\n        uint8 zoom\n    ) external view returns (IDotnuggV1Data.Data memory res);\n\n    function resolveString(\n        uint256[] memory file,\n        IDotnuggV1Data.Data memory data,\n        uint8 zoom\n    ) external view returns (string memory res);\n\n    function resolveUri(\n        uint256[] memory file,\n        IDotnuggV1Data.Data memory data,\n        uint8 zoom\n    ) external view returns (string memory res);\n}\n"
    },
    "src/interfaces/IDotnuggV1Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IDotnuggV1Data} from './IDotnuggV1Data.sol';\n\ninterface IDotnuggV1Storage {\n    function totalStoredFiles(address implementer, uint8 feature) external returns (uint8);\n\n    function storeFiles(uint8 feature, uint256[][] calldata data) external returns (uint8 amount);\n}\n"
    },
    "src/_test/fixtures/NuggFather.fix.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {DSTestPlus as t} from '../utils/DSTestPlus.sol';\n\nimport {User} from '../utils/User.sol';\n\nimport {MockDotnuggV1Implementer} from '../../_mock/MockDotnuggV1Implementer.sol';\n\nimport {DotnuggV1Processor} from '../../DotnuggV1Processor.sol';\n\nlibrary SafeCast {\n    function safeI192(uint96 input) internal pure returns (int192) {\n        return (int192(int256(uint256(input))));\n    }\n}\n\ncontract NuggFatherFix is t {\n    using SafeCast for uint96;\n    using SafeCast for uint256;\n    using SafeCast for uint64;\n\n    DotnuggV1Processor public processor;\n\n    address public _processor;\n\n    MockDotnuggV1Implementer public implementer;\n\n    address public _implementer;\n\n    User public safe;\n\n    User public frank;\n    User public charlie;\n    User public dennis;\n    User public mac;\n    User public dee;\n\n    User public any;\n\n    constructor() {}\n\n    function reset() public {\n        fvm.roll(1);\n        fvm.roll(2);\n        processor = new DotnuggV1Processor();\n\n        _processor = address(processor);\n\n        implementer = new MockDotnuggV1Implementer(processor);\n\n        _implementer = address(implementer);\n\n        safe = new User{value: 1000 ether}();\n        frank = new User{value: 1000 ether}();\n        charlie = new User{value: 1000 ether}();\n        dennis = new User{value: 1000 ether}();\n        mac = new User{value: 1000 ether}();\n        dee = new User{value: 1000 ether}();\n\n        any = new User();\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                eth modifiers\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                encodeWithSelector\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function dotnuggV1StoreFiles(uint256[][] memory files, uint8 feature) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(implementer.dotnuggV1StoreFiles.selector, files, feature);\n    }\n\n    function take(int256 percent, int256 value) internal pure returns (int256) {\n        return (value * percent) / 100;\n    }\n}\n\n// Success: test__system1()\n\n//   users length: 2000\n//   nuggft.ethPerShare(): 36422938319266817\n//   nuggft.protocolEth(): 13721927850988207037\n//   nuggft.stakedEth(): 254960568234867720007\n//   nuggft.stakedShares(): 7000\n\n// Success: test__system1()\n\n//   users length: 2000\n//   nuggft.ethPerShare(): .220269870602728762\n//   nuggft.protocolEth(): 105.652900187038601090\n//   nuggft.stakedEth(): 3524.317929643660202576\n//   nuggft.stakedShares(): 16000\n\n// Success: test__system1()\n// *10\n//   users length: 2000\n//   nuggft.ethPerShare():  .081046931383505748\n//   nuggft.protocolEth(): 36.036371675422002761\n//   nuggft.stakedEth():  891.516245218563229016\n//   nuggft.stakedShares(): 11000\n\n//   users length: 2000\n//   nuggft.ethPerShare():   .009923420616251655\n//   nuggft.protocolEth():  10.797105517187750828\n//   nuggft.stakedEth():   109.157626778768205405\n//   nuggft.stakedShares(): 11000\n\n// Success: test__system1()\n\n//   users length: 2000\n//   nuggft.ethPerShare(): .023820112972809680\n//   nuggft.protocolEth(): 23.605706549631210195\n//   nuggft.stakedEth(): 262.021242700906482643\n//   nuggft.stakedShares(): 11000\n\n// Success: test__system1()\n\n//   users length: 2000\n//   nuggft.ethPerShare(): 22283800801842573\n//   nuggft.protocolEth(): 12045486919914902312\n//   nuggft.stakedEth(): 133702804811055442627\n//   nuggft.stakedShares(): 6000\n\n//   users length: 2000\n//   nuggft.ethPerShare(): 1.124042581556443270\n//   nuggft.protocolEth(): 658.232592803322633239\n//   nuggft.stakedEth(): 7306.276780116881258328\n//   nuggft.stakedShares(): 6500\n\n// Success: test__system1()\n\n//   users length: 2000\n//   nuggft.ethPerShare(): .179846813049030914\n//   nuggft.protocolEth(): 105317214848531614175\n//   nuggft.stakedEth(): 1169004284818700946598\n//   nuggft.stakedShares(): 6500\n\n// .092595956292375926\n\n// .101719406217199627\n\n// Success: test__system1()\n\n//   users length: 2000\n//   nuggft.ethPerShare(): .178270406414740660\n//   nuggft.protocolEth(): 96363895359319273644\n//   nuggft.stakedEth(): 1069622438488443964472\n//   nuggft.stakedShares(): 6000\n\n// Success: test__system1()\n\n//   users length: 1000\n//   nuggft.ethPerShare():   1.425741271002990526\n//   nuggft.protocolEth():  305.518843786355111578\n//   nuggft.stakedEth():   4277.223813008971579744\n//   nuggft.stakedShares(): 3000\n"
    },
    "src/_test/utils/DSTestPlus.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {DSTest} from '../../../lib/ds-test/src/test.sol';\n\nimport {Hevm, ForgeVm} from './Vm.sol';\n\ncontract DSTestPlus is DSTest {\n    Hevm internal constant hevm = Hevm(HEVM_ADDRESS);\n\n    ForgeVm internal constant fvm = ForgeVm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    address internal constant DEAD_ADDRESS = 0xDeaDbeefdEAdbeefdEadbEEFdeadbeEFdEaDbeeF;\n\n    modifier changeInBalance96(address target, int192 change) {\n        int256 before_staked = int192(int256(uint256(target.balance)));\n        _;\n        int256 after_staked = int192(int256(uint256(target.balance)));\n\n        assertEq(after_staked - before_staked, change, 'user balance did not change');\n    }\n\n    bytes32 checkpointLabel;\n    uint256 private checkpointGasLeft;\n\n    function startMeasuringGas(bytes32 label) internal virtual {\n        checkpointLabel = label;\n        checkpointGasLeft = gasleft();\n    }\n\n    function stopMeasuringGas() internal virtual {\n        uint256 checkpointGasLeft2 = gasleft();\n\n        bytes32 label = checkpointLabel;\n\n        emit log_named_uint(string(abi.encodePacked(label, ' Gas')), checkpointGasLeft - checkpointGasLeft2 - 22134);\n    }\n\n    function fail(bytes32 err) internal virtual {\n        emit log_named_string('Error', string(abi.encodePacked(err)));\n        fail();\n    }\n\n    function assertFalse(bool data) internal virtual {\n        assertTrue(!data);\n    }\n\n    function assertBytesEq(bytes memory a, bytes memory b) internal virtual {\n        if (keccak256(a) != keccak256(b)) {\n            emit log('Error: a == b not satisfied [bytes]');\n            emit log_named_bytes('  Expected', b);\n            emit log_named_bytes('    Actual', a);\n            fail();\n        }\n    }\n\n    function assertArrayEq(uint256[] memory a, uint256[] memory b) internal virtual {\n        if (a.length != b.length) {\n            emit log('Error: a == b not satisfied [uint256[]]');\n            emit log_named_uint('  Expected length', b.length);\n            emit log_named_uint('    Actual length', a.length);\n            fail();\n            return;\n        }\n\n        bool ok = true;\n        for (uint256 i = 0; i < a.length; i++) {\n            if (a[i] != b[i]) {\n                ok = false;\n                emit log_named_uint('Error: a == b not satisfied [bytes256[i]]: i = ', i);\n                emit log_named_bytes32('  Expected', bytes32(b[i]));\n                emit log_named_bytes32('    Actual', bytes32(a[i]));\n            }\n        }\n\n        if (!ok) fail();\n    }\n}\n\ncontract DSInvariantTest {\n    address[] private targets;\n\n    function targetContracts() public view virtual returns (address[] memory) {\n        require(targets.length > 0, 'NO_TARGET_CONTRACTS');\n\n        return targets;\n    }\n\n    function addTargetContract(address newTargetContract) internal virtual {\n        targets.push(newTargetContract);\n    }\n}\n"
    },
    "src/_test/utils/User.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {ForgeVm} from './Vm.sol';\n\nlibrary UserTarget {\n    function shouldPass(\n        address target,\n        User user,\n        bytes memory args\n    ) internal {\n        shouldPass(target, user, args, 0);\n    }\n\n    function shouldPass(\n        address target,\n        User user,\n        bytes memory args,\n        uint96 eth\n    ) internal {\n        user.call(target, args, eth);\n    }\n\n    function shouldFail(\n        address target,\n        string memory message,\n        User user,\n        bytes memory args\n    ) internal {\n        shouldFail(target, message, user, args, 0);\n    }\n\n    function shouldFail(\n        address target,\n        string memory message,\n        User user,\n        bytes memory args,\n        uint96 eth\n    ) internal {\n        user.revertCall(target, message, args, eth);\n    }\n}\n\ncontract User {\n    ForgeVm internal constant fvm = ForgeVm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    event log_named_string(string key, string val);\n\n    fallback() external payable {}\n\n    receive() external payable {}\n\n    constructor() payable {}\n\n    function tryCall(address target, bytes memory data) public payable virtual returns (bool success, bytes memory returnData) {\n        (success, returnData) = target.call{value: msg.value}(data);\n    }\n\n    function call(\n        address target,\n        bytes memory data,\n        uint256 eth\n    ) public payable virtual returns (bytes memory returnData) {\n        bool success;\n        (success, returnData) = target.call{value: eth}(data);\n\n        if (!success) {\n            if (returnData.length > 0) {\n                assembly {\n                    let returnDataSize := mload(returnData)\n                    revert(add(32, returnData), returnDataSize)\n                }\n            } else {\n                revert('REVERTED_WITHOUT_MESSAGE');\n            }\n        }\n    }\n\n    function revertCall(\n        address target,\n        string memory message,\n        bytes memory data,\n        uint256 eth\n    ) public payable virtual {\n        (bool callSuccess, bytes memory returnData) = target.call{value: eth}(data);\n\n        require(!callSuccess, 'REVERT-CALL SUCCEEDED');\n\n        string memory revertReason = string(extractRevertReason(returnData));\n\n        if (!compareStrings(revertReason, message)) {\n            revert(string(abi.encodePacked('UNEXPECTED REVERT: ', revertReason, ' EXPECTED: ', message)));\n        }\n    }\n\n    function extractRevertReason(bytes memory revertData) internal pure returns (string memory reason) {\n        uint256 l = revertData.length;\n        if (l < 68) return '';\n        uint256 t;\n        assembly {\n            revertData := add(revertData, 4)\n            t := mload(revertData) // Save the content of the length slot\n            mstore(revertData, sub(l, 4)) // Set proper length\n        }\n        reason = abi.decode(revertData, (string));\n        assembly {\n            mstore(revertData, t) // Restore the content of the length slot\n        }\n    }\n\n    function compareStrings(string memory a, string memory b) public pure returns (bool) {\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n    }\n}\n"
    },
    "src/DotnuggV1Processor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IDotnuggV1Processor} from './interfaces/IDotnuggV1Processor.sol';\nimport {IDotnuggV1Data} from './interfaces/IDotnuggV1Data.sol';\nimport {IDotnuggV1Resolver} from './interfaces/IDotnuggV1Resolver.sol';\nimport {IDotnuggV1Implementer} from './interfaces/IDotnuggV1Implementer.sol';\n\nimport {DotnuggV1Storage} from './logic/DotnuggV1Storage.sol';\n\nimport {DotnuggV1Lib} from './DotnuggV1Lib.sol';\n\n/// @title dotnugg Processor V1 - onchain encoder/decoder protocol for dotnugg files\n/// @author nugg.xyz - danny7even & dub6ix\n/// @notice yoU CAN'T HaVe ImAgES oN THe BlOCkcHAIn\n/// @dev hold my margarita\ncontract DotnuggV1Processor is IDotnuggV1Processor, DotnuggV1Storage {\n    DotnuggV1Lib public lib;\n\n    constructor() {\n        lib = new DotnuggV1Lib();\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                     core\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function process(\n        address implementer,\n        uint256 tokenId,\n        uint8 width\n    ) public view override returns (uint256[] memory resp, IDotnuggV1Data.Data memory dat) {\n        IDotnuggV1Data.Data memory data = IDotnuggV1Implementer(implementer).dotnuggV1Callback(tokenId);\n\n        uint256[][] memory files = getBatchFiles(implementer, data.ids);\n\n        dat = data;\n\n        resp = processCore(files, data, width);\n    }\n\n    function processCore(\n        uint256[][] memory files,\n        IDotnuggV1Data.Data memory data,\n        uint8 width\n    ) public view override returns (uint256[] memory resp) {\n        return lib.processCore(files, data, width);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                resolvers\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function resolveRaw(\n        uint256[] memory file,\n        IDotnuggV1Data.Data memory,\n        uint8\n    ) public pure override returns (uint256[] memory res) {\n        res = file;\n    }\n\n    function resolveBytes(\n        uint256[] memory file,\n        IDotnuggV1Data.Data memory data,\n        uint8\n    ) public pure override returns (bytes memory res) {\n        res = abi.encode(file, data);\n    }\n\n    function resolveData(\n        uint256[] memory,\n        IDotnuggV1Data.Data memory data,\n        uint8\n    ) public pure override returns (IDotnuggV1Data.Data memory res) {\n        res = data;\n    }\n\n    function resolveString(\n        uint256[] memory file,\n        IDotnuggV1Data.Data memory,\n        uint8 zoom\n    ) public view override returns (string memory) {\n        bytes memory working = lib.buildSvg(file, zoom);\n\n        return string(working);\n    }\n\n    function resolveUri(\n        uint256[] memory file,\n        IDotnuggV1Data.Data memory data,\n        uint8 zoom\n    ) public view override returns (string memory res) {\n        res = string(\n            lib.jsonBase64(\n                abi.encodePacked(\n                    '{\"name\":\"',\n                    data.name,\n                    '\",\"description\":\"',\n                    data.desc,\n                    '\", \"image\": \"',\n                    lib.buildSvg(file, zoom),\n                    '\",\"DotnuggVersion\":\"',\n                    lib.uintToAscii(data.version),\n                    '\",\"tokenId\":\"',\n                    lib.uintToAscii(data.tokenId),\n                    '\",\"proof\":\"',\n                    lib.uintToHex(data.proof, 32),\n                    '\",\"owner\":\"',\n                    lib.uintToHex(uint160(data.owner), 20),\n                    '\"}'\n                )\n            )\n        );\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                full processors\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function dotnuggToUri(\n        address implementer,\n        uint256 tokenId,\n        address resolver,\n        uint8 width,\n        uint8 zoom\n    ) external view override returns (address resolvedBy, string memory res) {\n        (uint256[] memory file, IDotnuggV1Data.Data memory data) = process(implementer, tokenId, width);\n\n        if (resolver != address(0)) {\n            try IDotnuggV1Resolver(resolver).resolveUri(file, data, zoom) returns (string memory d) {\n                return (resolver, d);\n            } catch (bytes memory) {}\n        }\n\n        return (address(this), resolveUri(file, data, zoom));\n    }\n\n    function dotnuggToRaw(\n        address implementer,\n        uint256 tokenId,\n        address resolver,\n        uint8 width,\n        uint8 zoom\n    ) external view override returns (address resolvedBy, uint256[] memory res) {\n        (uint256[] memory file, IDotnuggV1Data.Data memory data) = process(implementer, tokenId, width);\n\n        if (resolver != address(0)) {\n            try IDotnuggV1Resolver(resolver).resolveRaw(file, data, zoom) returns (uint256[] memory d) {\n                return (resolver, d);\n            } catch (bytes memory) {}\n        }\n\n        return (address(this), resolveRaw(file, data, zoom));\n    }\n\n    function dotnuggToBytes(\n        address implementer,\n        uint256 tokenId,\n        address resolver,\n        uint8 width,\n        uint8 zoom\n    ) external view override returns (address resolvedBy, bytes memory res) {\n        (uint256[] memory file, IDotnuggV1Data.Data memory data) = process(implementer, tokenId, width);\n\n        if (resolver != address(0)) {\n            try IDotnuggV1Resolver(resolver).resolveBytes(file, data, zoom) returns (bytes memory d) {\n                return (resolver, d);\n            } catch (bytes memory) {}\n        }\n\n        return (address(this), resolveBytes(file, data, zoom));\n    }\n\n    function dotnuggToString(\n        address implementer,\n        uint256 tokenId,\n        address resolver,\n        uint8 width,\n        uint8 zoom\n    ) external view override returns (address resolvedBy, string memory res) {\n        (uint256[] memory file, IDotnuggV1Data.Data memory data) = process(implementer, tokenId, width);\n\n        if (resolver != address(0)) {\n            try IDotnuggV1Resolver(resolver).resolveString(file, data, zoom) returns (string memory d) {\n                return (resolver, d);\n            } catch (bytes memory) {}\n        }\n\n        return (address(this), resolveString(file, data, zoom));\n    }\n\n    function dotnuggToData(\n        address implementer,\n        uint256 tokenId,\n        address resolver,\n        uint8 width,\n        uint8 zoom\n    ) external view override returns (address resolvedBy, IDotnuggV1Data.Data memory res) {\n        (uint256[] memory file, IDotnuggV1Data.Data memory data) = process(implementer, tokenId, width);\n\n        if (resolver != address(0)) {\n            try IDotnuggV1Resolver(resolver).resolveData(file, data, zoom) returns (IDotnuggV1Data.Data memory d) {\n                return (resolver, d);\n            } catch (bytes memory) {}\n        }\n\n        return (address(this), resolveData(file, data, zoom));\n    }\n}\n"
    },
    "lib/ds-test/src/test.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.4.23;\n\ncontract DSTest {\n    event log                    (string);\n    event logs                   (bytes);\n\n    event log_address            (address);\n    event log_bytes32            (bytes32);\n    event log_int                (int);\n    event log_uint               (uint);\n    event log_bytes              (bytes);\n    event log_string             (string);\n\n    event log_named_address      (string key, address val);\n    event log_named_bytes32      (string key, bytes32 val);\n    event log_named_decimal_int  (string key, int val, uint decimals);\n    event log_named_decimal_uint (string key, uint val, uint decimals);\n    event log_named_int          (string key, int val);\n    event log_named_uint         (string key, uint val);\n    event log_named_bytes        (string key, bytes val);\n    event log_named_string       (string key, string val);\n\n    bool public IS_TEST = true;\n    bool public failed;\n\n    address constant HEVM_ADDRESS =\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\n\n    modifier mayRevert() { _; }\n    modifier testopts(string memory) { _; }\n\n    function fail() internal {\n        failed = true;\n    }\n\n    modifier logs_gas() {\n        uint startGas = gasleft();\n        _;\n        uint endGas = gasleft();\n        emit log_named_uint(\"gas\", startGas - endGas);\n    }\n\n    function assertTrue(bool condition) internal {\n        if (!condition) {\n            emit log(\"Error: Assertion Failed\");\n            fail();\n        }\n    }\n\n    function assertTrue(bool condition, string memory err) internal {\n        if (!condition) {\n            emit log_named_string(\"Error\", err);\n            assertTrue(condition);\n        }\n    }\n\n    function assertEq(address a, address b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [address]\");\n            emit log_named_address(\"  Expected\", b);\n            emit log_named_address(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(address a, address b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes32 a, bytes32 b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bytes32]\");\n            emit log_named_bytes32(\"  Expected\", b);\n            emit log_named_bytes32(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(bytes32 a, bytes32 b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq32(bytes32 a, bytes32 b) internal {\n        assertEq(a, b);\n    }\n    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {\n        assertEq(a, b, err);\n    }\n\n    function assertEq(int a, int b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [int]\");\n            emit log_named_int(\"  Expected\", b);\n            emit log_named_int(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(int a, int b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq(uint a, uint b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [uint]\");\n            emit log_named_uint(\"  Expected\", b);\n            emit log_named_uint(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(uint a, uint b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Expected\", b, decimals);\n            emit log_named_decimal_int(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Expected\", b, decimals);\n            emit log_named_decimal_uint(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGt(uint a, uint b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(uint a, uint b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGt(int a, int b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(int a, int b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGe(uint a, uint b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(uint a, uint b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGe(int a, int b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(int a, int b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLt(uint a, uint b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(uint a, uint b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLt(int a, int b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(int a, int b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLe(uint a, uint b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(uint a, uint b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLe(int a, int b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(int a, int b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLeDecimal(a, b, decimals);\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertEq(string memory a, string memory b) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log(\"Error: a == b not satisfied [string]\");\n            emit log_named_string(\"  Value a\", a);\n            emit log_named_string(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertEq(string memory a, string memory b, string memory err) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {\n        ok = true;\n        if (a.length == b.length) {\n            for (uint i = 0; i < a.length; i++) {\n                if (a[i] != b[i]) {\n                    ok = false;\n                }\n            }\n        } else {\n            ok = false;\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b) internal {\n        if (!checkEq0(a, b)) {\n            emit log(\"Error: a == b not satisfied [bytes]\");\n            emit log_named_bytes(\"  Expected\", a);\n            emit log_named_bytes(\"    Actual\", b);\n            fail();\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {\n        if (!checkEq0(a, b)) {\n            emit log_named_string(\"Error\", err);\n            assertEq0(a, b);\n        }\n    }\n}\n"
    },
    "src/_test/utils/Vm.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface Hevm {\n    function warp(uint256) external;\n\n    function roll(uint256) external;\n\n    function store(\n        address,\n        bytes32,\n        bytes32\n    ) external;\n\n    function load(address, bytes32) external returns (bytes32);\n\n    function sign(uint256, bytes32)\n        external\n        returns (\n            uint8,\n            bytes32,\n            bytes32\n        );\n\n    function addr(uint256) external returns (address);\n\n    function ffi(string[] calldata) external returns (bytes memory);\n}\n\ninterface ForgeVm {\n    // Set block.timestamp (newTimestamp)\n    function warp(uint256) external;\n\n    // Set block.height (newHeight)\n    function roll(uint256) external;\n\n    // Loads a storage slot from an address (who, slot)\n    function load(address, bytes32) external returns (bytes32);\n\n    // Stores a value to an address' storage slot, (who, slot, value)\n    function store(\n        address,\n        bytes32,\n        bytes32\n    ) external;\n\n    // Signs data, (privateKey, digest) => (r, v, s)\n    function sign(uint256, bytes32)\n        external\n        returns (\n            uint8,\n            bytes32,\n            bytes32\n        );\n\n    // Gets address for a given private key, (privateKey) => (address)\n    function addr(uint256) external returns (address);\n\n    // Performs a foreign function call via terminal, (stringInputs) => (result)\n    function ffi(string[] calldata) external returns (bytes memory);\n\n    // Calls another contract with a specified `msg.sender`, (newSender, contract, input) => (success, returnData)\n    function prank(\n        address,\n        address,\n        bytes calldata\n    ) external payable returns (bool, bytes memory);\n\n    // Sets an address' balance, (who, newBalance)\n    function deal(address, uint256) external;\n\n    // Sets an address' code, (who, newCode)\n    function etch(address, bytes calldata) external;\n\n    // Expects an error on next call\n    function expectRevert(bytes calldata) external;\n}\n"
    },
    "src/logic/DotnuggV1Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\nimport {IDotnuggV1Storage} from '../interfaces/IDotnuggV1Storage.sol';\nimport {SSTORE2} from '../libraries/SSTORE2.sol';\nimport {SafeCastLib} from '../libraries/SafeCastLib.sol';\n\n\nabstract contract DotnuggV1Storage is IDotnuggV1Storage {\n    using SafeCastLib for uint256;\n    using SafeCastLib for uint16;\n\n    // Mapping from token ID to owner address\n    mapping(address => mapping(uint8 => uint168[])) sstore2Pointers;\n    mapping(address => mapping(uint8 => uint8)) featureLengths;\n\n    function totalStoredFiles(address implementer, uint8 feature) public view override returns (uint8 res) {\n        return featureLengths[implementer][feature];\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                TRUSTED\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function storeFiles(uint8 feature, uint256[][] calldata data) external override returns (uint8 res) {\n        uint8 len = data.length.safe8();\n\n        require(len > 0, 'F:0');\n\n        address ptr = SSTORE2.write(abi.encode(data));\n\n        sstore2Pointers[msg.sender][feature].push(uint168(uint160(ptr)) | (uint168(len) << 160));\n\n        featureLengths[msg.sender][feature] += len;\n\n        return len;\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                 GET FILES\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function getBatchFiles(address implementer, uint8[] memory ids) internal view returns (uint256[][] memory data) {\n        data = new uint256[][](ids.length);\n\n        for (uint8 i = 0; i < ids.length; i++) {\n            if (ids[i] == 0) data[i] = new uint256[](0);\n            else data[i] = get(implementer, i, ids[i]);\n        }\n    }\n\n    function get(\n        address implementer,\n        uint8 feature,\n        uint8 pos\n    ) internal view returns (uint256[] memory data) {\n        require(pos != 0, 'F:1');\n\n        pos--;\n\n        uint8 totalLength = featureLengths[implementer][feature];\n\n        require(pos < totalLength, 'F:2');\n\n        uint168[] memory ptrs = sstore2Pointers[implementer][feature];\n\n        address store;\n        uint8 storePos;\n\n        uint8 workingPos;\n\n        for (uint256 i = 0; i < ptrs.length; i++) {\n            uint8 here = uint8(ptrs[i] >> 160);\n            if (workingPos + here > pos) {\n                store = address(uint160(ptrs[i]));\n                storePos = pos - workingPos;\n                break;\n            } else {\n                workingPos += here;\n            }\n        }\n\n        require(store != address(0), 'F:3');\n\n        data = abi.decode(SSTORE2.read(address(uint160(store))), (uint256[][]))[storePos];\n    }\n}\n"
    },
    "src/DotnuggV1Lib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IDotnuggV1Processor} from './interfaces/IDotnuggV1Processor.sol';\nimport {IDotnuggV1Data} from './interfaces/IDotnuggV1Data.sol';\nimport {IDotnuggV1Resolver} from './interfaces/IDotnuggV1Resolver.sol';\nimport {IDotnuggV1Implementer} from './interfaces/IDotnuggV1Implementer.sol';\n\nimport {BitReader} from './libraries/BitReader.sol';\nimport {Base64} from './libraries/Base64.sol';\n\nimport {Calculator} from './logic/Calculator.sol';\nimport {Matrix} from './logic/Matrix.sol';\nimport {Svg} from './logic/Svg.sol';\n\nimport {ShiftLib} from './libraries/ShiftLib.sol';\nimport {Base64} from './libraries/Base64.sol';\n\nimport {Version} from './types/Version.sol';\nimport {Types} from './types/Types.sol';\nimport {DotnuggV1Storage} from './logic/DotnuggV1Storage.sol';\nimport {StringCastLib} from './libraries/StringCastLib.sol';\n\ncontract DotnuggV1Lib {\n    using BitReader for BitReader.Memory;\n\n    function processCore(\n        uint256[][] memory files,\n        IDotnuggV1Data.Data memory data,\n        uint8 width\n    ) public pure returns (uint256[] memory resp) {\n        require(data.version == 1, 'V1s');\n\n        require(width <= 64 && width > 4, 'V1:SIZE');\n\n        if (width % 2 == 0) width--;\n\n        Version.Memory[][] memory versions = parse(files, data.xovers, data.yovers);\n\n        Types.Matrix memory old = combine(8, width, versions);\n\n        resp = compressBigMatrix(old.version.bigmatrix, old.version.data);\n    }\n\n    function combine(\n        uint256 featureLen,\n        uint8 width,\n        Version.Memory[][] memory versions\n    ) internal pure returns (Types.Matrix memory resa) {\n        Types.Canvas memory canvas;\n        canvas.matrix = Matrix.create(width, width);\n        canvas.receivers = new Types.Anchor[](featureLen);\n        Types.Coordinate memory coord;\n        coord.a = width / 2 + 1;\n        coord.b = width / 2 + 1;\n        coord.exists = true;\n        Types.Rlud memory r;\n        for (uint8 i = 0; i < featureLen; i++) {\n            canvas.receivers[i] = Types.Anchor({coordinate: coord, radii: r});\n        }\n        canvas.matrix.width = width;\n        canvas.matrix.height = width;\n\n        Types.Mix memory mix;\n        mix.matrix = Matrix.create(width, width);\n        mix.receivers = new Types.Anchor[](featureLen);\n\n        for (uint8 i = 0; i < versions.length; i++) {\n            if (versions[i].length > 0) {\n                Calculator.setMix(mix, versions[i], Calculator.pickVersionIndex(canvas, versions[i]));\n\n                Calculator.formatForCanvas(canvas, mix);\n\n                Calculator.postionForCanvas(canvas, mix);\n\n                Calculator.mergeToCanvas(canvas, mix);\n\n                Calculator.calculateReceivers(mix);\n\n                Calculator.updateReceivers(canvas, mix);\n            }\n        }\n\n        return canvas.matrix;\n    }\n\n    function parse(\n        uint256[][] memory data,\n        uint8[] memory xovers,\n        uint8[] memory yovers\n    ) internal pure returns (Version.Memory[][] memory m) {\n        m = new Version.Memory[][](data.length);\n\n        for (uint256 j = 0; j < data.length; j++) {\n            (bool empty, BitReader.Memory memory reader) = BitReader.init(data[j]);\n\n            if (empty) continue;\n\n            // indicates dotnuggV1 encoded file\n            require(reader.select(32) == 0x420690_01, 'DEC:PI:0');\n\n            uint256 feature = reader.select(3);\n\n            uint256 id = reader.select(8);\n\n            uint256[] memory pallet = Version.parsePallet(reader, id, feature);\n\n            uint256 versionLength = reader.select(2) + 1;\n\n            m[j] = new Version.Memory[](versionLength);\n\n            for (uint256 i = 0; i < versionLength; i++) {\n                m[j][i].data = Version.parseData(reader, feature, xovers, yovers);\n\n                m[j][i].receivers = Version.parseReceivers(reader);\n\n                (uint256 width, uint256 height) = Version.getWidth(m[j][i]);\n\n                m[j][i].minimatrix = Version.parseMiniMatrix(reader, width, height);\n\n                m[j][i].pallet = pallet;\n            }\n        }\n    }\n\n    function decompressBigMatrix(uint256[] memory input) public pure returns (uint256[] memory res) {\n        res = new uint256[]((input[input.length - 1] >> 240));\n\n        uint256 counter = 0;\n\n        for (uint256 i = 0; i < input.length; i++) {\n            uint256 numzeros = input[i] & 0xf;\n\n            if (numzeros == 0xf) {\n                numzeros = input[i++] >> 4;\n            }\n\n            for (uint256 j = 0; j < numzeros; j++) {\n                // skips a row, keeping it at zero\n                counter++;\n            }\n\n            res[counter++] = input[i] >> 4;\n        }\n    }\n\n    function compressBigMatrix(uint256[] memory input, uint256 data) public pure returns (uint256[] memory res) {\n        // res = m.bigmatrix;\n\n        uint256 counter;\n        uint256 rescounter;\n        uint256 zerocount;\n\n        do {\n            if (input[counter] == 0) {\n                zerocount++;\n                continue;\n            }\n\n            if (zerocount > 14) {\n                input[rescounter++] = (zerocount << 4) | 0xf;\n                zerocount = 0;\n            }\n\n            input[rescounter++] = (input[counter] << 4) | zerocount;\n\n            zerocount = 0;\n        } while (++counter < input.length);\n\n        if (zerocount > 14) {\n            input[rescounter++] = (zerocount << 4) | 0xf;\n            zerocount = 0;\n        }\n\n        input[rescounter++] = (data << 4) | zerocount | ((input.length + 1) << 240);\n\n        Version.setArrayLength(input, rescounter);\n\n        return input;\n    }\n\n    function buildSvg(uint256[] memory file, uint8 zoom) external pure returns (bytes memory res) {\n        file = decompressBigMatrix(file);\n\n        uint256 width = (file[file.length - 1] >> 63) & ShiftLib.mask(6);\n        uint256 height = (file[file.length - 1] >> 69) & ShiftLib.mask(6);\n\n        res = Svg.build(file, width, height, zoom);\n\n        return svgBase64(res);\n    }\n\n    function svgBase64(bytes memory input) public pure returns (bytes memory res) {\n        res = base64(abi.encodePacked(Base64.PREFIX_SVG, input));\n    }\n\n    function jsonBase64(bytes memory input) public pure returns (bytes memory res) {\n        res = base64(abi.encodePacked(Base64.PREFIX_JSON, input));\n    }\n\n    function dotnuggBase64(bytes memory input) public pure returns (bytes memory res) {\n        res = base64(abi.encodePacked(Base64.PREFIX_DOTNUGG, input));\n    }\n\n    function base64(bytes memory input) public pure returns (bytes memory res) {\n        res = Base64._encode(input);\n    }\n\n    function uintToAscii(uint256 input) public pure returns (string memory res) {\n        res = StringCastLib.toAsciiString(input);\n    }\n\n    function uintToHex(uint256 input, uint8 length) public pure returns (string memory res) {\n        res = StringCastLib.toHexString(input, length);\n    }\n}\n"
    },
    "src/libraries/SSTORE2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\n/// Adapted from Rari-Capital/solmate\n\n/// @notice Read and write to persistent storage at a fraction of the cost.\n/// @author Modified from 0xSequence (https://github.com/0xsequence/sstore2/blob/master/contracts/SSTORE2.sol)\nlibrary SSTORE2 {\n    uint256 internal constant DATA_OFFSET = 1;\n\n    function write(bytes memory data) internal returns (address pointer) {\n        bytes memory runtimeCode = abi.encodePacked(hex'00', data);\n\n        bytes memory creationCode = abi.encodePacked(hex'63', uint32(runtimeCode.length), hex'80_60_0E_60_00_39_60_00_F3', runtimeCode);\n\n        assembly {\n            pointer := create(0, add(creationCode, 32), mload(creationCode))\n        }\n\n        require(pointer != address(0), 'DEPLOYMENT_FAILED');\n    }\n\n    function read(address pointer) internal view returns (bytes memory) {\n        return readBytecode(pointer, DATA_OFFSET, pointer.code.length - DATA_OFFSET);\n    }\n\n    function read(address pointer, uint256 start) internal view returns (bytes memory) {\n        start += DATA_OFFSET;\n\n        return readBytecode(pointer, start, pointer.code.length - start);\n    }\n\n    function read(\n        address pointer,\n        uint256 start,\n        uint256 end\n    ) internal view returns (bytes memory) {\n        start += DATA_OFFSET;\n        end += DATA_OFFSET;\n\n        require(pointer.code.length >= end, 'OUT_OF_BOUNDS');\n\n        return readBytecode(pointer, start, end - start);\n    }\n\n    function readBytecode(\n        address pointer,\n        uint256 start,\n        uint256 size\n    ) private view returns (bytes memory data) {\n        assembly {\n            data := mload(0x40)\n            mstore(0x40, add(data, and(add(add(size, add(start, 0x20)), 0x1f), not(0x1f))))\n            mstore(data, size)\n            extcodecopy(pointer, add(data, 0x20), start, size)\n        }\n    }\n}\n"
    },
    "src/libraries/SafeCastLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\nimport {ShiftLib} from './ShiftLib.sol';\n\nlibrary SafeCastLib {\n    function safe252(uint256 x) internal pure returns (uint256 y) {\n        require(x <= ShiftLib.mask(252), 'SC:252');\n        return x;\n    }\n\n    function safe160(uint256 x) internal pure returns (uint160 y) {\n        require(x <= type(uint160).max);\n        y = uint160(x);\n    }\n\n    function safe96(uint256 x) internal pure returns (uint96 y) {\n        require(x <= type(uint96).max);\n        y = uint96(x);\n    }\n\n    function safe64(uint256 x) internal pure returns (uint64 y) {\n        require(x <= type(uint64).max);\n        y = uint64(x);\n    }\n\n    function safe32(uint256 x) internal pure returns (uint32 y) {\n        require(x <= type(uint32).max);\n        y = uint32(x);\n    }\n\n    function safe16(uint256 x) internal pure returns (uint16 y) {\n        require(x <= type(uint16).max);\n        y = uint16(x);\n    }\n\n    function safe8(uint256 x) internal pure returns (uint8 y) {\n        require(x <= type(uint8).max);\n        y = uint8(x);\n    }\n\n    function safe6(uint256 x) internal pure returns (uint8 y) {\n        require(x <= 0xf7);\n        y = uint8(x);\n    }\n\n    function safe4(uint256 x) internal pure returns (uint8 y) {\n        require(x <= 0xf);\n        y = uint8(x);\n    }\n\n    function safe3(uint256 x) internal pure returns (uint8 y) {\n        require(x <= 0x7);\n        y = uint8(x);\n    }\n}\n"
    },
    "src/libraries/ShiftLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {SafeCastLib} from './SafeCastLib.sol';\n\nlibrary ShiftLib {\n    using SafeCastLib for uint256;\n\n    /// @notice creates a bit mask\n    /// @dev res = (2 ^ bits) - 1\n    /// @param bits d\n    /// @return res d\n    /// @dev no need to check if \"bits\" is < 256 as anything greater than 255 will be treated the same\n    function mask(uint8 bits) internal pure returns (uint256 res) {\n        assembly {\n            res := sub(shl(bits, 1), 1)\n        }\n    }\n\n    function fullsubmask(uint8 bits, uint8 pos) internal pure returns (uint256 res) {\n        res = ~(mask(bits) << pos);\n    }\n\n    function set(\n        uint256 cache,\n        uint8 bits,\n        uint8 pos,\n        uint256 value\n    ) internal pure returns (uint256 res) {\n        res = cache & fullsubmask(bits, pos);\n\n        assembly {\n            value := shl(pos, value)\n        }\n\n        res |= value;\n    }\n\n    function get(\n        uint256 cache,\n        uint8 bits,\n        uint8 pos\n    ) internal pure returns (uint256 res) {\n        assembly {\n            res := shr(pos, cache)\n        }\n        res &= mask(bits);\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                ARRAYS\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function getArray8x8(uint256 store, uint8 pos) internal pure returns (uint8[] memory arr) {\n        store = get(store, 64, pos);\n\n        arr = new uint8[](8);\n        for (uint256 i = 0; i < 8; i++) {\n            arr[i] = uint8(store & 0xff);\n            store >>= 8;\n        }\n    }\n\n    function setArray8x8(\n        uint256 store,\n        uint8 pos,\n        uint8[] memory arr\n    ) internal pure returns (uint256 res) {\n        for (uint256 i = 8; i > 0; i--) {\n            res |= uint256(arr[i - 1]) << ((8 * (i - 1)));\n        }\n\n        res = set(store, 64, pos, res);\n    }\n}\n"
    },
    "src/libraries/BitReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport '../libraries/ShiftLib.sol';\n\nlibrary BitReader {\n    using ShiftLib for uint256;\n\n    struct Memory {\n        uint256[] dat;\n        uint256 moves;\n        uint256 pos;\n    }\n\n    function init(uint256[] memory input) internal pure returns (bool err, Memory memory m) {\n        if (input.length == 0) return (true, m);\n\n        m.dat = input;\n\n        m.moves = 2;\n\n        m.dat = new uint256[](input.length);\n\n        for (uint256 i = input.length; i > 0; i--) {\n            m.dat[i - 1] = input[input.length - i];\n        }\n    }\n\n    function peek(Memory memory m, uint8 bits) internal pure returns (uint256 res) {\n        res = m.dat[0] & ShiftLib.mask(bits);\n    }\n\n    function select(Memory memory m, uint8 bits) internal pure returns (uint256 res) {\n        res = m.dat[0] & ShiftLib.mask(bits);\n\n        m.dat[0] = m.dat[0] >> bits;\n\n        m.pos += bits;\n\n        if (m.pos >= 128) {\n            uint256 ptr = (m.moves / 2);\n            if (ptr < m.dat.length) {\n                m.dat[0] <<= m.pos - 128;\n                uint256 move = m.dat[ptr] & ShiftLib.mask(128);\n                m.dat[ptr] >>= 128;\n                m.dat[0] |= (move << 128);\n                m.dat[0] >>= (m.pos - 128);\n                m.moves++;\n                m.pos -= 128;\n            }\n        }\n    }\n}\n"
    },
    "src/libraries/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\n/**\n * @title Base64\n * @author Nugg Labs - @danny7even & @dub6ix\n * @notice library for encoding bytes into base64\n */\nlibrary Base64 {\n    string internal constant _TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    string internal constant PREFIX_JSON = 'data:application/json;base64,';\n    string internal constant PREFIX_DOTNUGG = 'data:image/dotnugg;base64,';\n    string internal constant PREFIX_SVG = 'data:image/svg+xml;base64,';\n\n    /**\n     * @notice wrapper for _encode for svg data\n     * @param data bytes to encode\n     * @return base64 string representation of input bytes, prefixed with json base64 prefix\n     */\n    function encode(bytes memory data, string memory file) internal pure returns (string memory) {\n        return string(abi.encodePacked('data:', file, ';base64,', _encode(data)));\n    }\n\n    /**\n     * @notice Encodes some bytes in base64\n     * @param data bytes to encode\n     * @return base64 string representation of input bytes\n     * @dev Credit to Brecht Devos - <brecht@loopring.org> - under MIT license https://github.com/Brechtpd/base64/blob/main/base64.sol\n     * @dev modified for solidity v8\n     */\n    function _encode(bytes memory data) internal pure returns (bytes memory) {\n        if (data.length == 0) return '';\n\n        // load the table into memory\n        string memory table = _TABLE;\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n\n        // add some extra buffer at the end required for the writing\n        bytes memory result = new bytes(encodedLen + 32);\n\n        assembly {\n            // set the actual output length\n            mstore(result, encodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 3 bytes at a time\n            for {\n\n            } lt(dataPtr, endPtr) {\n\n            } {\n                dataPtr := add(dataPtr, 3)\n\n                // read 3 bytes\n                let input := mload(dataPtr)\n\n                // write 4 characters\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(6, input), 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(input, 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n            }\n\n            // padding with '='\n            switch mod(mload(data), 3)\n            case 1 {\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\n            }\n            case 2 {\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\n            }\n        }\n\n        return result;\n    }\n}\n"
    },
    "src/logic/Calculator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport './Matrix.sol';\nimport './Rgba.sol';\nimport './Anchor.sol';\n\nimport '../types/Version.sol';\nimport '../types/Pixel.sol';\n\nimport '../types/Types.sol';\n\nlibrary Calculator {\n    using Rgba for Types.Rgba;\n    using Matrix for Types.Matrix;\n    using Pixel for uint256;\n\n    /**\n     * @notice\n     * @devg\n     */\n    function postionForCanvas(Types.Canvas memory canvas, Types.Mix memory mix) internal pure {\n        Types.Anchor memory receiver = canvas.receivers[mix.feature];\n        Types.Anchor memory anchor = mix.version.anchor;\n\n        mix.xoffset = receiver.coordinate.a > anchor.coordinate.a ? receiver.coordinate.a - anchor.coordinate.a : 0;\n        mix.yoffset = receiver.coordinate.b > anchor.coordinate.b ? receiver.coordinate.b - anchor.coordinate.b : 0;\n\n        canvas.matrix.moveTo(mix.xoffset, mix.yoffset, mix.matrix.width, mix.matrix.height);\n    }\n\n    /**\n     * @notice\n     * @dev\n     */\n    function formatForCanvas(Types.Canvas memory canvas, Types.Mix memory mix) internal pure {\n        Types.Anchor memory receiver = canvas.receivers[mix.feature];\n        Types.Anchor memory anchor = mix.version.anchor;\n\n        if (mix.version.expanders.l != 0 && anchor.radii.l != 0 && anchor.radii.l <= receiver.radii.l) {\n            uint8 amount = receiver.radii.l - anchor.radii.l;\n            mix.matrix.addColumnsAt(mix.version.expanders.l - 1, amount);\n            anchor.coordinate.a += amount;\n            if (mix.version.expanders.r > 0) mix.version.expanders.r += amount;\n        }\n        if (mix.version.expanders.r != 0 && anchor.radii.r != 0 && anchor.radii.r <= receiver.radii.r) {\n            mix.matrix.addColumnsAt(mix.version.expanders.r - 1, receiver.radii.r - anchor.radii.r);\n        }\n        if (mix.version.expanders.d != 0 && anchor.radii.d != 0 && anchor.radii.d <= receiver.radii.d) {\n            uint8 amount = receiver.radii.d - anchor.radii.d;\n            mix.matrix.addRowsAt(mix.version.expanders.d, amount);\n            anchor.coordinate.b += amount;\n            if (mix.version.expanders.u > 0) mix.version.expanders.u += amount;\n        }\n        if (mix.version.expanders.u != 0 && anchor.radii.u != 0 && anchor.radii.u <= receiver.radii.u) {\n            mix.matrix.addRowsAt(mix.version.expanders.u, receiver.radii.u - anchor.radii.u);\n        }\n    }\n\n    function pickVersionIndex(Types.Canvas memory canvas, Version.Memory[] memory versions) internal pure returns (uint8) {\n        require(versions.length > 0, 'CALC:PVI:0');\n        if (versions.length == 1) {\n            return 0;\n        }\n        uint8 index = uint8(versions.length) - 1;\n\n        uint256 feature = (versions[0].data >> 75) & ShiftLib.mask(3);\n\n        while (index > 0) {\n            uint256 bits = (versions[index].data >> 27) & ShiftLib.mask(24);\n            Types.Rlud memory anchorRadii = Types.Rlud({\n                r: uint8((bits >> 18) & ShiftLib.mask(6)),\n                l: uint8((bits >> 12) & ShiftLib.mask(6)),\n                u: uint8((bits >> 6) & ShiftLib.mask(6)),\n                d: uint8((bits) & ShiftLib.mask(6)),\n                exists: true\n            });\n\n            if (checkRluds(anchorRadii, canvas.receivers[feature].radii)) {\n                return index;\n            }\n            index = index - 1;\n        }\n\n        return 0;\n    }\n\n    function checkRluds(Types.Rlud memory r1, Types.Rlud memory r2) internal pure returns (bool) {\n        return (r1.r <= r2.r && r1.l <= r2.l) || (r1.u <= r2.u && r1.d <= r2.d);\n    }\n\n    function setMix(\n        Types.Mix memory res,\n        Version.Memory[] memory versions,\n        uint8 versionIndex\n    ) internal pure {\n        uint256 radiiBits = (versions[versionIndex].data >> 27) & ShiftLib.mask(24);\n        uint256 expanderBits = (versions[versionIndex].data >> 3) & ShiftLib.mask(24);\n\n        (uint256 x, uint256 y) = Version.getAnchor(versions[versionIndex]);\n\n        (uint256 width, uint256 height) = Version.getWidth(versions[versionIndex]);\n\n        res.version.width = uint8(width);\n        res.version.height = uint8(height);\n        res.version.anchor = Types.Anchor({\n            radii: Types.Rlud({\n                r: uint8((radiiBits >> 18) & ShiftLib.mask(6)),\n                l: uint8((radiiBits >> 12) & ShiftLib.mask(6)),\n                u: uint8((radiiBits >> 6) & ShiftLib.mask(6)),\n                d: uint8((radiiBits >> 0) & ShiftLib.mask(6)),\n                exists: true\n            }),\n            coordinate: Types.Coordinate({a: uint8(x), b: uint8(y), exists: true})\n        });\n        res.version.expanders = Types.Rlud({\n            r: uint8((expanderBits >> 18) & ShiftLib.mask(6)),\n            l: uint8((expanderBits >> 12) & ShiftLib.mask(6)),\n            u: uint8((expanderBits >> 6) & ShiftLib.mask(6)),\n            d: uint8((expanderBits >> 0) & ShiftLib.mask(6)),\n            exists: true\n        });\n        res.version.calculatedReceivers = new Types.Coordinate[](8);\n\n        res.version.staticReceivers = new Types.Coordinate[](8);\n\n        for (uint256 i = 0; i < 8; i++) {\n            (uint256 _x, uint256 _y, bool exists) = Version.getReceiverAt(versions[versionIndex], i, false);\n            if (exists) {\n                res.version.staticReceivers[i].a = uint8(_x);\n                res.version.staticReceivers[i].b = uint8(_y);\n                res.version.staticReceivers[i].exists = true;\n            }\n        }\n\n        for (uint256 i = 0; i < 8; i++) {\n            (uint256 _x, uint256 _y, bool exists) = Version.getReceiverAt(versions[versionIndex], i, true);\n            if (exists) {\n                res.version.calculatedReceivers[i].a = uint8(_x);\n                res.version.calculatedReceivers[i].b = uint8(_y);\n                res.version.calculatedReceivers[i].exists = true;\n            }\n        }\n\n        // TODO - receivers?\n        res.xoffset = 0;\n        res.yoffset = 0;\n        res.receivers = new Types.Anchor[](res.receivers.length);\n        res.feature = uint8((versions[versionIndex].data >> 75) & ShiftLib.mask(3));\n        res.matrix.set(versions[versionIndex], width, height);\n    }\n\n    function updateReceivers(Types.Canvas memory canvas, Types.Mix memory mix) internal pure {\n        for (uint8 i = 0; i < mix.receivers.length; i++) {\n            Types.Anchor memory m = mix.receivers[i];\n            if (m.coordinate.exists) {\n                m.coordinate.a += mix.xoffset;\n                m.coordinate.b += mix.yoffset;\n                canvas.receivers[i] = m;\n            }\n        }\n    }\n\n    function mergeToCanvas(Types.Canvas memory canvas, Types.Mix memory mix) internal pure {\n        while (canvas.matrix.next() && mix.matrix.next()) {\n            uint256 canvasPixel = canvas.matrix.current();\n            uint256 mixPixel = mix.matrix.current();\n\n            if (mixPixel.e() && mixPixel.z() >= canvasPixel.z()) {\n                canvas.matrix.setCurrent(Rgba.combine(canvasPixel, mixPixel));\n            }\n        }\n        canvas.matrix.moveBack();\n        canvas.matrix.resetIterator();\n        mix.matrix.resetIterator();\n    }\n\n    function calculateReceivers(Types.Mix memory mix) internal pure {\n        Anchor.convertReceiversToAnchors(mix);\n    }\n}\n"
    },
    "src/logic/Matrix.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {Rgba} from '../logic/Rgba.sol';\n\nimport {Version} from '../types/Version.sol';\nimport {Types} from '../types/Types.sol';\n\nlibrary Matrix {\n    using Rgba for Types.Rgba;\n    using Version for Version.Memory;\n\n    function create(uint8 width, uint8 height) internal pure returns (Types.Matrix memory res) {\n        require(width % 2 == 1 && height % 2 == 1, 'ML:C:0');\n\n        Version.initBigMatrix(res.version, width);\n        res.version.setWidth(width, height);\n    }\n\n    function moveTo(\n        Types.Matrix memory matrix,\n        uint8 xoffset,\n        uint8 yoffset,\n        uint8 width,\n        uint8 height\n    ) internal pure {\n        matrix.currentUnsetX = xoffset;\n        matrix.currentUnsetY = yoffset;\n        matrix.startX = xoffset;\n        matrix.width = width + xoffset;\n        matrix.height = height + yoffset;\n    }\n\n    function next(Types.Matrix memory matrix) internal pure returns (bool res) {\n        res = next(matrix, matrix.width);\n    }\n\n    function next(Types.Matrix memory matrix, uint8 width) internal pure returns (bool res) {\n        if (matrix.init) {\n            if (width <= matrix.currentUnsetX + 1) {\n                if (matrix.height == matrix.currentUnsetY + 1) {\n                    return false;\n                }\n                matrix.currentUnsetX = matrix.startX; // 0 by default\n                matrix.currentUnsetY++;\n            } else {\n                matrix.currentUnsetX++;\n            }\n        } else {\n            matrix.init = true;\n        }\n        res = true;\n    }\n\n    function current(Types.Matrix memory matrix) internal pure returns (uint256 res) {\n        res = matrix.version.getBigMatrixPixelAt(matrix.currentUnsetX, matrix.currentUnsetY);\n    }\n\n    function setCurrent(Types.Matrix memory matrix, uint256 pixel) internal pure {\n        matrix.version.setBigMatrixPixelAt(matrix.currentUnsetX, matrix.currentUnsetY, pixel);\n    }\n\n    function resetIterator(Types.Matrix memory matrix) internal pure {\n        matrix.currentUnsetX = 0;\n        matrix.currentUnsetY = 0;\n        matrix.startX = 0;\n        matrix.init = false;\n    }\n\n    function moveBack(Types.Matrix memory matrix) internal pure {\n        (uint256 width, uint256 height) = matrix.version.getWidth();\n        matrix.width = uint8(width);\n        matrix.height = uint8(height);\n    }\n\n    function set(\n        Types.Matrix memory matrix,\n        Version.Memory memory data,\n        uint256 groupWidth,\n        uint256 groupHeight\n    ) internal pure {\n        matrix.height = uint8(groupHeight);\n        // uint256 feature = data.getFeature();\n\n        for (uint256 y = 0; y < groupHeight; y++) {\n            for (uint256 x = 0; x < groupWidth; x++) {\n                next(matrix, uint8(groupWidth));\n                uint256 col = Version.getPixelAt(data, x, y);\n                if (col != 0) {\n                    (uint256 yo, , ) = Version.getPalletColorAt(data, col);\n\n                    setCurrent(matrix, yo);\n                } else {\n                    setCurrent(matrix, 0x0000000000);\n                }\n            }\n        }\n\n        matrix.width = uint8(groupWidth);\n\n        resetIterator(matrix);\n    }\n\n    function addRowsAt(\n        Types.Matrix memory matrix,\n        uint8 index,\n        uint8 amount\n    ) internal pure {\n        for (uint256 i = 0; i < matrix.height; i++) {\n            for (uint256 j = matrix.height; j > index; j--) {\n                if (j < index) break;\n                matrix.version.setBigMatrixPixelAt(i, j + amount, matrix.version.getBigMatrixPixelAt(i, j));\n            }\n            // \"<=\" is because this loop needs to run [amount] times\n            for (uint256 j = index + 1; j <= index + amount; j++) {\n                matrix.version.setBigMatrixPixelAt(i, j, matrix.version.getBigMatrixPixelAt(i, index));\n            }\n        }\n        matrix.height += amount;\n    }\n\n    function addColumnsAt(\n        Types.Matrix memory matrix,\n        uint8 index,\n        uint8 amount\n    ) internal pure {\n        // require(index < matrix.data[0].length, 'MAT:ACA:0');\n        for (uint256 i = 0; i < matrix.width; i++) {\n            for (uint256 j = matrix.width; j > index; j--) {\n                if (j < index) break;\n                matrix.version.setBigMatrixPixelAt(j + amount, i, matrix.version.getBigMatrixPixelAt(j, i));\n            }\n            // \"<=\" is because this loop needs to run [amount] times\n            for (uint256 j = index + 1; j <= index + amount; j++) {\n                matrix.version.setBigMatrixPixelAt(j, i, matrix.version.getBigMatrixPixelAt(index, i));\n            }\n        }\n        matrix.width += amount;\n    }\n}\n"
    },
    "src/logic/Svg.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {StringCastLib} from '../libraries/StringCastLib.sol';\nimport {ShiftLib} from '../libraries/ShiftLib.sol';\nimport {Pixel} from '../types/Pixel.sol';\nimport {Version} from '../types/Version.sol';\n\nlibrary Svg {\n    using StringCastLib for uint256;\n\n    function build(\n        uint256[] memory file,\n        uint256 width,\n        uint256 height,\n        uint8 zoom\n    ) internal pure returns (bytes memory res) {\n        bytes memory header = abi.encodePacked(\n            hex'3c7376672076696577426f783d2730203020', //\"<svg Box='0 0 \",\n            (zoom * width).toAsciiString(),\n            hex'20', // ' ',\n            (zoom * width).toAsciiString(),\n            hex'20272077696474683d27', //\"' width='\",\n            (zoom * width).toAsciiString(),\n            hex'27206865696768743d27', //  \"' height='\",\n            (zoom * width).toAsciiString(),\n            hex'2720786d6c6e733d27687474703a2f2f7777772e77332e6f72672f323030302f7376672720786d6c6e733a786c696e6b3d27687474703a2f2f7777772e77332e6f72672f313939392f786c696e6b273e5c6e' // \"' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'>\\n\"\n        );\n\n        bytes memory footer = hex'3c2f7376673e';\n\n        uint256 last = Version.getPixelAt(file, 0, 0, width);\n        uint256 count = 1;\n\n        // bytes[] memory rects = new bytes[](35);\n        bytes memory body;\n\n        for (uint256 y = 0; y < height; y++) {\n            for (uint256 x = 0; x < height; x++) {\n                if (y == 0 && x == 0) x++;\n                uint256 curr = Version.getPixelAt(file, x, y, width);\n                if (curr == last) {\n                    count++;\n                    continue;\n                } else {\n                    body = abi.encodePacked(body, getRekt(last, (x - count) * zoom, y * zoom, 1 * zoom, count * zoom));\n                    last = curr;\n                    count = 1;\n                }\n            }\n\n            body = abi.encodePacked(body, getRekt(last, (width - count) * zoom, y * zoom, 1 * zoom, count * zoom));\n            last = 0;\n            count = 0;\n        }\n\n        res = abi.encodePacked(header, body, footer);\n    }\n\n    function getRekt(\n        uint256 pixel,\n        uint256 x,\n        uint256 y,\n        uint256 xlen,\n        uint256 ylen\n    ) internal pure returns (bytes memory res) {\n        if (pixel & 0xff == 0) return '';\n        res = abi.encodePacked(\n            \"\\t<rect fill='#\",\n            pixel.toHexStringNoPrefix(4),\n            hex'2720783d27',\n            x.toAsciiString(),\n            hex'2720793d27',\n            y.toAsciiString(),\n            hex'27206865696768743d27',\n            xlen.toAsciiString(),\n            hex'272077696474683d27',\n            ylen.toAsciiString(),\n            \"'/>\\n\"\n        );\n    }\n}\n"
    },
    "src/types/Version.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {ShiftLib} from '../libraries/ShiftLib.sol';\nimport {BitReader} from '../libraries/BitReader.sol';\nimport {SafeCastLib} from '../libraries/SafeCastLib.sol';\n\nimport {Pixel} from '../types/Pixel.sol';\n\nlibrary Version {\n    using BitReader for BitReader.Memory;\n    using SafeCastLib for uint256;\n\n    struct Memory {\n        uint256[] pallet;\n        uint256[] minimatrix;\n        uint256[] bigmatrix;\n        uint256 receivers;\n        uint256 data;\n    }\n\n    function parsePallet(\n        BitReader.Memory memory reader,\n        uint256 id,\n        uint256 feature\n    ) internal pure returns (uint256[] memory res) {\n        uint256 palletLength = reader.select(4) + 1;\n\n        res = new uint256[](palletLength + 1);\n\n        for (uint256 i = 0; i < palletLength; i++) {\n            // uint256 working = 0;\n\n            // 4 bits: zindex\n            // working |= (reader.select(4) << 32);\n            uint256 z = reader.select(4);\n\n            uint256 color;\n\n            uint256 selecta = reader.select(1);\n            if (selecta == 1) {\n                color = 0x000000;\n            } else {\n                uint256 r = reader.select(8);\n                uint256 g = reader.select(8);\n                uint256 b = reader.select(8);\n\n                color = (r << 16) | (g << 8) | b;\n            }\n\n            // // 1 or 8 bits: a\n            uint256 a = (reader.select(1) == 0x1 ? 0xff : reader.select(8));\n\n            res[i + 1] = Pixel.safePack(color, a, id, z, feature);\n        }\n\n        // Event.pixLog(res, 'pixels');\n    }\n\n    function parseData(\n        BitReader.Memory memory reader,\n        uint256 feature,\n        uint8[] memory xovers,\n        uint8[] memory yovers\n    ) internal pure returns (uint256 res) {\n        // 12 bits: coordinate - anchor x and y\n\n        res |= feature << 75;\n\n        uint256 width = reader.select(6);\n        uint256 height = reader.select(6);\n\n        res |= height << 69; // heighth and width\n        res |= width << 63;\n\n        uint256 anchorX = reader.select(6);\n        uint256 anchorY = reader.select(6);\n\n        if (xovers.length == 8 && yovers.length == 8 && (xovers[feature] != 0 || yovers[feature] != 0)) {\n            res |= uint256(yovers[feature]) << 57;\n            res |= uint256(xovers[feature]) << 51;\n        } else {\n            // 12 bits: coordinate - anchor x and y\n            res |= anchorX << 51;\n            res |= anchorY << 57;\n        }\n\n        // 1 or 25 bits: rlud - radii\n        res |= (reader.select(1) == 0x1 ? 0x000000 : reader.select(24)) << 27;\n\n        // 1 or 25 bits: rlud - expanders\n        res |= (reader.select(1) == 0x1 ? 0x000000 : reader.select(24)) << 3;\n    }\n\n    function parseReceivers(BitReader.Memory memory reader) internal pure returns (uint256 res) {\n        uint256 receiversLength = reader.select(1) == 0x1 ? 0x1 : reader.select(4);\n\n        for (uint256 j = 0; j < receiversLength; j++) {\n            uint256 receiver = 0;\n\n            uint256 yOrYOffset = reader.select(6);\n\n            uint256 xOrPreset = reader.select(6);\n\n            // rFeature\n            uint256 rFeature = reader.select(3);\n\n            uint256 calculated = reader.select(1);\n\n            if (calculated == 0x1) {\n                receiver |= yOrYOffset << 6;\n                receiver |= xOrPreset;\n            } else {\n                receiver |= xOrPreset << 6;\n                receiver |= yOrYOffset;\n            }\n\n            receiver <<= ((rFeature * 12) + (calculated == 0x1 ? 128 : 0));\n\n            res |= receiver;\n        }\n    }\n\n    function parseMiniMatrix(\n        BitReader.Memory memory reader,\n        uint256 height,\n        uint256 width\n    ) internal pure returns (uint256[] memory res) {\n        uint256 groupsLength = reader.select(1) == 0x1 ? reader.select(8) + 1 : reader.select(16) + 1;\n\n        res = new uint256[]((height * width) / 64 + 1);\n\n        uint256 index = 0;\n\n        for (uint256 a = 0; a < groupsLength; a++) {\n            uint256 len = reader.select(2) + 1;\n\n            if (len == 4) len = reader.select(4) + 4;\n\n            uint256 key = reader.select(4);\n\n            for (uint256 i = 0; i < len; i++) {\n                res[index / 64] |= (key << (4 * (index % 64)));\n                index++;\n            }\n        }\n    }\n\n    function getReceiverAt(\n        Memory memory m,\n        uint256 index,\n        bool calculated\n    )\n        internal\n        pure\n        returns (\n            uint256 x,\n            uint256 y,\n            bool exists\n        )\n    {\n        uint256 data = m.receivers >> (index * 12 + (calculated ? 128 : 0));\n\n        data &= ShiftLib.mask(12);\n\n        x = data & ShiftLib.mask(6);\n        y = data >> 6;\n\n        exists = x != 0 || y != 0;\n    }\n\n    function setReceiverAt(\n        Memory memory m,\n        uint256 index,\n        bool calculated,\n        uint256 x,\n        uint256 y\n    ) internal pure returns (uint256 res) {\n        // yOrYOffset\n        res |= y << 6;\n\n        //xOrPreset\n        res |= x;\n\n        m.receivers |= res << ((index * 12) + (calculated ? 128 : 0));\n    }\n\n    function setOffset(\n        Memory memory m,\n        bool negX,\n        uint256 diffX,\n        bool negY,\n        uint256 diffY\n    ) internal pure {\n        m.data |= ((((diffX & 0xff) << 1) | (((negX ? 0x1 : 0x0)))) << 85);\n        m.data |= ((((diffY & 0xff) << 1) | ((((negY ? 0x1 : 0x0))))) << 94);\n    }\n\n    function getOffset(Memory memory m)\n        internal\n        pure\n        returns (\n            bool negX,\n            uint256 diffX,\n            bool negY,\n            uint256 diffY\n        )\n    {\n        uint256 data = m.data;\n        negX = (data >> 85) & 0x1 == 1;\n        diffX = (data >> 86) & 0xff;\n        negY = (data >> 94) & 0x1 == 1;\n        diffY = (data >> 95) & 0xff;\n    }\n\n    function setZ(Memory memory m, uint256 z) internal pure {\n        require(z <= 0xf, 'VERS:SETZ:0');\n        m.data |= z << 78;\n    }\n\n    function getZ(Memory memory m) internal pure returns (uint256 res) {\n        res = (m.data >> 78) & 0xf;\n    }\n\n    function setFeature(Memory memory m, uint256 z) internal pure {\n        require(z <= ShiftLib.mask(3), 'VERS:SETF:0');\n        m.data &= ShiftLib.fullsubmask(3, 75);\n        m.data |= (z << 75);\n    }\n\n    function getFeature(Memory memory m) internal pure returns (uint256 res) {\n        res = (m.data >> 75) & ShiftLib.mask(3);\n    }\n\n    function getWidth(Memory memory m) internal pure returns (uint256 width, uint256 height) {\n        // yOrYOffset\n        width = (m.data >> 63) & ShiftLib.mask(6);\n        height = (m.data >> 69) & ShiftLib.mask(6);\n    }\n\n    function setWidth(\n        Memory memory m,\n        uint256 w,\n        uint256 h\n    ) internal pure {\n        require(w <= ShiftLib.mask(6), 'VERS:SETW:0');\n        require(h <= ShiftLib.mask(6), 'VERS:SETW:1');\n\n        m.data &= ShiftLib.fullsubmask(12, 63);\n\n        m.data |= (w << 63);\n        m.data |= (h << 69);\n    }\n\n    function getAnchor(Memory memory m) internal pure returns (uint256 x, uint256 y) {\n        // yOrYOffset\n        x = (m.data >> 51) & ShiftLib.mask(6);\n        y = (m.data >> 57) & ShiftLib.mask(6);\n    }\n\n    function getOverrides(Memory memory m)\n        internal\n        pure\n        returns (\n            bool shouldOverride,\n            uint8 x,\n            uint8 y\n        )\n    {\n        // yOrYOffset\n        x = uint8((m.data >> 78) & ShiftLib.mask(6));\n        y = uint8((m.data >> 84) & ShiftLib.mask(6));\n\n        shouldOverride = x != 0 && y != 0;\n    }\n\n    function getPixelAt(\n        Memory memory m,\n        uint256 x,\n        uint256 y\n    ) internal pure returns (uint256 palletKey) {\n        (uint256 width, ) = getWidth(m);\n        uint256 index = x + (y * width);\n\n        if (index / 64 >= m.minimatrix.length) return 0x0;\n\n        palletKey = (m.minimatrix[index / 64] >> (4 * (index % 64))) & 0xf;\n    }\n\n    function getPalletColorAt(Memory memory m, uint256 index)\n        internal\n        pure\n        returns (\n            uint256 res,\n            uint256 color,\n            uint256 zindex\n        )\n    {\n        // res = (m.pallet[index / 7] >> (36 * (index % 7))) & ShiftLib.mask(36);\n        res = m.pallet[index];\n\n        color = Pixel.rgba(res);\n\n        zindex = Pixel.z(res);\n    }\n\n    function initBigMatrix(Memory memory m, uint256 width) internal pure {\n        m.bigmatrix = new uint256[](((width * width) / 6) + 2);\n    }\n\n    function setBigMatrixPixelAt(\n        Memory memory m,\n        uint256 x,\n        uint256 y,\n        uint256 color\n    ) internal pure {\n        (uint256 width, ) = getWidth(m);\n\n        uint256 index = x + (y * width);\n\n        setBigMatrixPixelAt(m, index, color);\n    }\n\n    function setBigMatrixPixelAt(\n        Memory memory m,\n        uint256 index,\n        uint256 color\n    ) internal pure {\n        if (m.bigmatrix.length > index / 6) {\n            uint8 offset = (42 * (index % 6)).safe8();\n            m.bigmatrix[index / 6] &= ShiftLib.fullsubmask(42, offset);\n            m.bigmatrix[index / 6] |= (color << offset);\n        }\n    }\n\n    function getBigMatrixPixelAt(\n        Memory memory m,\n        uint256 x,\n        uint256 y\n    ) internal pure returns (uint256 res) {\n        (uint256 width, ) = getWidth(m);\n\n        return getPixelAt(m.bigmatrix, x, y, width);\n    }\n\n    function getPixelAt(\n        uint256[] memory arr,\n        uint256 x,\n        uint256 y,\n        uint256 width\n    ) internal pure returns (uint256 res) {\n        uint256 index = x + (y * width);\n\n        if (index / 6 >= arr.length) return 0x0000000000;\n\n        res = (arr[index / 6] >> (42 * (index % 6))) & ShiftLib.mask(42);\n    }\n\n    function bigMatrixHasPixelAt(\n        Memory memory m,\n        uint256 x,\n        uint256 y\n    ) internal pure returns (bool res) {\n        uint256 pix = getBigMatrixPixelAt(m, x, y);\n\n        res = pix & 0x7 != 0x00;\n    }\n\n    function setArrayLength(uint256[] memory input, uint256 size) internal pure {\n        assembly {\n            let ptr := mload(input)\n            ptr := size\n            mstore(input, ptr)\n        }\n    }\n}\n"
    },
    "src/types/Types.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {Version as NewVersion} from '../types/Version.sol';\n\nlibrary Types {\n    struct Rlud {\n        bool exists;\n        uint8 r;\n        uint8 l;\n        uint8 u;\n        uint8 d;\n    }\n\n    struct Rgba {\n        uint8 r;\n        uint8 g;\n        uint8 b;\n        uint8 a;\n    }\n\n    struct Anchor {\n        Rlud radii;\n        Coordinate coordinate;\n    }\n\n    struct Coordinate {\n        uint8 a; // anchorId\n        uint8 b; // yoffset\n        bool exists;\n    }\n\n    struct Version {\n        uint8 width;\n        uint8 height;\n        Anchor anchor;\n        // these must be in same order as canvas receivers, respectively\n        Coordinate[] calculatedReceivers; // can be empty\n        Coordinate[] staticReceivers; // can be empty\n        Rlud expanders;\n        bytes data;\n    }\n\n    struct Canvas {\n        Matrix matrix;\n        Anchor[] receivers;\n    }\n\n    struct Mix {\n        uint8 feature;\n        Version version;\n        Matrix matrix;\n        Anchor[] receivers;\n        uint8 yoffset;\n        uint8 xoffset;\n    }\n\n    struct Matrix {\n        uint8 width;\n        uint8 height;\n        NewVersion.Memory version;\n        uint8 currentUnsetX;\n        uint8 currentUnsetY;\n        bool init;\n        uint8 startX;\n    }\n}\n"
    },
    "src/libraries/StringCastLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\n/*\n * @dev Uint operations.\n */\nlibrary StringCastLib {\n    bytes16 private constant ALPHABET = '0123456789abcdef';\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toAsciiString(uint256 value) internal pure returns (string memory) {\n        return string(toAsciiBytes(value));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toAsciiBytes(uint256 value) internal pure returns (bytes memory buffer) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return '0';\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n\n        buffer = new bytes(digits);\n\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return buffer;\n    }\n\n    /// @notice Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n    /// @dev Credit to Open Zeppelin under MIT license https://github.com/OpenZeppelin/openzeppelin-contracts/blob/243adff49ce1700e0ecb99fe522fb16cff1d1ddc/contracts/utils/Strings.sol#L55\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = '0';\n        buffer[1] = 'x';\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = ALPHABET[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, 'Strings: hex length insufficient');\n        return string(buffer);\n    }\n\n    function toHexStringNoPrefix(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length);\n        for (uint256 i = buffer.length; i > 0; i--) {\n            buffer[i - 1] = ALPHABET[value & 0xf];\n            value >>= 4;\n        }\n        return string(buffer);\n    }\n}\n"
    },
    "src/logic/Rgba.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {Pixel} from '../types/Pixel.sol';\n\nlibrary Rgba {\n    using Pixel for uint256;\n\n    function combine(uint256 base, uint256 mix) internal pure returns (uint256 res) {\n        if (mix.a() == 255 || base.a() == 0) {\n            res = mix;\n            return res;\n        }\n        res |= uint256((base.r() * (255 - mix.a()) + mix.r() * mix.a()) / 255) << 19;\n        res |= uint256((base.g() * (255 - mix.a()) + mix.g() * mix.a()) / 255) << 11;\n        res |= uint256((base.b() * (255 - mix.a()) + mix.b() * mix.a()) / 255) << 3;\n        res |= 0x7;\n    }\n}\n"
    },
    "src/types/Pixel.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {SafeCastLib} from '../libraries/SafeCastLib.sol';\nimport {ShiftLib} from '../libraries/ShiftLib.sol';\n\nlibrary Pixel {\n    using SafeCastLib for uint256;\n\n    function safePack(\n        uint256 _rgb,\n        uint256 _a,\n        uint256 _id,\n        uint256 _zindex,\n        uint256 _feature\n    ) internal pure returns (uint256 res) {\n        unchecked {\n            res |= uint256(_feature.safe3()) << 39;\n            res |= uint256(_zindex.safe4()) << 35;\n            res |= uint256(_id.safe8()) << 27;\n            res |= uint256(_rgb) << 3;\n            res |= uint256(compressA(_a.safe8()));\n        }\n    }\n\n    function unsafePack(\n        uint256 _rgb,\n        uint256 _a,\n        uint256 _id,\n        uint256 _zindex,\n        uint256 _feature\n    ) internal pure returns (uint256 res) {\n        unchecked {\n            res |= _feature << 39;\n            res |= _zindex << 35;\n            res |= _id << 27;\n            res |= _rgb << 3;\n            res |= compressA(uint8(_a));\n        }\n    }\n\n    function rgba(uint256 input) internal pure returns (uint256 res) {\n        return ((input << 5) & 0xffffff_00) | a(input);\n    }\n\n    function r(uint256 input) internal pure returns (uint256 res) {\n        res = (input >> 19) & 0xff;\n    }\n\n    function g(uint256 input) internal pure returns (uint256 res) {\n        res = (input >> 11) & 0xff;\n    }\n\n    function b(uint256 input) internal pure returns (uint256 res) {\n        res = (input >> 3) & 0xff;\n    }\n\n    // 3 bits\n    function a(uint256 input) internal pure returns (uint256 res) {\n        res = decompressA(uint8(input & 0x7));\n    }\n\n    // this is 1-8 so 3 bits\n    function id(uint256 input) internal pure returns (uint256 res) {\n        res = (input >> 27) & 0xff;\n    }\n\n    // 18 3,3,4 && 8\n    // this is 1-16 so 4 bits\n    function z(uint256 input) internal pure returns (uint256 res) {\n        res = (input >> 35) & 0xf;\n    }\n\n    // this is 1-8 so 3 bits\n    function f(uint256 input) internal pure returns (uint256 res) {\n        res = (input >> 39) & 0x7;\n    }\n\n    /// @notice check for if a pixel exists\n    /// @dev for a pixel to exist a must be > 0, so we can safely assume that if we see\n    /// no data it is empty or a transparent pixel we do not need to process\n    function e(uint256 input) internal pure returns (bool res) {\n        res = input != 0x00;\n    }\n\n    /// @notice converts an 8 bit (0-255) value into a 3 bit value (0-7)\n    /// @dev a compressed value of 7 is equivilent to 255, and a compressed 0 is 0\n    function compressA(uint256 input) internal pure returns (uint256 res) {\n        return input.safe8() / 36;\n    }\n\n    /// @notice converts an 8 bit value into a 3 bit value\n    function decompressA(uint256 input) internal pure returns (uint256 res) {\n        if (input == 7) return 255;\n        else return input.safe3() * 36;\n    }\n}\n"
    },
    "src/_test/system/system1.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {NuggFatherFix} from '../fixtures/NuggFather.fix.sol';\nimport {SafeCast} from '../fixtures/NuggFather.fix.sol';\n\ncontract systemTest__one is NuggFatherFix {\n    using SafeCast for uint96;\n\n    // function setUp() public {\n    //     reset();\n    // }\n\n    // function test__system1() public {\n    //     address[] memory users = environmentForge2();\n    //     emit log_named_uint('users length', users.length);\n\n    //     emit log_named_uint('nuggft.totalEthPerShare()', nuggft.totalEthPerShare());\n    //     emit log_named_uint('nuggft.totalProtocolEth()', nuggft.totalProtocolEth());\n    //     emit log_named_uint('nuggft.totalStakedEth()', nuggft.totalStakedEth());\n    //     emit log_named_uint('nuggft.totalStakedShares()', nuggft.totalStakedShares());\n    //     emit log_named_uint('nuggft.minSharePrice()', nuggft.minSharePrice());\n\n    //     // assert(false);\n    // }\n}\n// 918280174020444\n/// simulated epoch\n\n/// full migration\n\n/// everyone loans\n\n/// everyone burns\n\n/// everyone liquidates\n\n///\n\n// Success: test__system1()\n\n//   users length: 2000\n//   nuggft.totalEthPerShare(): 0.016383373055966815\n//   nuggft.totalProtocolEth():  7.392450086659235424\n//   nuggft.totalStakedEth():   98.300238335800890640\n//   nuggft.totalStakedShares(): 6000\n\n// Success: test__system1()\n\n//   users length: 2000\n//   nuggft.totalEthPerShare():  .029822095207758643\n//   nuggft.totalProtocolEth(): 10.420998798111959771\n//   nuggft.totalStakedEth(): 178.932571246551862590\n//   nuggft.totalStakedShares(): 6000\n"
    },
    "src/_test/reverts/version.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {DSTestPlus as t} from '../utils/DSTestPlus.sol';\n\nimport {NuggFatherFix} from '../fixtures/NuggFather.fix.sol';\n\ncontract revertTest__version is t, NuggFatherFix {\n    function setUp() public {\n        reset();\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n            [T:1] - addStakedShareFromMsgValue - \"value of tx too low\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n}\n"
    },
    "src/_test/fixtures/NuggFather.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {DSTestPlus as t} from '../utils/DSTestPlus.sol';\n\nimport {NuggFatherFix} from '../fixtures/NuggFather.fix.sol';\n\ncontract fixtureTest__NuggFatherFix is t, NuggFatherFix {\n    function setUp() public {\n        reset();\n    }\n}\n"
    },
    "src/_test/general/Version.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {NuggFatherFix} from '../fixtures/NuggFather.fix.sol';\n\nimport {UserTarget} from '../utils/User.sol';\n\nimport {DotnuggV1Lib} from '../../DotnuggV1Lib.sol';\nimport {BigMatrix0} from '../objects/BigMatrix0.sol';\n\ncontract VersionTest is NuggFatherFix {\n    using UserTarget for address;\n\n    BigMatrix0 _bigmatrix0;\n\n    uint256[][] dummy2D;\n    uint256[] dummy1D;\n\n    uint256[] dummy1Dcompressed;\n\n    function setUp() public {\n        reset();\n\n        _bigmatrix0 = new BigMatrix0();\n\n        dummy1D = _bigmatrix0.get();\n\n        dummy1Dcompressed = processor.lib().compressBigMatrix(dummy1D, 0);\n\n        emit log_named_bytes32('compreseed last', bytes32(dummy1Dcompressed[dummy1Dcompressed.length - 1]));\n\n        dummy2D.push(dummy1D);\n        dummy2D.push(dummy1D);\n        dummy2D.push(dummy1D);\n    }\n\n    // function test__DotnuggV2Processor__dotnuggV1StoreFiles__pass() public {\n    //     _implementer.shouldPass(frank, dotnuggV1StoreFiles(dummy2D, 0));\n    // }\n\n    function test__Version__compressBigMatrix__pass() public {\n        uint256 data = 0;\n        uint256[] memory compressed = processor.lib().compressBigMatrix(dummy1D, data);\n        uint256[] memory decompressed = processor.lib().decompressBigMatrix(compressed);\n\n        dummy1D.push(data | ((dummy1D.length + 1) << 236));\n\n        assertArrayEq(decompressed, dummy1D);\n    }\n}\n"
    },
    "src/_test/objects/BigMatrix0.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ncontract BigMatrix0 {\n    uint256[] public rows;\n\n    uint256 public data = 0x29800000000000000000000000000000000000000007ff8000000000000000;\n    uint256 public beforeData = 0x00000000000000000000000000000000000000000007ff8000000000000000;\n\n    function get() external view returns (uint256[] memory) {\n        return rows;\n    }\n\n    function getDecompressed() external returns (uint256[] memory res) {\n        uint256[] memory tmp = rows;\n\n        rows.push(data);\n\n        res = rows;\n\n        rows = tmp;\n    }\n\n    constructor() payable {\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x09a125e362fe684978d8bf000000000000000000000000000000000000000000);\n        rows.push(0x09a125e362fe684978d8bf9a125e362fe684978d8bf9a125e362fe684978d8bf);\n        rows.push(0x09a125e362fe684978d8bf9a125e362fe684978d8bf9a125e362fe684978d8bf);\n        rows.push(0x02684978d8bf);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x09a125e362fe684978d8bf9a125e362fe684978d8bf9a125e362fc0000000000);\n        rows.push(0x09a125e362fe684978d8bf9a125e362fe684978d8bf9a125e362fe684978d8bf);\n        rows.push(0x9a125e362fe684978d8bf9a125e362fe684978d8bf);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x09a125e362fe684978d8bf000000000000000000000000000000000000000000);\n        rows.push(0x09a125e362fe684978d8bf9a125e362fe684978d8bf9a125e362fe684978d8bf);\n        rows.push(0x09a125e362fe684978d8bf9a125e362fe684978d8bf9a125e362fe684978d8bf);\n        rows.push(0x02684978d8bf);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x09a125e362fe684978d8bf9a125e362fe684978d8bf9a125e362fc0000000000);\n        rows.push(0x09a125e362fe684978d8bf9a125e362fe684978d8bf9a125e362fe684978d8bf);\n        rows.push(0x9a125e362fe684978d8bf9a125e362fe684978d8bf);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x09a125e362fe684978d8bf000000000000000000000000000000000000000000);\n        rows.push(0x09a125e362fe684978d8bf9a125e362fe684978d8bf9a125e362fe684978d8bf);\n        rows.push(0x09a125e362fe684978d8bf9a125e362fe684978d8bf9a125e362fe684978d8bf);\n        rows.push(0x02684978d8bf);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x09a125e362fe684978d8bf9a125e362fe684978d8bf9a125e362fc0000000000);\n        rows.push(0x09a125e362fe684978d8bf9a125e362fe684978d8bf9a125e362fe684978d8bf);\n        rows.push(0x9a125e362fe684978d8bf9a125e362fe684978d8bf);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x09a125e362fe684978d8bf000000000000000000000000000000000000000000);\n        rows.push(0x09a125e362fe684978d8bf9a125e362fe684978d8bf9a125e362fe684978d8bf);\n        rows.push(0x09a125e362fe684978d8bf9a125e362fe684978d8bf9a125e362fe684978d8bf);\n        rows.push(0x02684978d8bf);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x09a125e362fe684978d8bf9a125e362fc0000000000000000000000000000000);\n        rows.push(0x09a125e362fe684978d8bf9a125e362fe684978d8bf9a125e362fe684978d8bf);\n        rows.push(0x09a125e362fe684978d8bf9a125e362fe684978d8bf9a125e362fe684978d8bf);\n        rows.push(0x09a125e362fe684978d8bf9a125e362fe684978d8bf9a125e362fe684978d8bf);\n        rows.push(0x09a125e362fe684978d8bf);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x09a125e362fe684978d8bf9a125e362fe684978d8bf9a125e362fe684978d8bf);\n        rows.push(0x09a125e362fe684978d8bf9a125e362fe684978d8bf9a125e362fe684978d8bf);\n        rows.push(0x09a125e362fe684978d8bf9a125e362fe684978d8bf9a125e362fe684978d8bf);\n        rows.push(0x02684978d8bf9a125e362fe684978d8bf9a125e362fe684978d8bf);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x09a125e362fe684978d8bf9a125e362fc0000000000000000000000000000000);\n        rows.push(0x09a125e362fe684978d8bf9a125e362fe684978d8bf9a125e362fe684978d8bf);\n        rows.push(0x09a125e362fe684978d8bf9a125e362fe684978d8bf9a125e362fe684978d8bf);\n        rows.push(0x09a125e362fe684978d8bf9a125e362fe684978d8bf9a125e362fe684978d8bf);\n        rows.push(0x09a125e362fe684978d8bf);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x07807f9e02dde01fe780b77807f9e02dc0000000000000000000000000000000);\n        rows.push(0x07807f9e02dde01fe780b77807f9e02dde01fe780b77807f9e02dde01fe780b7);\n        rows.push(0x07807f9e02dde01fe780b77807f9e02dde01fe780b77807f9e02dde01fe780b7);\n        rows.push(0x07807f9e02dde01fe780b7);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x07807f9e02dc0000000000000000000000000000000000000000000000000000);\n        rows.push(0x07807f9e02dde01fe780b77807f9e02dde01fe780b77807f9e02dde01fe780b7);\n        rows.push(0x07807f9e02dde01fe780b77807f9e02dde01fe780b77807f9e02dde01fe780b7);\n        rows.push(0x07807f9e02dde01fe780b77807f9e02dde01fe780b77807fff92dde01fffe4b7);\n        rows.push(0x01e01fe780b7);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x07807f9e02dde01fe780b77807f9e02dde01fe780b7000000000000000000000);\n        rows.push(0x07807f9e02dde01fe780b77807f9e02dde01fe780b77807f9e02dde01fe780b7);\n        rows.push(0x07807f9e02dde01fe780b77807f9e02dde01fffe4b77807f9e02dde01fe780b7);\n        rows.push(0x7807f9e02dde01fe780b77807f9e02dde01fe780b7);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x07807f9e02dc0000000000000000000000000000000000000000000000000000);\n        rows.push(0x07807f9e02dde01fe780b77807f9e02dde01fe780b77807f9e02dde01fe780b7);\n        rows.push(0x07807fff92dde01fe780b77807f9e02dde01fe780b77807f9e02dde01fe780b7);\n        rows.push(0x07807f9e02dde01fe780b77807f9e02dde01fffe4b77807f9e02dde01fe780b7);\n        rows.push(0x07807f9e02dde01fe780b7);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x07807f9e02dde01fe780b77807f9e02dde01fffe4b7000000000000000000000);\n        rows.push(0x07807f9e02dde01fe780b77807f9e02dde01fe780b77807f9e02dde01fe780b7);\n        rows.push(0x07807f9e02dde01fffe4b77807f9e02dde01fffe4b77807f9e02dde01fe780b7);\n        rows.push(0x01e01fe780b77807f9e02dde01fffe4b77807f9e02dde01fe780b7);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x07807fff92dde01fe780b7000000000000000000000000000000000000000000);\n        rows.push(0x07807f9e02dde01fe780b77807f9e02dde01fe780b77807f39e85de01fe780b7);\n        rows.push(0x07807f9e02dde01fe780b71203f36085de01fe780b71203e93e6bc480d4258f7);\n        rows.push(0x07807fff92dde01fe780b77807f9e02dc480d4258f77807fff92dde01fe780b7);\n        rows.push(0x07807f9e02dde01fe780b7);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x07807f9e02dde01fe780b77807f9e02dde01fe780b77807f9e02dc0000000000);\n        rows.push(0x01203e93e6bc480fa4f9af1203f36085c480fcd82177807f9e02dcd0c8000007);\n        rows.push(0x03432000001cd0c80000071203f36085c480f8c992f1203f36085c480fa4f9af);\n        rows.push(0x01e01fffe4b77807f9e02dde01fffe4b77807f9e02dcd0c8000007);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x07807f9e02dde01fe780b7000000000000000000000000000000000000000000);\n        rows.push(0x03432000001cd0cfffffff3432000001de01fce7a177807f9e02dde01fe780b7);\n        rows.push(0x01203e93e6bc480fa4f9af1203f36085c480fa4f9af1203f36085cd0c8000007);\n        rows.push(0x07807f9e02dde01fe780b73432000001cd0cfffffff3432000001cd0c8000007);\n        rows.push(0x07807fff92dde01fe780b7);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x07807f39e85de01fe780b77807f9e02dde01fe780b77807f9e02dc0000000000);\n        rows.push(0x01203f36085cd0c80000073432000001cd0cfffffff3433ffffffcd0c8000007);\n        rows.push(0x03433ffffffcd0cfffffff3432000001c480fcd82171203f36085c480fa4f9af);\n        rows.push(0x01e01fffe4b77807f9e02dde01fe780b71203e3264bcd0c8000007);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x07807f9e02dde01fe780b7000000000000000000000000000000000000000000);\n        rows.push(0x03433ffffffcd0cfffffff3432000001c480d4258f77807f9e02dde01fe780b7);\n        rows.push(0x03432000001c480fcd82171203f36085cd0c80000073432000001cd0cfffffff);\n        rows.push(0x07807f9e02dc480fcd82173432000001cd0cfffffff3433ffffffcd0cfffffff);\n        rows.push(0x07807fff92dde01fe780b7);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x07807f9e02dde01fffe4b77807f9e02dde01fffe4b77807f9e02dc0000000000);\n        rows.push(0x03432000001cd0cfffffff3433ffffffcd0c80000073432000001cd0c8000007);\n        rows.push(0x03433ffffffcd0c80000073432000001cd0c80000071203f36085c480fcd8217);\n        rows.push(0x01e01fffe4b77807f9e02dc480fcd82171203e3264bcd0c8000007);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x07807f9e02dde01fe780b7000000000000000000000000000000000000000000);\n        rows.push(0x03432000001cd0c80000073432000001de01fe780b77807f9e02dde01fce7a17);\n        rows.push(0x03432000001c480fcd82171203f36085cd0c80000073432000001cd0c8000007);\n        rows.push(0x01203f36085c480fcd82173432000001cd0c80000073432000001cd0c8000007);\n        rows.push(0x2c03178d8bf7807fff92dde01fe780b7);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x07807f9e02dde01fffe4b77807f9e02dde01fe780b77807fff92dc0000000000);\n        rows.push(0x01203f36085c480fcd82171203f36085c480fcd82171203f36085c480f8c992f);\n        rows.push(0x01203f36085c480fcd82171203f36085c480fcd82171203f36085c480fcd8217);\n        rows.push(0x0b00c5e362fde01fffe4b77807f9e02dde01fffe4b71203f36085c480fcd8217);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x07807fff92dde01fffe4b7000000000000000000000000000000000000000000);\n        rows.push(0x01203f36085c480fcd82171203f36085de01fffe4b77807f9e02dde01fe780b7);\n        rows.push(0x01203f36085c480fcd82171203f36085c480fcd82171203f36085c480fcd8217);\n        rows.push(0x07807f39e85c480fcd82171203f36085c480fcd82171203f36085c480fcd8217);\n        rows.push(0x2c03178d8bf7807fff92dde01fce7a17);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x07807f9e02dde01fe780b77807fff92dde01fffe4b7000000000000000000000);\n        rows.push(0x01203f36085c480fcd82171203f36085c480fcd82171203f36085c480fcd8217);\n        rows.push(0x01203f36085c480fcd82171203f36085c480fcd82171203f36085c480fcd8217);\n        rows.push(0x0b00c5e362fde01fffe4b77807fff92dde01fce7a177807fff92dc480fcd8217);\n        rows.push(0x02c03178d8bf);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x01203f36085c480fcd82171203f36085de01fce7a177807fff92dde01fffe4b7);\n        rows.push(0x01203f36085c480fcd82171203f36085c480fcd82171203f36085c480fcd8217);\n        rows.push(0x07807f9e02dc480fcd82171203f36085c480fcd82171203f36085c480fcd8217);\n        rows.push(0x02c03178d8bfb00c5e362fec03178d8bf12031eac77de01fce7a17);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x07807f9e02dde01fffe4b7000000000000000000000000000000000000000000);\n        rows.push(0x01203f36085c480fcd82171203f36085c480fcd82171203f36085c480f8c992f);\n        rows.push(0x01203f36085c480fcd82171203f36085c480fcd82171203f36085c480fcd8217);\n        rows.push(0x0b00c5e362fc480c7ab1df7807f39e85de01fce7a171203f36085c480fcd8217);\n        rows.push(0x0b00c5e362fec03178d8bf);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x01203f36085c480f8c992f7807f39e85de01fce7a177807f9e02dc0000000000);\n        rows.push(0x0540ddd7d9dd503775f677540ddd7d9dc480fcd82171203f36085c480fcd8217);\n        rows.push(0x07807f39e85de01fce7a171203f36085c480fcd82171203f36085c480fcd8217);\n        rows.push(0x02c03178d8bfb00c5e362fec03178d8bf120358ca4dc480d4258f7);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x07807f9e02dc0000000000000000000000000000000000000000000000000000);\n        rows.push(0x0540ddd7d9dc480fcd82171203f36085c480f8c992f1203f36085de01fce7a17);\n        rows.push(0x01203f36085c480fcd8217540ddd7d9dd5035496ab7540d525aadd5035496ab7);\n        rows.push(0x0b00c5e362fec03178d8bf120358ca4dc480d6329371203f36085c480fcd8217);\n        rows.push(0x0b00c5e362fec03178d8bf);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x01203f36085c480f8c992f7807f39e85de01fe780b7000000000000000000000);\n        rows.push(0x01203f36085d503775f6771203f36085c480fcd82171203f36085c480fcd8217);\n        rows.push(0x01203b8fca2c480fcd82171203f36085c480fcd82171203f36085c480fcd8217);\n        rows.push(0x02c03178d8bfb00c5e362fec03178d8bfb00c5e362fc480d4258f7);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x07807f9e02dc0000000000000000000000000000000000000000000000000000);\n        rows.push(0x01203e3264bc480fcd82171203f36085c480f761cd77807f39e85de01fce7a17);\n        rows.push(0x01203f36085c480fcd82171203e93e6bc480f8c992f1203f36085c480fcd8217);\n        rows.push(0x0b00c5e362fec03178d8bf120358ca4dc480c7ab1df120350963dc480ee3f28b);\n        rows.push(0x0b00c5e362fec03178d8bf);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x01203e3264bc480ee3f28b120350963dec03178d8bf000000000000000000000);\n        rows.push(0x01203f36085c480f8c992f1203e93e6bc480fcd82171203f36085c480f8c992f);\n        rows.push(0x012031eac77c480d6329371203e3264bc480fcd82171203e3264bc480f5c5097);\n        rows.push(0x02c03178d8bfb00c5e362fec03178d8bfb00c5e362fec03178d8bf);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x01203f36085c480f8c992f1203f36085c480ee3f28b120358ca4dc480fcd8217);\n        rows.push(0x01203e3264bc480f5c50971203f36085c480fa4f9af1203e93e6bc480fcd8217);\n        rows.push(0x0b00c5e362fec03178d8bfb00c5e362fec03178d8bf120358ca4dc480fcd8217);\n        rows.push(0x0b00c5e362fec03178d8bf);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x01203b8fca2c480fcd8217b00c5e362fc0000000000000000000000000000000);\n        rows.push(0x01203e3264bc480fa4f9af1203e93e6bc480fcd82171203f36085c480f5c5097);\n        rows.push(0x0b00c5e362fc480d6329371203d71425c480d4258f71203d71425c480fcd8217);\n        rows.push(0xb00c5e362fec03178d8bfb00c5e362fec03178d8bf);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x01203f36085c480d6329371203d71425c480d4258f7b00c5e362fec03178d8bf);\n        rows.push(0x0120358ca4dc480d6329371203d71425c480f5c50971203f36085c480fa4f9af);\n        rows.push(0x0b00c5e362fec03178d8bfb00c5e362fec03178d8bfb00c5e362fc480d4258f7);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x0b00c5e362fec03178d8bf000000000000000000000000000000000000000000);\n        rows.push(0x0120350963dc480d632937120350963dc480d632937120350963dc480d4258f7);\n        rows.push(0x0b00c5e362fec03178d8bfb00c5e362fc480d4258f7120350963dc480d4258f7);\n        rows.push(0x2c03178d8bfb00c5e362fec03178d8bf);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x0b00c5e362fec03178d8bfb00c5e362fec03178d8bfb00c5e362fc0000000000);\n        rows.push(0x02c03178d8bf);\n        rows.push(0x0b00c5e362fec03178d8bfb00c5e362fec03178d8bfb00c5e362fc0000000000);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x0b00c5e362fc0000000000000000000000000000000000000000000000000000);\n        rows.push(0xb00c5e362fec03178d8bfb00c5e362fec03178d8bf);\n        rows.push(0x0b00c5e362fec03178d8bf000000000000000000000000000000000000000000);\n        rows.push(0x2c03178d8bfb00c5e362fec03178d8bf);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x0b00c5e362fec03178d8bfb00c5e362fec03178d8bf000000000000000000000);\n        rows.push(0x0b00c5e362fec03178d8bf);\n        rows.push(0x02c03178d8bfb00c5e362fec03178d8bfb00c5e362fec03178d8bf);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x0b00c5e362fec03178d8bfb00c5e362fec03178d8bfb00c5e362fec03178d8bf);\n        rows.push(0x0b00c5e362fec03178d8bfb00c5e362fec03178d8bfb00c5e362fec03178d8bf);\n        rows.push(0x0b00c5e362fec03178d8bf);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x0b00c5e362fec03178d8bfb00c5e362fc0000000000000000000000000000000);\n        rows.push(0x0b00c5e362fec03178d8bfb00c5e362fec03178d8bfb00c5e362fec03178d8bf);\n        rows.push(0xb00c5e362fec03178d8bfb00c5e362fec03178d8bf);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x0b00c5e362fec03178d8bfb00c5e362fec03178d8bfb00c5e362fec03178d8bf);\n        rows.push(0x0b00c5e362fec03178d8bfb00c5e362fec03178d8bfb00c5e362fec03178d8bf);\n        rows.push(0x0b00c5e362fec03178d8bf);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x0b00c5e362fec03178d8bfb00c5e362fc0000000000000000000000000000000);\n        rows.push(0x0b00c5e362fec03178d8bfb00c5e362fec03178d8bfb00c5e362fec03178d8bf);\n        rows.push(0x02c03178d8bfb00c5e362fec03178d8bfb00c5e362fec03178d8bf);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x0b00c5e362fec03178d8bfb00c5e362fec03178d8bfb00c5e362fec03178d8bf);\n        rows.push(0x0b00c5e362fec03178d8bfb00c5e362fec03178d8bfb00c5e362fec03178d8bf);\n        rows.push(0x2c03178d8bfb00c5e362fec03178d8bf);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x0b00c5e362fec03178d8bfb00c5e362fec03178d8bf000000000000000000000);\n        rows.push(0x02c03178d8bf);\n        rows.push(0x0b00c5e362fec03178d8bfb00c5e362fec03178d8bf000000000000000000000);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n        rows.push(0x00);\n    }\n}\n"
    },
    "src/_test/general/Resolver.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {NuggFatherFix} from '../fixtures/NuggFather.fix.sol';\nimport {IDotnuggV1Data} from '../../interfaces/IDotnuggV1Data.sol';\n\nimport {UserTarget} from '../utils/User.sol';\n\nimport {DotnuggV1Lib} from '../../DotnuggV1Lib.sol';\nimport {BigMatrix0} from '../objects/BigMatrix0.sol';\n\ncontract ResolverTest is NuggFatherFix {\n    using UserTarget for address;\n\n    BigMatrix0 _bigmatrix0;\n\n    uint256[][] dummy2D;\n    uint256[] dummy1D;\n\n    uint256[] dummy1Dcompressed;\n\n    IDotnuggV1Data.Data testData;\n\n    function setUp() public {\n        reset();\n\n        _bigmatrix0 = new BigMatrix0();\n\n        dummy1D = _bigmatrix0.get();\n\n        dummy1Dcompressed = processor.lib().compressBigMatrix(dummy1D, _bigmatrix0.beforeData());\n\n        testData.name = 'name';\n        testData.desc = 'desc';\n        testData.version = 1;\n        testData.tokenId = 0;\n        testData.proof = 0;\n        testData.owner = address(0);\n    }\n\n    // function test__DotnuggV2Processor__dotnuggV1StoreFiles__pass() public {\n    //     _implementer.shouldPass(frank, dotnuggV1StoreFiles(dummy2D, 0));\n    // }\n\n    function test__Resolver__resolvString__pass() public {\n        string memory res = processor.resolveString(dummy1Dcompressed, testData, 10);\n\n        emit log_named_string('svg', res);\n\n        // assert(false);\n    }\n}\n"
    },
    "src/_test/reverts/calculator.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {NuggFatherFix} from '../fixtures/NuggFather.fix.sol';\n\ncontract revertTest__calculator is NuggFatherFix {\n    function setUp() public {\n        reset();\n    }\n}\n"
    },
    "src/_test/reverts/anchors.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {NuggFatherFix} from '../fixtures/NuggFather.fix.sol';\nimport {SafeCast} from '../fixtures/NuggFather.fix.sol';\n\ncontract revertTest__anchors is NuggFatherFix {\n    using SafeCast for uint96;\n\n    function setUp() public {\n        reset();\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}