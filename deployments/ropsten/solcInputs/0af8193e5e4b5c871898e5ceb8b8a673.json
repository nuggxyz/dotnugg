{
  "language": "Solidity",
  "sources": {
    "contracts/mock/DotNuggHolder/DotNuggLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport './ItemLib.sol';\nimport '../../src/libraries/ShiftLib.sol';\nimport '../types/ItemType.sol';\nimport '../types/LengthType.sol';\n// import '../../test/Console.sol';\nimport '../../src/interfaces/IResolver.sol';\n\nlibrary DotNuggLib {\n    using ItemType for uint256;\n    using LengthType for uint256;\n    using Event for uint256;\n    using Event for uint256[];\n\n    struct Storage {\n        uint256[] collection;\n        mapping(uint256 => mapping(uint256 => mapping(uint256 => uint256))) items;\n        uint256 lengths;\n        mapping(uint256 => address) resolvers;\n    }\n\n    // function generateTokenURIDefaultResolver(\n    //     Storage storage s,\n    //     ItemLib.Storage storage item_storage,\n    //     address dotnugg,\n    //     uint256 tokenId,\n    //     address defaultResolver\n    // ) internal view returns (string memory) {\n    //     address res = s.resolvers[tokenId];\n    //     if (res != address(0)) defaultResolver = res;\n    //     return generateTokenURI(s, item_storage, dotnugg, tokenId, defaultResolver);\n    // }\n\n    function addItems(Storage storage s, uint256[][] calldata data) internal {\n        uint256 lengths = s.lengths;\n\n        for (uint256 i = 0; i < data.length; i++) {\n            uint256 itemType = (data[i][data[i].length - 1] >> 32) & 0x7;\n\n            itemType.log('itemType');\n\n            uint256 len = lengths.length(itemType);\n\n            for (uint256 j = 0; j < data[i].length; j++) {\n                s.items[itemType][len][j] = data[i][j];\n            }\n            len++;\n\n            lengths = lengths.length(itemType, len);\n        }\n        s.lengths = lengths;\n    }\n\n    /**\n     * @notice calcualtes the token uri for a given epoch\n     */\n    function getData(\n        Storage storage s,\n        ItemLib.Storage storage item_storage,\n        uint256 tokenId\n    ) internal view returns (uint256[][] memory res, uint256 itemData) {\n        itemData = item_storage.tokenData[tokenId];\n\n        res = new uint256[][](5);\n\n        res[0] = loadItem(s, 0, itemData.base());\n        res[1] = loadItem(s, 1, itemData.item(1, 0));\n        res[2] = loadItem(s, 2, itemData.item(2, 0));\n        res[3] = loadItem(s, 3, itemData.item(3, 0));\n        res[4] = loadItem(s, 4, itemData.item(4, 0));\n\n        // data[3] = loadItem(s, 3, item_memory.item(ItemType.Index.MOUTH, 0));\n        // data[4] = loadItem(s, 4, item_memory.item(ItemType.Index.OTHER, 0));\n        // data[5] = loadItem(s, 5, item_memory.item(ItemType.Index.SPECIAL, 0));\n        // IDotNugg(dotnugg).nuggify(33, data, resolver, uriname, descrription, tokenId, '');\n        // string memory uriname = 'NuggFT {#}';\n        // string memory descrription = 'the description';\n    }\n\n    function loadItem(\n        Storage storage s,\n        uint8 itemType,\n        uint256 id\n    ) internal view returns (uint256[] memory data) {\n        data = new uint256[](15);\n\n        uint256 i;\n        uint256 tmp;\n\n        for (i = 0; (tmp = s.items[itemType][id][i]) != 0; i++) {\n            data[i + 1] = tmp;\n        }\n\n        data[0] = i;\n\n        data.log('data');\n    }\n}\n"
    },
    "contracts/mock/DotNuggHolder/ItemLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../types/ItemType.sol';\nimport '../types/LengthType.sol';\n\nimport '../types/OldShiftType.sol';\n\nimport '../../src/libraries/ShiftLib.sol';\nimport './DotNuggLib.sol';\n\nlibrary ItemLib {\n    using ItemType for uint256;\n    using LengthType for uint256;\n\n    using ShiftLib for uint256;\n    using OldShiftType for uint256;\n\n    struct Storage {\n        mapping(uint256 => uint256) tokenData;\n        mapping(uint256 => uint256) protocolItems;\n    }\n\n    event PreMint(uint256 tokenId, uint256[] items);\n    event PopItem(uint256 tokenId, uint256 itemId);\n    event PushItem(uint256 tokenId, uint256 itemId);\n    event OpenSlot(uint256 tokenId);\n\n    function mint(\n        Storage storage s,\n        DotNuggLib.Storage storage dns,\n        uint256 tokenId,\n        uint256 data\n    ) internal returns (uint256[] memory items) {\n        require(s.tokenData[tokenId] == 0, 'IL:M:0');\n\n        uint256 lendata = dns.lengths;\n\n\n\n\n\n        data = data.size(0x0);\n        data = OldShiftType.base(data, OldShiftType.base(data) % lendata.length(0));\n        data = data.item(1, 0, data.item1() % lendata.length(1));\n\n        data = data.item(2, 0, data.item(2) % lendata.length(2));\n        data = data.item(3, 0, data.item(3) % lendata.length(3));\n\n        data = data.item(4, 0, data.item(4) % lendata.length(4));\n        // data = data.item(5, 0, data.item(5) % lendata.length(5));\n\n        // .item4(data.item4() % lendata.item4());\n\n        s.tokenData[tokenId] = data;\n\n        return data.items();\n    }\n\n    function pop(\n        Storage storage s,\n        uint256 tokenId,\n        uint256 itemId\n    ) internal {\n        uint256 data = s.tokenData[tokenId];\n\n        require(data != 0, '1155:STF:0');\n\n        (data, , ) = data.popFirstMatch(uint16(itemId));\n\n        s.tokenData[tokenId] = data;\n\n        s.protocolItems[itemId]++;\n\n        emit PushItem(tokenId, itemId);\n    }\n\n    function push(\n        Storage storage s,\n        uint256 tokenId,\n        uint256 itemId\n    ) internal {\n        uint256 data = s.tokenData[tokenId];\n        require(data != 0, '1155:STF:0');\n\n        require(s.protocolItems[itemId] > 0, '1155:SBTF:1');\n\n        s.protocolItems[itemId]++;\n\n        (data, ) = data.pushFirstEmpty(uint16(itemId));\n\n        s.tokenData[tokenId] = data;\n\n        emit PushItem(tokenId, itemId);\n    }\n\n    function open(Storage storage s, uint256 tokenId) internal {\n        uint256 data = s.tokenData[tokenId];\n        require(data != 0, '1155:STF:0');\n\n        data = data.size(OldShiftType.size(data) + 1);\n\n        s.tokenData[tokenId] = data;\n\n        emit OpenSlot(tokenId);\n    }\n\n    function infoOf(Storage storage s, uint256 tokenId)\n        internal\n        view\n        returns (\n            uint256 base,\n            uint256 size,\n            uint256[] memory items\n        )\n    {\n        uint256 data = s.tokenData[tokenId];\n        items = data.items();\n        size = OldShiftType.size(data);\n        base = OldShiftType.base(data);\n    }\n\n    // 1/2 byte - size ---- 0-15\n    // 1/2 bytes - base -----  0-15\n    // 1/2 byte - traits 0-3\n    // 1/2 byte - traits 4-7 --- 2\n\n    // 1.5 bytes - head\n    // 1.5 bytes - eyes\n    // 1.5 bytes - mouth\n    // 1.5 bytes - other\n    // 1.5 bytes - other2 ---- 7.5  9.5\n\n    // 1.5 bytes - head\n    // 1.5 bytes - eyes\n    // 1.5 bytes - mouth\n    // 1.5 bytes - other\n    // 1.5 bytes - other2 ---- 7.5  17\n\n    // 1.5 bytes - head\n    // 1.5 bytes - eyes\n    // 1.5 bytes - mouth\n    // 1.5 bytes - other\n    // 1.5 bytes - other2 ---- 7.5  24.5\n\n    // 1.5 bytes - head\n    // 1.5 bytes - eyes\n    // 1.5 bytes - mouth\n    // 1.5 bytes - other\n    // 1.5 bytes - other2 ---- 7.5  32\n}\n"
    },
    "contracts/src/libraries/ShiftLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../../test/Event.sol';\n\nlibrary ShiftLib {\n    using Event for uint256;\n\n    function reverse(uint256 input) internal pure returns (uint256 v) {\n        v = input;\n\n        // v =\n        //     ((v & 0xF0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0) >> 4) |\n        //     ((v & 0x0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F) << 4);\n\n        // swap bytes\n        v =\n            ((v & 0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00) >> 8) |\n            ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\n\n        // swap 2-byte long pairs\n        v =\n            ((v & 0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >> 16) |\n            ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\n\n        // swap 4-byte long pairs\n        v =\n            ((v & 0xFFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000) >> 32) |\n            ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\n\n        // swap 8-byte long pairs\n        v =\n            ((v & 0xFFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >> 64) |\n            ((v & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) << 64);\n\n        // swap 16-byte long pairs\n        v = (v >> 128) | (v << 128);\n    }\n\n    function rbit(\n        uint256[] memory input,\n        uint256 b,\n        uint256 pos\n    ) internal pure returns (uint256 res) {\n        require(pos <= input.length * 256, 'SL:B4:0');\n        res = rbit(input[pos / 256], b, pos % 256);\n    }\n\n    function rbit(\n        uint256 input,\n        uint256 b,\n        uint256 pos\n    ) internal pure returns (uint256 res) {\n        input = reverse(input);\n        require(pos <= 0xff, 'SL:B4:0');\n        uint256 _mask = mask(b);\n        assembly {\n            res := and(shr(pos, input), _mask)\n        }\n    }\n\n    function rbit1(uint256[] memory input, uint256 pos) internal pure returns (bool res) {\n        require(pos <= input.length * 256, 'SL:B4:0');\n        res = rbit1(input[pos / 256], pos % 256);\n    }\n\n    function rbit1(uint256 input, uint256 pos) internal pure returns (bool res) {\n        require(pos <= 0xff, 'SL:B4:0');\n        input = reverse(input);\n\n        assembly {\n            res := and(shr(pos, input), 0x3)\n        }\n    }\n\n    function bit(\n        uint256[] memory input,\n        uint256 b,\n        uint256 pos\n    ) internal pure returns (uint256 res) {\n        require(pos <= input.length * 256, 'SL:B4:0');\n        res = bit(input[pos / 256], b, pos % 256);\n    }\n\n    function bit1(uint256[] memory input, uint256 pos) internal pure returns (bool res) {\n        require(pos <= input.length * 256, 'SL:B4:0');\n        res = bit1(input[pos / 256], pos % 256);\n    }\n\n    function bit(\n        uint256[] memory input,\n        uint256 b,\n        uint256 pos,\n        uint256 update\n    ) internal pure returns (uint256 res) {\n        res = bit(input[pos / 256], b, pos % 256, update);\n    }\n\n    function bit1(\n        uint256[] memory input,\n        uint256 pos,\n        bool update\n    ) internal pure returns (uint256 res) {\n        res = bit1(input[pos / 256], pos % 256, update);\n    }\n\n    function submask(uint256 bits, uint256 offset) internal pure returns (uint256 res) {\n        assembly {\n            res := shl(not(sub(exp(2, bits), 1)), offset)\n        }\n    }\n\n    function fullsubmask(uint256 bits, uint256 offset) internal pure returns (uint256 res) {\n        res = ~(mask(bits) << offset);\n    }\n\n    function mask(uint256 bits) internal pure returns (uint256 res) {\n        assembly {\n            res := sub(exp(2, bits), 1)\n        }\n    }\n\n    function bit(\n        uint256 input,\n        uint256 b,\n        uint256 pos\n    ) internal pure returns (uint256 res) {\n        require(pos <= 0xff, 'SL:B4:0');\n        uint256 _mask = mask(b);\n\n        assembly {\n            res := and(shr(pos, input), _mask)\n        }\n    }\n\n    function bit(\n        uint256 input,\n        uint256 b,\n        uint256 pos,\n        uint256 update\n    ) internal pure returns (uint256 res) {\n        uint256 offset;\n        uint256 _mask = mask(b);\n\n        assembly {\n            offset := _mask\n        }\n\n        assembly {\n            if gt(update, offset) {\n                revert(0, 0)\n            }\n            if gt(pos, 0xff) {\n                revert(0, 0)\n            }\n            input := and(not(shl(pos, _mask)), input)\n            res := or(input, shl(pos, update))\n        }\n    }\n\n    function bit1(uint256 input, uint256 pos) internal pure returns (bool res) {\n        require(pos <= 0xff, 'SL:B4:0');\n        assembly {\n            res := and(shr(pos, input), 0x3)\n        }\n    }\n\n    function bit1(\n        uint256 input,\n        uint256 pos,\n        bool update\n    ) internal pure returns (uint256 res) {\n        require(pos <= 0xff, 'SL:B4:0');\n        uint256 tu = update ? 0x1 : 0x0;\n        assembly {\n            input := and(not(shl(pos, 0x3)), input)\n            res := or(input, shl(pos, tu))\n        }\n    }\n\n    // function bit3(uint256 input, uint256 pos) internal pure  returns (uint256 res) {\n    //     require(pos <= 0xff, 'SL:B4:0');\n\n    //     assembly {\n    //         res := and(shr(pos, input), 0xb)\n    //     }\n    // }\n\n    // function bit4(uint256 input, uint256 pos) internal pure  returns (uint256 res) {\n    //     require(pos <= 0xff, 'SL:B4:0');\n\n    //     assembly {\n    //         res := and(shr(pos, input), 0xf)\n    //     }\n    // }\n\n    // function bit6(uint256 input, uint256 pos) internal pure  returns (uint256 res) {\n    //     require(pos <= 0xff, 'SL:B4:0');\n\n    //     assembly {\n    //         res := and(shr(pos, input), 0x3f)\n    //     }\n    // }\n\n    // function bit8(uint256 input, uint256 pos) internal pure  returns (uint256 res) {\n    //     require(pos <= 0xff, 'SL:B4:0');\n\n    //     assembly {\n    //         res := and(shr(pos, input), 0xff)\n    //     }\n    // }\n\n    // function bit12(uint256 input, uint256 pos) internal pure  returns (uint16 res) {\n    //     require(pos <= 0xff, 'SL:B4:0');\n\n    //     assembly {\n    //         res := and(shr(pos, input), 0xfff)\n    //     }\n    // }\n\n    // function bit16(uint256 input, uint256 pos) internal pure  returns (uint16 res) {\n    //     require(pos <= 0xff, 'SL:B4:0');\n\n    //     assembly {\n    //         res := and(shr(pos, input), 0xffff)\n    //     }\n    // }\n\n    // function bit20(uint256 input, uint256 pos) internal pure  returns (uint16 res) {\n    //     require(pos <= 0xff, 'SL:B4:0');\n\n    //     assembly {\n    //         res := and(shr(pos, input), 0xfffff)\n    //     }\n    // }\n\n    // function bit24(uint256 input, uint256 pos) internal pure  returns (uint16 res) {\n    //     require(pos <= 0xff, 'SL:B4:0');\n\n    //     assembly {\n    //         res := and(shr(pos, input), 0xffffff)\n    //     }\n    // }\n\n    // function bit28(uint256 input, uint256 pos) internal pure  returns (uint16 res) {\n    //     require(pos <= 0xff, 'SL:B4:0');\n\n    //     assembly {\n    //         res := and(shr(pos, input), 0xfffffff)\n    //     }\n    // }\n\n    // function bit32(uint256 input, uint256 pos) internal pure  returns (uint16 res) {\n    //     require(pos <= 0xff, 'SL:B4:0');\n\n    //     assembly {\n    //         res := and(shr(pos, input), 0xffffffff)\n    //     }\n    // }\n\n    // function bit1(\n    //     uint256 input,\n    //     uint256 pos,\n    //     bool update\n    // ) internal pure  returns (uint256 res) {\n    //     require(pos <= 0xff, 'SL:B4:0');\n    //     uint256 tu = update ? 0x1 : 0x0;\n    //     assembly {\n    //         input := and(not(shl(pos, 0x3)), input)\n    //         res := or(input, shl(pos, tu))\n    //     }\n    // }\n\n    // function bit3(\n    //     uint256 input,\n    //     uint256 pos,\n    //     uint256 update\n    // ) internal pure  returns (uint256 res) {\n    //     require(update <= 0xb && pos <= 0xff, 'SL:B3:0');\n    //     assembly {\n    //         input := and(not(shl(pos, 0xb)), input)\n    //         res := or(input, shl(pos, update))\n    //     }\n    // }\n\n    // function bit4(\n    //     uint256 input,\n    //     uint256 pos,\n    //     uint256 update\n    // ) internal pure  returns (uint256 res) {\n    //     require(update <= 0xf && pos <= 0xff, 'SL:B4:0');\n    //     assembly {\n    //         input := and(not(shl(pos, 0xf)), input)\n    //         res := or(input, shl(pos, update))\n    //     }\n    // }\n\n    // function bit6(\n    //     uint256 input,\n    //     uint256 pos,\n    //     uint256 update\n    // ) internal pure  returns (uint256 res) {\n    //     require(update <= 0xff && pos <= 0xff, 'SL:B8:0');\n    //     assembly {\n    //         input := and(not(shl(pos, 0x3f)), input)\n    //         res := or(input, shl(pos, update))\n    //     }\n    // }\n\n    // function bit8(\n    //     uint256 input,\n    //     uint256 pos,\n    //     uint256 update\n    // ) internal pure  returns (uint256 res) {\n    //     require(update <= 0xff && pos <= 0xff, 'SL:B8:0');\n    //     assembly {\n    //         input := and(not(shl(pos, 0xff)), input)\n    //         res := or(input, shl(pos, update))\n    //     }\n    // }\n\n    // function bit12(\n    //     uint256 input,\n    //     uint256 pos,\n    //     uint256 update\n    // ) internal pure  returns (uint256 res) {\n    //     require(update <= 0xfff && pos <= 0xff, 'SL:B12:0');\n    //     assembly {\n    //         input := and(not(shl(pos, 0xfff)), input)\n    //         res := or(input, shl(pos, update))\n    //     }\n    // }\n\n    // function bit16(\n    //     uint256 input,\n    //     uint256 pos,\n    //     uint256 update\n    // ) internal pure  returns (uint256 res) {\n    //     require(update <= 0xffff && pos <= 0xff, 'SL:B16:0');\n    //     assembly {\n    //         input := and(not(shl(pos, 0xffff)), input)\n    //         res := or(input, shl(pos, update))\n    //     }\n    // }\n\n    // function bit20(\n    //     uint256 input,\n    //     uint256 pos,\n    //     uint256 update\n    // ) internal pure  returns (uint256 res) {\n    //     require(update <= 0xfffff && pos <= 0xff, 'SL:B16:0');\n    //     assembly {\n    //         input := and(not(shl(pos, 0xfffff)), input)\n    //         res := or(input, shl(pos, update))\n    //     }\n    // }\n\n    // function bit24(\n    //     uint256 input,\n    //     uint256 pos,\n    //     uint256 update\n    // ) internal pure  returns (uint256 res) {\n    //     require(update <= 0xffffff && pos <= 0xff, 'SL:B16:0');\n    //     assembly {\n    //         input := and(not(shl(pos, 0xffffff)), input)\n    //         res := or(input, shl(pos, update))\n    //     }\n    // }\n\n    // function bit28(\n    //     uint256 input,\n    //     uint256 pos,\n    //     uint256 update\n    // ) internal pure  returns (uint256 res) {\n    //     require(update <= 0xfffffff && pos <= 0xff, 'SL:B16:0');\n    //     assembly {\n    //         input := and(not(shl(pos, 0xfffffff)), input)\n    //         res := or(input, shl(pos, update))\n    //     }\n    // }\n\n    // function bit32(\n    //     uint256 input,\n    //     uint256 pos,\n    //     uint256 update\n    // ) internal pure  returns (uint256 res) {\n    //     require(update <= 0xffffffff && pos <= 0xff, 'SL:B16:0');\n    //     assembly {\n    //         input := and(not(shl(pos, 0xffffffff)), input)\n    //         res := or(input, shl(pos, update))\n    //     }\n    // }\n}\n"
    },
    "contracts/mock/types/ItemType.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// 1/2 byte - size ---- 0-15\n// 1/2 bytes - base -----  0-15\n// 1/2 byte - traits 0-3\n// 1/2 byte - traits 4-7 --- 2\n\n// 1.5 bytes - head\n// 1.5 bytes - eyes\n// 1.5 bytes - mouth\n// 1.5 bytes - other\n// 1.5 bytes - other2 ---- 7.5  9.5\n\n// 1.5 bytes - head\n// 1.5 bytes - eyes\n// 1.5 bytes - mouth\n// 1.5 bytes - other\n// 1.5 bytes - other2 ---- 7.5  17\n\n// 1.5 bytes - head\n// 1.5 bytes - eyes\n// 1.5 bytes - mouth\n// 1.5 bytes - other\n// 1.5 bytes - other2 ---- 7.5  24.5\n\n// 1.5 bytes - head\n// 1.5 bytes - eyes\n// 1.5 bytes - mouth\n// 1.5 bytes - other\n// 1.5 bytes - other2 ---- 7.5  32\n\n// each nugg gets 10 items (2 of each item) (10 bytes)\n\n// need to determine the order those pop up in\n\n// first 10 under 128 - if not hit, load them up at the end\n\n// need to figure out what determines the randomnness (last 10 bytes)\n\n//\n\n// each item has a rarity of 1/256, 2/256,\n\n//\n\npragma solidity 0.8.4;\n\n// import '../../test/Console.sol';\nimport '../../src/libraries/ShiftLib.sol';\n\nlibrary ItemType {\n    using ShiftLib for uint256;\n\n    uint8 constant HEAD_INDEX = 0;\n    uint8 constant EYES_INDEX = 1;\n    uint8 constant MOUTH_INDEX = 2;\n    uint8 constant OTHER_INDEX = 3;\n    uint8 constant SPECIAL_INDEX = 4;\n\n    uint8 constant NUM_ATTRS = 5;\n    uint8 constant NUM_SLOTS = 4;\n\n    uint256 constant BLOCKED_ITEM = 0xffff;\n\n    uint256 constant OPEN_ITEM = 0x0000;\n\n    function size(uint256 input) internal pure returns (uint256 res) {\n        res = input.bit(4, 0);\n    }\n\n    function base(uint256 input) internal pure returns (uint256 res) {\n        res = input.bit(4, 4);\n    }\n\n    function checkSlot(uint256 slot) internal pure {\n        require(slot < NUM_SLOTS, 'IT:S:0');\n    }\n\n    function checkIndex(uint256 index) internal pure {\n        require(index < NUM_ATTRS, 'IT:A:0');\n    }\n\n    function valid(\n        uint256 input,\n        uint256 index,\n        uint256 slot\n    ) internal pure returns (bool res) {\n        checkSlot(slot);\n        checkIndex(index);\n\n        // uint256 s = size(input);\n\n        // uint256 check = (slot - 1) * NUM_ATTRS + index;\n\n        if (slot == 0 || size(input) >= (slot - 1) * NUM_ATTRS + index) return true;\n\n        // head    1 = 0\n        // mouth   1 = 1\n        // eyes    1 = 2\n        // other   1 = 3\n        // special 1 = 4\n        // head    2 = 5\n        // mouth   2 = 6\n        // eyes    2 = 7\n        // other   2 = 8\n        // special 2 = 9\n        // head    3 = 10\n        // mouth   3 = 11\n        // eyes    3 = 12\n        // other   3 = 13\n        // special 3 = 14\n    }\n\n    enum Index {\n        HEAD,\n        EYES,\n        MOUTH,\n        OTHER,\n        SPECIAL\n    }\n\n    function item(\n        uint256 input,\n        uint256 index,\n        uint256 slot\n    ) internal pure returns (uint256 res) {\n        if (valid(input, uint256(index), slot)) {\n            res = input.bit(12, 16 + (48 * uint256(index)) + (12 * slot));\n        } else {\n            res = BLOCKED_ITEM;\n        }\n    }\n\n    function item(\n        uint256 input,\n        uint256 index,\n        uint256 slot,\n        uint256 update\n    ) internal pure returns (uint256 res) {\n        res = input.bit(12, 16 + (48 * uint256(index)) + (12 * slot), update);\n    }\n\n    // function item(\n    //     uint256 input,\n    //     uint256 index,\n    //     uint256 slot\n    // ) internal pure  returns (uint256 res) {\n    //     if (valid(input, index, slot)) {\n    //         res = input.bit(12,16 + (48 * index) + (12 * slot));\n    //     } else {\n    //         res = BLOCKED_ITEM;\n    //     }\n    // }\n\n    // function item(\n    //     uint256 input,\n    //     uint256 index,\n    //     uint256 slot,\n    //     uint256 update\n    // ) internal pure  returns (uint256 res) {\n    //     res = input.bit(12,16 + (48 * index) + (12 * slot), update);\n    // }\n\n    // function head(uint256 input, uint8 index) internal pure  returns (uint256 res) {\n    //     checkSlot(index);\n    //     res = item(input, HEAD_INDEX, index);\n    // }\n\n    // function head(\n    //     uint256 input,\n    //     uint8 index,\n    //     uint256 update\n    // ) internal pure  returns (uint256 res) {\n    //     checkSlot(index);\n    //     res = item(input, HEAD_INDEX, index, update);\n    // }\n\n    // function eyes(uint256 input, uint8 index) internal pure  returns (uint256 res) {\n    //     checkSlot(index);\n    //     res = item(input, EYES_INDEX, index);\n    // }\n\n    // function eyes(\n    //     uint256 input,\n    //     uint8 index,\n    //     uint256 update\n    // ) internal pure  returns (uint256 res) {\n    //     checkSlot(index);\n    //     res = item(input, EYES_INDEX, index, update);\n    // }\n\n    // function mouth(uint256 input, uint8 slot) internal pure  returns (uint256 res) {\n    //     checkSlot(slot);\n    //     res = item(input, MOUTH_INDEX, slot);\n    // }\n\n    // function mouth(\n    //     uint256 input,\n    //     uint8 slot,\n    //     uint256 update\n    // ) internal pure  returns (uint256 res) {\n    //     checkSlot(slot);\n    //     res = item(input, MOUTH_INDEX, slot, update);\n    // }\n\n    // function other(uint256 input, uint8 slot) internal pure  returns (uint256 res) {\n    //     checkSlot(slot);\n    //     res = item(input, OTHER_INDEX, slot);\n    // }\n\n    // function other(\n    //     uint256 input,\n    //     uint8 slot,\n    //     uint256 update\n    // ) internal pure  returns (uint256 res) {\n    //     checkSlot(slot);\n    //     res = item(input, OTHER_INDEX, slot, update);\n    // }\n\n    // function special(uint256 input, uint8 slot) internal pure  returns (uint256 res) {\n    //     checkSlot(slot);\n    //     res = item(input, SPECIAL_INDEX, slot);\n    // }\n\n    // function special(\n    //     uint256 input,\n    //     uint8 slot,\n    //     uint256 update\n    // ) internal pure  returns (uint256 res) {\n    //     checkSlot(slot);\n    //     res = item(input, SPECIAL_INDEX, slot, update);\n    // }\n}\n"
    },
    "contracts/mock/types/LengthType.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../../src/libraries/ShiftLib.sol';\nimport './ItemType.sol';\n\nlibrary LengthType {\n    using ShiftLib for uint256;\n\n    function length(uint256 input, uint256 index) internal pure returns (uint256 res) {\n        res = input.bit(12, (12 * uint256(index)));\n    }\n\n    function length(\n        uint256 input,\n        uint256 index,\n        uint256 update\n    ) internal pure returns (uint256 res) {\n        res = input.bit(12, (12 * uint256(index)), update);\n    }\n}\n"
    },
    "contracts/src/interfaces/IResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../erc165/IERC165.sol';\n\ninterface IProcessResolver is IERC165 {\n    function process(\n        uint256[][] memory files,\n        bytes memory data,\n        bytes memory preProcessData\n    ) external view returns (uint256[] memory file);\n\n    function supportsInterface(bytes4 interfaceId) external view override returns (bool);\n}\n\ninterface IPreProcessResolver is IERC165 {\n    function preProcess(bytes memory data) external view returns (bytes memory preProcessData);\n\n    function supportsInterface(bytes4 interfaceId) external view override returns (bool);\n}\n\ninterface IPostProcessResolver is IERC165 {\n    function postProcess(\n        uint256[] memory file,\n        bytes memory data,\n        bytes memory preProcessData\n    ) external view returns (bytes memory res);\n\n    function supportsInterface(bytes4 interfaceId) external view override returns (bool);\n}\n\ninterface INuggFtProcessor is IERC165, IPostProcessResolver, IProcessResolver, IPreProcessResolver {\n    function postProcessor() external view returns (IPostProcessResolver);\n\n    function preProcessor() external view returns (IPreProcessResolver);\n\n    function processor() external view returns (IProcessResolver);\n\n    function supportsInterface(bytes4 interfaceId) external view override(IERC165, IPostProcessResolver, IProcessResolver, IPreProcessResolver) returns (bool);\n}\n"
    },
    "contracts/mock/types/OldShiftType.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\n\nlibrary OldShiftType {\n    function unmask(uint256 input) internal pure returns (uint256 res) {\n        assembly {\n            res := input\n            if eq(res, not(0)) {\n                res := 0\n            }\n        }\n    }\n\n    function mask(uint256 input) internal pure returns (uint256 res) {\n        assembly {\n            res := input\n            if eq(res, 0) {\n                res := not(0)\n            }\n        }\n    }\n\n    function account(uint256 input) internal pure returns (uint160 res) {\n        assembly {\n            res := input\n        }\n    }\n\n    function account(uint256 input, uint160 update) internal pure returns (uint256 res) {\n        assembly {\n            input := and(input, 0xffffffffffffffffffffffff0000000000000000000000000000000000000000)\n            res := or(input, update)\n        }\n    }\n\n    function isOwner(uint256 input, bool) internal pure returns (uint256 res) {\n        assembly {\n            res := or(input, shl(255, 0x1))\n        }\n    }\n\n    function isOwner(uint256 input) internal pure returns (bool res) {\n        assembly {\n            res := and(shr(255, input), 0x1)\n        }\n    }\n\n    function eth(uint256 input) internal pure returns (uint256 res) {\n        assembly {\n            res := and(shr(160, input), 0xFFFFFFFFFFFFFF)\n            let i := and(res, 0xff)\n            res := shl(mul(4, i), shr(8, res))\n            res := mul(res, 0xE8D4A51000)\n        }\n    }\n\n    // 14 f's\n    function eth(uint256 input, uint256 update) internal pure returns (uint256 res, uint256 rem) {\n        assembly {\n            let in := update\n            update := div(update, 0xE8D4A51000)\n            for {\n            } gt(update, 0xFFFFFFFFFFFF) {\n                // 13\n            } {\n                res := add(res, 0x01)\n                update := shr(4, update)\n            }\n            update := or(shl(8, update), res)\n            let out := shl(mul(4, res), shr(8, update))\n            rem := sub(in, mul(out, 0xE8D4A51000))\n            input := and(input, 0xffffffffff00000000000000ffffffffffffffffffffffffffffffffffffffff)\n            res := or(input, shl(160, update))\n        }\n    }\n\n    // 9 f's\n    function epoch(uint256 input, uint256 update) internal pure returns (uint256 res) {\n        assert(update <= 0xFFFFFFFFF);\n        assembly {\n            //                0xfffffffffffffffddffffffffffffffccfffffffffffffffffffffffffffffff)\n            res := and(input, 0xf000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            res := or(res, shl(216, update))\n        }\n    }\n\n    function epoch(uint256 input) internal pure returns (uint256 res) {\n        assembly {\n            res := and(shr(216, input), 0xFFFFFFFFF)\n        }\n    }\n\n    function pushFirstEmpty(uint256 input, uint16 itemId) internal pure returns (uint256 res, uint8 index) {\n        uint256[] memory _items = items(input);\n        for (uint8 i = 0; i < _items.length; i++) {\n            if (_items[i] == 0) {\n                index = i + 1;\n                break;\n            }\n        }\n\n        require(index > 0, 'SL:PFM:A');\n\n        index--;\n\n        res = pushItem(input, itemId, index);\n\n    }\n\n    function popFirstMatch(uint256 input, uint16 itemId)\n        internal\n        pure\n        returns (\n            uint256 res,\n            uint16 popped,\n            uint8 index\n        )\n    {\n        uint256[] memory _items = items(input);\n        for (uint8 i = 0; i < _items.length; i++) {\n            if (_items[i] == itemId) {\n                index = i + 1;\n                break;\n            }\n        }\n\n        require(index > 0, 'SL:PFM:0');\n\n        index--;\n\n        (res, popped) = popItem(input, index);\n\n\n        require(popped == itemId, 'SL:PFM:1');\n    }\n\n    function items(uint256 input) internal pure returns (uint256[] memory res) {\n        uint256 s = size(input);\n        res = new uint256[](s);\n        input >>= 16;\n        for (uint256 i = 0; i < s; i++) {\n            res[i] = input & 0xffff;\n            input >>= 16;\n        }\n    }\n\n    // function itemsWithTokenId(uint256 input, uint256 tokenId) internal pure returns (uint256[] memory res) {\n    //     uint256 s = size(input);\n    //     res = new uint256[](s + 1);\n    //     res[0] = tokenId;\n    //     input >>= 8;\n    //     for (uint256 i = 0; i < s; i++) {\n    //         input >>= i == 0 ? 8 : 16;\n    //         res[i] = input & 0xffff;\n    //     }\n    // }\n\n    function pushItem(\n        uint256 input,\n        uint16 itm,\n        uint8 at\n    ) internal pure returns (uint256 res) {\n        assembly {\n            let offset := add(16, mul(16, at))\n            res := and(input, not(shl(offset, 0xffff)))\n            res := or(input, shl(offset, itm))\n        }\n    }\n\n    function popItem(uint256 input, uint8 at) internal pure returns (uint256 res, uint16 itm) {\n        assembly {\n            let offset := add(16, mul(16, at))\n            res := and(input, not(shl(offset, 0xffff)))\n            itm := shr(offset, input)\n        }\n    }\n\n    function size(uint256 input, uint256 update) internal pure returns (uint256 res) {\n        assembly {\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00)\n            res := or(update, input)\n        }\n    }\n\n    function size(uint256 input) internal pure returns (uint256 res) {\n        assembly {\n            res := and(input, 0xff)\n        }\n    }\n\n    function base(uint256 input) internal pure returns (uint256 res) {\n        assembly {\n            res := and(shr(0x8, input), 0xff)\n        }\n    }\n\n    function base(uint256 input, uint256 update) internal pure returns (uint256 res) {\n        assembly {\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00ff)\n            res := or(shl(0x8, update), input)\n        }\n    }\n\n    function item0(uint256 input, uint16 update) internal pure returns (uint256 res) {\n        assembly {\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000)\n            res := or(shl(mul(16, 0), update), input)\n        }\n    }\n\n    function item0(uint256 input) internal pure returns (uint16 res) {\n        assembly {\n            res := shr(mul(16, 0), input)\n        }\n    }\n\n    function item1(uint256 input, uint16 update) internal pure returns (uint256 res) {\n        assembly {\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000ffff)\n            res := or(shl(mul(16, 1), update), input)\n        }\n    }\n\n    function item1(uint256 input) internal pure returns (uint16 res) {\n        assembly {\n            res := shr(mul(16, 1), input)\n        }\n    }\n\n    function item2(uint256 input, uint16 update) internal pure returns (uint256 res) {\n        assembly {\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffffffffffffffff0000ffffffff)\n            res := or(shl(mul(16, 2), update), input)\n        }\n    }\n\n    function item2(uint256 input) internal pure returns (uint16 res) {\n        assembly {\n            res := shr(mul(16, 2), input)\n        }\n    }\n\n    function item3(uint256 input, uint16 update) internal pure returns (uint256 res) {\n        assembly {\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffffffffffff0000ffffffffffff)\n            res := or(shl(mul(16, 3), update), input)\n        }\n    }\n\n    function item3(uint256 input) internal pure returns (uint16 res) {\n        assembly {\n            res := shr(mul(16, 3), input)\n        }\n    }\n\n    function item4(uint256 input, uint16 update) internal pure returns (uint256 res) {\n        assembly {\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffffffff0000ffffffffffffffff)\n            res := or(shl(mul(16, 4), update), input)\n        }\n    }\n\n    function item4(uint256 input) internal pure returns (uint16 res) {\n        assembly {\n            res := shr(mul(16, 4), input)\n        }\n    }\n\n\n\n    function item(uint256 input, uint8 id) internal pure returns (uint16 res) {\n        assembly {\n            res := shr(mul(16, id), input)\n        }\n    }\n\n    function item(uint256 input, uint16 update, uint8 id) internal pure returns (uint256 res) {\n        assembly {\n            input := and(input,not(shl(mul(16, id), 0xffff)))\n            res := or(shl(mul(16, id), update), input)\n        }\n    }\n}\n"
    },
    "contracts/test/Event.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../src/libraries/Uint.sol';\nimport '../../contracts/src/libraries/Uint.sol';\n\n\n\nlibrary Event {\n    function log(uint256 val, string memory name) internal view {\n\n\n\n    }\n\n    function log(\n        uint256 val0,\n        string memory name0,\n        uint256 val1,\n        string memory name1,\n        uint256 val2,\n        string memory name2\n    ) internal view {\n\n\n\n\n    }\n\n    function log(\n        uint256 val0,\n        string memory name0,\n        uint256 val1,\n        string memory name1\n    ) internal view {\n\n\n\n    }\n\n    function log(\n        uint256 val0,\n        string memory name0,\n        uint256 val1,\n        string memory name1,\n        uint256 val2,\n        string memory name2,\n        uint256 val3,\n        string memory name3\n    ) internal view {\n\n\n\n\n\n    }\n\n    function log(uint256[] memory arr, string memory name) internal view {\n\n\n        for (uint256 i = 0; i < arr.length; i++) {\n\n        }\n    }\n}\n\n// library Event {\n//     function log(uint256 val, string memory name) internal view {}\n\n//     function log(\n//         uint256 val0,\n//         string memory name0,\n//         uint256 val1,\n//         string memory name1,\n//         uint256 val2,\n//         string memory name2\n//     ) internal view {}\n\n//     function log(uint256[] memory arr, string memory name) internal view {}\n// }\n"
    },
    "contracts/src/libraries/Uint.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\n/*\n * @dev Uint operations.\n */\nlibrary Uint8 {\n    function toByte(uint8 u) internal pure returns (bytes1 res) {\n        res = bytes1(u);\n    }\n\n    function toString(uint8 u) internal pure returns (string memory res) {\n        res = Uint256.toString(uint256(u));\n    }\n}\n\n/*\n * @dev Uint operations.\n */\nlibrary Uint256 {\n    bytes16 private constant ALPHABET = '0123456789abcdef';\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toAscii(uint256 value) internal pure returns (bytes memory buffer) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return '0';\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n\n        buffer = new bytes(digits);\n\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return buffer;\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        return string(toAscii(value));\n    }\n\n    /// @notice Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n    /// @dev Credit to Open Zeppelin under MIT license https://github.com/OpenZeppelin/openzeppelin-contracts/blob/243adff49ce1700e0ecb99fe522fb16cff1d1ddc/contracts/utils/Strings.sol#L55\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = '0';\n        buffer[1] = 'x';\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = ALPHABET[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, 'Strings: hex length insufficient');\n        return string(buffer);\n    }\n\n    function toHexStringNoPrefix(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length);\n        for (uint256 i = buffer.length; i > 0; i--) {\n            buffer[i - 1] = ALPHABET[value & 0xf];\n            value >>= 4;\n        }\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/src/erc165/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/mock/DotNuggHolder/MockDotNuggHolder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport './IMockDotNuggHolder.sol';\nimport './DotNuggLib.sol';\nimport '../types/ItemType.sol';\n\nimport './../../src/interfaces/IDotNugg.sol';\nimport './../../src/interfaces/IResolver.sol';\n\ncontract MockDotNuggHolder is IMockDotNuggHolder {\n    using DotNuggLib for DotNuggLib.Storage;\n\n    address _defaultResolver;\n\n    DotNuggLib.Storage dotnugg_storage;\n    ItemLib.Storage item_storage;\n\n    constructor(address defaultResolver_) {\n        _defaultResolver = defaultResolver_;\n    }\n\n    function dotNuggUpload(uint256[][] calldata items, bytes memory) external override {\n        dotnugg_storage.addItems(items);\n\n        ItemLib.mint(item_storage, dotnugg_storage, 0, uint256(blockhash(block.number - 1)));\n    }\n\n    function tokenUri(uint256 tokenId) external view returns (string memory res) {\n        return string(tokenUri(tokenId, defaultResolver(tokenId)));\n    }\n\n    function defaultResolver(uint256) public view returns (address res) {\n        return _defaultResolver;\n    }\n\n    function tokenUri(uint256 tokenId, address resolver) public view returns (bytes memory res) {\n        (uint256[][] memory files, uint256 itemData) = dotnugg_storage.getData(item_storage, tokenId);\n\n        bytes memory data = abi.encode(tokenId, itemData, address(this));\n\n        bytes memory customData = IPreProcessResolver(resolver).preProcess(data);\n\n        uint256[] memory processedFile = IProcessResolver(resolver).process(files, data, customData);\n\n        return IPostProcessResolver(resolver).postProcess(processedFile, data, customData);\n    }\n\n    // function tokenUriTest(uint256 tokenId) external view returns (uint256[] memory res) {\n    //     res = dotnugg_storage.generateTokenURITest(item_storage, address(dotnugg), tokenId, address(svgResolver));\n    // }\n\n    // function tokenUri2(uint256 tokenId) external view returns (string memory res) {\n    //     res = dotnugg_storage.generateTokenURI2(item_storage, address(dotnugg), tokenId, address(svgResolver));\n    // }\n\n    // function tokenUriTest2(uint256 tokenId) external view returns (uint256[] memory res) {\n    //     res = dotnugg_storage.generateTokenURITest2(item_storage, address(dotnugg), tokenId, address(svgResolver));\n    // }\n}\n"
    },
    "contracts/mock/DotNuggHolder/IMockDotNuggHolder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\ninterface IMockDotNuggHolder {\n    function dotNuggUpload(uint256[][] memory items, bytes memory data) external;\n}\n"
    },
    "contracts/src/interfaces/IDotNugg.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport {Version as V} from '../types/Version.sol';\n\ninterface IDotNugg {\n    struct Rlud {\n        bool exists;\n        uint8 r;\n        uint8 l;\n        uint8 u;\n        uint8 d;\n    }\n\n    struct Rgba {\n        uint8 r;\n        uint8 g;\n        uint8 b;\n        uint8 a;\n    }\n\n    struct Anchor {\n        Rlud radii;\n        Coordinate coordinate;\n    }\n\n    struct Coordinate {\n        uint8 a; // anchorId\n        uint8 b; // yoffset\n        bool exists;\n    }\n\n    // struct Collection {\n    //     uint8 width;\n    //     uint8 height;\n    //     uint8 numFeatures;\n    //     bytes[] defaults;\n    // }\n\n    struct Version {\n        uint8 width;\n        uint8 height;\n        Anchor anchor;\n        // these must be in same order as canvas receivers, respectively\n        Coordinate[] calculatedReceivers; // can be empty\n        Coordinate[] staticReceivers; // can be empty\n        Rlud expanders;\n        bytes data;\n    }\n\n    struct Canvas {\n        Matrix matrix;\n        Anchor[] receivers;\n    }\n\n    struct Mix {\n        uint8 feature;\n        Version version;\n        Matrix matrix;\n        Anchor[] receivers;\n        uint8 yoffset;\n        uint8 xoffset;\n    }\n\n    // struct Pixel {\n    //     int8 zindex;\n    //     Rgba rgba;\n    //     bool exists;\n    // }\n\n    // struct Pallet {\n    //     Pixel[] pixels;\n    // }\n\n    struct Matrix {\n        uint8 width;\n        uint8 height;\n        // Pixel[][] data;\n        V.Memory version;\n        uint8 currentUnsetX;\n        uint8 currentUnsetY;\n        bool init;\n        uint8 startX;\n    }\n}\n"
    },
    "contracts/src/types/Version.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../libraries/BitReader.sol';\n\nlibrary Version {\n    using BitReader for BitReader.Memory;\n    using Event for uint256;\n    using Event for uint256[];\n\n    struct Memory {\n        uint256[] pallet;\n        uint256[] minimatrix;\n        uint256[] bigmatrix;\n        uint256 receivers;\n        uint256 data;\n    }\n\n    function parse(uint256[][] memory data) internal view returns (Memory[][] memory m) {\n        m = new Memory[][](data.length);\n\n        for (uint256 j = 0; j < data.length; j++) {\n            (bool empty, BitReader.Memory memory reader) = BitReader.init(data[j]);\n\n            if (empty) continue;\n\n            // 32 bits: NUGG\n            require(reader.select(32) == 0x4e554747, 'DEC:PI:0');\n\n            uint256 feature = reader.select(3);\n\n            uint256[] memory pallet = parsePallet(reader);\n\n            uint256 versionLength = reader.select(2) + 1;\n\n            m[j] = new Memory[](versionLength);\n\n            for (uint256 i = 0; i < versionLength; i++) {\n                m[j][i].data = parseData(reader, feature);\n\n                m[j][i].receivers = parseReceivers(reader);\n\n                (uint256 width, uint256 height) = getWidth(m[j][i]);\n\n                m[j][i].minimatrix = parseMiniMatrix(reader, width, height);\n\n                m[j][i].pallet = pallet;\n\n                (uint256 ancX, uint256 ancY) = getAnchor(m[j][i]);\n                (, , uint256 ancZ) = getPalletColorAt(m[j][i], getPixelAt(m[j][i], ancX, ancY));\n\n                setZ(m[j][i], ancZ);\n            }\n        }\n    }\n\n    function parsePallet(BitReader.Memory memory reader) internal pure returns (uint256[] memory res) {\n        uint256 palletLength = reader.select(4) + 1;\n\n        res = new uint256[](palletLength + 1);\n\n        for (uint256 i = 0; i < palletLength; i++) {\n            uint256 working = 0;\n            // 4 bits: zindex\n            working |= (reader.select(4) << 32);\n\n            uint256 color;\n            uint256 selecta = reader.select(1);\n            if (selecta == 1) {\n                color = 0x000000;\n            } else {\n                uint256 r = reader.select(8);\n                uint256 g = reader.select(8);\n                uint256 b = reader.select(8);\n\n                color = (r << 16) | (g << 8) | b;\n            }\n\n            // // 1 or 25 bits: rgb\n            working |= color << 8;\n\n            // // 1 or 8 bits: a\n            working |= (reader.select(1) == 0x1 ? 0xff : reader.select(8));\n\n            res[i + 1] = working;\n        }\n    }\n\n    function parseData(BitReader.Memory memory reader, uint256 feature) internal pure returns (uint256 res) {\n        // 12 bits: coordinate - anchor x and y\n\n        res |= feature << 75;\n\n        uint256 width = reader.select(6);\n        uint256 height = reader.select(6);\n\n        res |= height << 69; // heighth and width\n        res |= width << 63;\n\n        // 12 bits: coordinate - anchor x and y\n        res |= reader.select(6) << 51;\n        res |= reader.select(6) << 57;\n\n        // 1 or 25 bits: rlud - radii\n        res |= (reader.select(1) == 0x1 ? 0x000000 : reader.select(24)) << 27;\n\n        // 1 or 25 bits: rlud - expanders\n        res |= (reader.select(1) == 0x1 ? 0x000000 : reader.select(24)) << 3;\n    }\n\n    function parseReceivers(BitReader.Memory memory reader) internal pure returns (uint256 res) {\n        uint256 receiversLength = reader.select(1) == 0x1 ? 0x1 : reader.select(4);\n\n        for (uint256 j = 0; j < receiversLength; j++) {\n            uint256 receiver = 0;\n\n            uint256 yOrYOffset = reader.select(6);\n\n            uint256 xOrPreset = reader.select(6);\n\n            // rFeature\n            uint256 rFeature = reader.select(3);\n\n            uint256 calculated = reader.select(1);\n\n            if (calculated == 0x1) {\n                receiver |= yOrYOffset << 6;\n                receiver |= xOrPreset;\n            } else {\n                receiver |= xOrPreset << 6;\n                receiver |= yOrYOffset;\n            }\n\n            receiver <<= ((rFeature * 12) + (calculated == 0x1 ? 128 : 0));\n\n            res |= receiver;\n        }\n    }\n\n    function parseMiniMatrix(\n        BitReader.Memory memory reader,\n        uint256 height,\n        uint256 width\n    ) internal pure returns (uint256[] memory res) {\n        uint256 groupsLength = reader.select(1) == 0x1 ? reader.select(8) + 1 : reader.select(16) + 1;\n\n        res = new uint256[]((height * width) / 64 + 1);\n\n        uint256 index = 0;\n\n        for (uint256 a = 0; a < groupsLength; a++) {\n            uint256 len = reader.select(2) + 1;\n\n            if (len == 4) len = reader.select(4) + 4;\n\n            uint256 key = reader.select(4);\n\n            for (uint256 i = 0; i < len; i++) {\n                res[index / 64] |= (key << (4 * (index % 64)));\n                index++;\n            }\n        }\n    }\n\n    function getReceiverAt(\n        Memory memory m,\n        uint256 index,\n        bool calculated\n    )\n        internal\n        pure\n        returns (\n            uint256 x,\n            uint256 y,\n            bool exists\n        )\n    {\n        uint256 data = m.receivers >> (index * 12 + (calculated ? 128 : 0));\n\n        data &= ShiftLib.mask(12);\n\n        x = data & ShiftLib.mask(6);\n        y = data >> 6;\n\n        exists = x != 0 || y != 0;\n    }\n\n    function setReceiverAt(\n        Memory memory m,\n        uint256 index,\n        bool calculated,\n        uint256 x,\n        uint256 y\n    ) internal pure returns (uint256 res) {\n        // yOrYOffset\n        res |= y << 6;\n\n        //xOrPreset\n        res |= x;\n\n        m.receivers |= res << ((index * 12) + (calculated ? 128 : 0));\n    }\n\n    function setOffset(\n        Memory memory m,\n        bool negX,\n        uint256 diffX,\n        bool negY,\n        uint256 diffY\n    ) internal pure {\n        m.data |= ((((diffX & 0xff) << 1) | (((negX ? 0x1 : 0x0)))) << 85);\n        m.data |= ((((diffY & 0xff) << 1) | ((((negY ? 0x1 : 0x0))))) << 94);\n    }\n\n    function getOffset(Memory memory m)\n        internal\n        pure\n        returns (\n            bool negX,\n            uint256 diffX,\n            bool negY,\n            uint256 diffY\n        )\n    {\n        uint256 data = m.data;\n        negX = (data >> 85) & 0x1 == 1;\n        diffX = (data >> 86) & 0xff;\n        negY = (data >> 94) & 0x1 == 1;\n        diffY = (data >> 95) & 0xff;\n    }\n\n    function setZ(Memory memory m, uint256 z) internal pure {\n        require(z <= 0xf, 'VERS:SETZ:0');\n        m.data |= z << 78;\n    }\n\n    function getZ(Memory memory m) internal pure returns (uint256 res) {\n        res = (m.data >> 78) & 0xf;\n    }\n\n    function setFeature(Memory memory m, uint256 z) internal pure {\n        require(z <= ShiftLib.mask(3), 'VERS:SETF:0');\n        m.data &= ShiftLib.fullsubmask(3, 75);\n        m.data |= (z << 75);\n    }\n\n    function getFeature(Memory memory m) internal pure returns (uint256 res) {\n        res = (m.data >> 75) & ShiftLib.mask(3);\n    }\n\n    function getWidth(Memory memory m) internal pure returns (uint256 width, uint256 height) {\n        // yOrYOffset\n        width = (m.data >> 63) & ShiftLib.mask(6);\n        height = (m.data >> 69) & ShiftLib.mask(6);\n    }\n\n    function setWidth(\n        Memory memory m,\n        uint256 w,\n        uint256 h\n    ) internal pure {\n        require(w <= ShiftLib.mask(6), 'VERS:SETW:0');\n        require(h <= ShiftLib.mask(6), 'VERS:SETW:1');\n\n        m.data &= ShiftLib.fullsubmask(12, 63);\n\n        m.data |= (w << 63);\n        m.data |= (h << 69);\n    }\n\n    function getAnchor(Memory memory m) internal pure returns (uint256 x, uint256 y) {\n        // yOrYOffset\n        x = (m.data >> 51) & ShiftLib.mask(6);\n        y = (m.data >> 57) & ShiftLib.mask(6);\n    }\n\n    function getPixelAt(\n        Memory memory m,\n        uint256 x,\n        uint256 y\n    ) internal pure returns (uint256 palletKey) {\n        (uint256 width, ) = getWidth(m);\n        uint256 index = x + (y * width);\n\n        if (index / 64 >= m.minimatrix.length) return 0x0;\n\n        palletKey = (m.minimatrix[index / 64] >> (4 * (index % 64))) & 0xf;\n    }\n\n    function getPalletColorAt(Memory memory m, uint256 index)\n        internal\n        pure\n        returns (\n            uint256 res,\n            uint256 color,\n            uint256 zindex\n        )\n    {\n        // res = (m.pallet[index / 7] >> (36 * (index % 7))) & ShiftLib.mask(36);\n        res = m.pallet[index];\n\n        color = res & 0xffffffff;\n\n        zindex = (res >> 32) & 0xf;\n    }\n\n    function getDiffOfReceiverAt(Memory memory base, Memory memory mix)\n        internal\n        pure\n        returns (\n            bool negX,\n            uint256 diffX,\n            bool negY,\n            uint256 diffY\n        )\n    {\n        (uint256 recX, uint256 recY, ) = getReceiverAt(base, (mix.data >> 75) & ShiftLib.mask(3), false);\n        (uint256 ancX, uint256 ancY) = getAnchor(mix);\n\n        negX = recX < ancX;\n        diffX = negX ? ancX - recX : recX - ancX;\n        negY = recY < ancY;\n        diffY = negY ? ancY - recY : recY - ancY;\n    }\n\n    // function getPixelAtPositionWithOffset(Memory memory m, uint256 index) internal pure returns (bool exists, uint256 palletKey) {\n    //     (uint256 width, ) = getWidth(m);\n\n    //     uint256 indexY = index / 33;\n    //     uint256 indexX = index % 33;\n\n    //     (, uint256 diffX, , uint256 diffY) = getOffset(m);\n\n    //     if (width != 33) {}\n\n    //     if (indexX < diffX) return (false, 0);\n    //     uint256 realX = indexX - diffX;\n\n    //     if (indexY < diffY) return (false, 0);\n    //     uint256 realY = indexY - diffY;\n\n    //     if (width != 33) {}\n\n    //     // require(indexX >= diffX, 'VERS:GPAP:0');\n    //     // uint256 realX = indexX - diffX;\n\n    //     // require(indexY >= diffY, 'VERS:GPAP:1');\n    //     // uint256 realY = indexY - diffY;\n\n    //     // if (realX >= width || realY >= height) return (false, 0);\n\n    //     uint256 realIndex = realY * width + realX;\n\n    //     if (realIndex / 64 >= m.minimatrix.length) return (false, 0);\n    //     exists = true;\n\n    //     palletKey = (m.minimatrix[realIndex / 64] >> (4 * (realIndex % 64))) & 0xf;\n    // }\n\n    function initBigMatrix(Memory memory m, uint256 width) internal pure {\n        m.bigmatrix = new uint256[](((width * width) / 6) + 2);\n    }\n\n    function setBigMatrixPixelAt(\n        Memory memory m,\n        uint256 x,\n        uint256 y,\n        uint256 color\n    ) internal pure {\n        (uint256 width, ) = getWidth(m);\n\n        uint256 index = x + (y * width);\n\n        // m.bigmatrix[index / 6] |= (color << (40 * (index % 6)));\n\n        setBigMatrixPixelAt(m, index, color);\n    }\n\n    function setBigMatrixPixelAt(\n        Memory memory m,\n        uint256 index,\n        uint256 color\n    ) internal pure {\n        // require(m.bigmatrix.length > index / 6, 'VERS:SBM:0');\n\n        if (m.bigmatrix.length > index / 6) {\n            uint256 offset = (40 * (index % 6));\n            m.bigmatrix[index / 6] &= ShiftLib.fullsubmask(40, offset);\n            m.bigmatrix[index / 6] |= (color << offset);\n        }\n    }\n\n    function getBigMatrixPixelAt(\n        Memory memory m,\n        uint256 x,\n        uint256 y\n    ) internal pure returns (uint256 res) {\n        (uint256 width, ) = getWidth(m);\n\n        uint256 index = x + (y * width);\n\n        if (index / 6 >= m.bigmatrix.length) return 0x0000000000;\n\n        res = (m.bigmatrix[index / 6] >> (40 * (index % 6))) & 0xffffffffff;\n    }\n\n    function bigMatrixHasPixelAt(\n        Memory memory m,\n        uint256 x,\n        uint256 y\n    ) internal pure returns (bool res) {\n        uint256 pix = getBigMatrixPixelAt(m, x, y);\n\n        res = pix & 0xff != 0x00;\n    }\n\n    function bigMatrixWithData(Memory memory m) internal pure returns (uint256[] memory res) {\n        res = m.bigmatrix;\n        res[res.length - 1] = m.data;\n    }\n}\n"
    },
    "contracts/src/libraries/BitReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../libraries/ShiftLib.sol';\n\nlibrary BitReader {\n    using ShiftLib for uint256;\n    using Event for uint256;\n    using Uint256 for uint256;\n\n    struct Memory {\n        uint256[] dat;\n        uint256 moves;\n        uint256 pos;\n    }\n\n    function init(uint256[] memory input) internal view returns (bool err, Memory memory m) {\n        if (input.length == 0) return (true, m);\n\n        m.dat = input;\n\n        m.moves = 2;\n\n        m.dat = new uint256[](input.length);\n\n        Event.log(input.length, 'input.length');\n\n        for (uint256 i = input.length; i > 0; i--) {\n            m.dat[i - 1] = input[input.length - i];\n        }\n\n        // for (uint256 i = 1; i < input[0] + 1; i++) {\n        //     m.dat[input[0] - i] = input[i];\n        // }\n    }\n\n    function peek(Memory memory m, uint256 bits) internal pure returns (uint256 res) {\n        res = m.dat[0] & ShiftLib.mask(bits);\n    }\n\n    function select(Memory memory m, uint256 bits) internal pure returns (uint256 res) {\n        res = m.dat[0] & ShiftLib.mask(bits);\n\n        m.dat[0] = m.dat[0] >> bits;\n\n        m.pos += bits;\n\n        if (m.pos >= 128) {\n            uint256 ptr = (m.moves / 2);\n            if (ptr < m.dat.length) {\n                m.dat[0] <<= m.pos - 128;\n                uint256 move = m.dat[ptr] & ShiftLib.mask(128);\n                m.dat[ptr] >>= 128;\n                m.dat[0] |= (move << 128);\n                m.dat[0] >>= (m.pos - 128);\n                m.moves++;\n                m.pos -= 128;\n            }\n        }\n    }\n}\n"
    },
    "contracts/src/DefaultResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport './interfaces/IDotNugg.sol';\nimport './interfaces/IResolver.sol';\n\nimport './logic/Calculator.sol';\nimport './logic/Matrix.sol';\nimport './logic/Svg.sol';\n\nimport './v2/Merge.sol';\n\nimport './interfaces/IResolver.sol';\nimport './libraries/Base64.sol';\n\nimport './types/Version.sol';\n\n/**\n * @title DotNugg V1 - onchain encoder/decoder for dotnugg files\n * @author Nugg Labs - @danny7even & @dub6ix\n * @notice yoU CAN'T HaVe ImAgES oN THe BlOCkcHAIn\n * @dev hold my margarita\n */\ncontract DefaultResolver is INuggFtProcessor {\n    IPostProcessResolver public immutable override postProcessor;\n\n    IProcessResolver public immutable override processor;\n\n    IPreProcessResolver public immutable override preProcessor;\n\n    constructor() {\n        postProcessor = IPostProcessResolver(address(this));\n        preProcessor = IPreProcessResolver(address(this));\n        processor = IProcessResolver(address(this));\n    }\n\n    function preProcess(bytes memory) public pure override returns (bytes memory _res) {\n        _res = '';\n    }\n\n    function process(\n        uint256[][] memory files,\n        bytes memory data,\n        bytes memory\n    ) public view override returns (uint256[] memory resp) {\n        (address nft, uint256 tokenId, uint256 itemData, address owner) = abi.decode(data, (address, uint256, uint256, address));\n\n        Version.Memory[][] memory versions = Version.parse(files);\n\n        IDotNugg.Matrix memory old = Calculator.combine(8, 63, itemData, versions);\n\n        resp = Version.bigMatrixWithData(old.version);\n    }\n\n    function postProcess(\n        uint256[] memory file,\n        bytes memory data,\n        bytes memory\n    ) public view override returns (bytes memory res) {\n        (uint256 tokenId, uint256 itemData, address owner) = abi.decode(data, (uint256, uint256, address));\n\n        uint256 width = (file[file.length - 1] >> 63) & ShiftLib.mask(6);\n        uint256 height = (file[file.length - 1] >> 69) & ShiftLib.mask(6);\n\n\n\n        res = Svg.buildSvg(file, width, height);\n\n        res = Base64._encode(res);\n\n        res = abi.encodePacked(\n            Base64.PREFIX_JSON,\n            Base64._encode(\n                bytes(\n                    abi.encodePacked(\n                        '{\"name\":\"',\n                        'NuggFT',\n                        '\",\"tokenId\":\"',\n                        Uint256.toString(tokenId),\n                        '\",\"description\":\"',\n                        'The Nuggiest FT',\n                        '\",\"itemData\":\"',\n                        Uint256.toHexString(itemData, 32),\n                        '\",\"owner\":\"',\n                        Uint256.toHexString(uint160(owner), 20),\n                        '\", \"image\": \"',\n                        Base64.PREFIX_SVG,\n                        res,\n                        '\"}'\n                    )\n                )\n            )\n        );\n    }\n\n    function supportsInterface(bytes4 interfaceId) public pure override(INuggFtProcessor) returns (bool) {\n        return\n            interfaceId == type(INuggFtProcessor).interfaceId ||\n            interfaceId == type(IProcessResolver).interfaceId ||\n            interfaceId == type(IPreProcessResolver).interfaceId ||\n            interfaceId == type(IPostProcessResolver).interfaceId ||\n            interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "contracts/src/logic/Calculator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport './Matrix.sol';\nimport './Rgba.sol';\nimport './Anchor.sol';\n\nimport '../types/Descriptor.sol';\nimport '../types/Version.sol';\nimport '../types/Pixel.sol';\n\nimport '../interfaces/IDotNugg.sol';\n\nlibrary Calculator {\n    using Rgba for IDotNugg.Rgba;\n    using Matrix for IDotNugg.Matrix;\n    using Pixel for uint256;\n    using Event for uint256;\n\n    /**\n     * @notice\n     * @dev\n     */\n    function combine(\n        uint256 featureLen,\n        uint8 width,\n        uint256 descriptor,\n        Version.Memory[][] memory versions\n    ) internal view returns (IDotNugg.Matrix memory resa) {\n        IDotNugg.Canvas memory canvas;\n        canvas.matrix = Matrix.create(width, width);\n        canvas.receivers = new IDotNugg.Anchor[](featureLen);\n        IDotNugg.Coordinate memory coord;\n        coord.a = width / 2 + 1;\n        coord.b = width / 2 + 1;\n        coord.exists = true;\n        IDotNugg.Rlud memory r;\n        for (uint8 i = 0; i < featureLen; i++) {\n            canvas.receivers[i] = IDotNugg.Anchor({coordinate: coord, radii: r});\n        }\n        canvas.matrix.width = width;\n        canvas.matrix.height = width;\n\n        IDotNugg.Mix memory mix;\n        mix.matrix = Matrix.create(width, width);\n        mix.receivers = new IDotNugg.Anchor[](featureLen);\n\n        // IDotNugg.Item[] memory items = Decoder.parseItems(inputs, featureLen);\n\n        for (uint8 i = 0; i < versions.length; i++) {\n            if (versions[i].length > 0) {\n                setMix(mix, versions[i], pickVersionIndex(canvas, versions[i]));\n\n                formatForCanvas(canvas, mix);\n\n                postionForCanvas(canvas, mix, descriptor);\n\n                mergeToCanvas(canvas, mix);\n\n                calculateReceivers(mix);\n\n                updateReceivers(canvas, mix);\n            }\n        }\n\n        return canvas.matrix;\n    }\n\n    /**\n     * @notice\n     * @devg\n     */\n    function postionForCanvas(\n        IDotNugg.Canvas memory canvas,\n        IDotNugg.Mix memory mix,\n        uint256 descriptor\n    ) internal view {\n        IDotNugg.Anchor memory receiver = canvas.receivers[mix.feature];\n        IDotNugg.Anchor memory anchor = mix.version.anchor;\n\n        // (bool overExists, uint256 overX, uint256 overY) = Descriptor.receiverOverride(descriptor, mix.feature);\n\n        // if (overExists) {\n        //     receiver.coordinate.a = uint8(overX);\n        //     receiver.coordinate.b = uint8(overY);\n        // }\n\n        uint256(mix.feature).log('mix.feature');\n\n        uint256(anchor.coordinate.a).log(\n            'anchor.coordinate.a',\n            anchor.coordinate.b,\n            'anchor.coordinate.b',\n            receiver.coordinate.a,\n            'receiver.coordinate.a',\n            receiver.coordinate.b,\n            'receiver.coordinate.b'\n        );\n        mix.xoffset = receiver.coordinate.a > anchor.coordinate.a ? receiver.coordinate.a - anchor.coordinate.a : 0;\n        mix.yoffset = receiver.coordinate.b > anchor.coordinate.b ? receiver.coordinate.b - anchor.coordinate.b : 0;\n\n        canvas.matrix.moveTo(mix.xoffset, mix.yoffset, mix.matrix.width, mix.matrix.height);\n    }\n\n    /**\n     * @notice\n     * @dev\n     */\n    function formatForCanvas(IDotNugg.Canvas memory canvas, IDotNugg.Mix memory mix) internal pure {\n        IDotNugg.Anchor memory receiver = canvas.receivers[mix.feature];\n        IDotNugg.Anchor memory anchor = mix.version.anchor;\n\n        if (mix.version.expanders.l != 0 && anchor.radii.l != 0 && anchor.radii.l <= receiver.radii.l) {\n            uint8 amount = receiver.radii.l - anchor.radii.l;\n            mix.matrix.addColumnsAt(mix.version.expanders.l - 1, amount);\n            anchor.coordinate.a += amount;\n            if (mix.version.expanders.r > 0) mix.version.expanders.r += amount;\n        }\n        if (mix.version.expanders.r != 0 && anchor.radii.r != 0 && anchor.radii.r <= receiver.radii.r) {\n            mix.matrix.addColumnsAt(mix.version.expanders.r - 1, receiver.radii.r - anchor.radii.r);\n        }\n        if (mix.version.expanders.d != 0 && anchor.radii.d != 0 && anchor.radii.d <= receiver.radii.d) {\n            uint8 amount = receiver.radii.d - anchor.radii.d;\n            mix.matrix.addRowsAt(mix.version.expanders.d, amount);\n            anchor.coordinate.b += amount;\n            if (mix.version.expanders.u > 0) mix.version.expanders.u += amount;\n        }\n        if (mix.version.expanders.u != 0 && anchor.radii.u != 0 && anchor.radii.u <= receiver.radii.u) {\n            mix.matrix.addRowsAt(mix.version.expanders.u, receiver.radii.u - anchor.radii.u);\n        }\n    }\n\n    /**\n     * @notice\n     * @dev\n     * makes the sorts versions\n     */\n    function pickVersionIndex(IDotNugg.Canvas memory canvas, Version.Memory[] memory versions) internal pure returns (uint8) {\n        require(versions.length > 0, 'CALC:PVI:0');\n        if (versions.length == 1) {\n            return 0;\n        }\n        uint8 index = uint8(versions.length) - 1;\n\n        uint256 feature = (versions[0].data >> 75) & ShiftLib.mask(3);\n\n        while (index > 0) {\n            uint256 bits = (versions[index].data >> 27) & ShiftLib.mask(24);\n            IDotNugg.Rlud memory anchorRadii = IDotNugg.Rlud({\n                r: uint8((bits >> 18) & ShiftLib.mask(6)),\n                l: uint8((bits >> 12) & ShiftLib.mask(6)),\n                u: uint8((bits >> 6) & ShiftLib.mask(6)),\n                d: uint8((bits) & ShiftLib.mask(6)),\n                exists: true\n            });\n\n            if (checkRluds(anchorRadii, canvas.receivers[feature].radii)) {\n                return index;\n            }\n            index = index - 1;\n        }\n\n        return 0;\n    }\n\n    function checkRluds(IDotNugg.Rlud memory r1, IDotNugg.Rlud memory r2) internal pure returns (bool) {\n        return (r1.r <= r2.r && r1.l <= r2.l) || (r1.u <= r2.u && r1.d <= r2.d);\n    }\n\n    /**\n     * @notice\n     * @dev done\n     * makes the sorts versions\n     */\n    function setMix(\n        IDotNugg.Mix memory res,\n        Version.Memory[] memory versions,\n        uint8 versionIndex\n    ) internal view {\n        uint256 radiiBits = (versions[versionIndex].data >> 27) & ShiftLib.mask(24);\n        uint256 expanderBits = (versions[versionIndex].data >> 3) & ShiftLib.mask(24);\n\n        (uint256 x, uint256 y) = Version.getAnchor(versions[versionIndex]);\n\n        (uint256 width, uint256 height) = Version.getWidth(versions[versionIndex]);\n\n        res.version.width = uint8(width);\n        res.version.height = uint8(height);\n        res.version.anchor = IDotNugg.Anchor({\n            radii: IDotNugg.Rlud({\n                r: uint8((radiiBits >> 18) & ShiftLib.mask(6)),\n                l: uint8((radiiBits >> 12) & ShiftLib.mask(6)),\n                u: uint8((radiiBits >> 6) & ShiftLib.mask(6)),\n                d: uint8((radiiBits >> 0) & ShiftLib.mask(6)),\n                exists: true\n            }),\n            coordinate: IDotNugg.Coordinate({a: uint8(x), b: uint8(y), exists: true})\n        });\n        res.version.expanders = IDotNugg.Rlud({\n            r: uint8((expanderBits >> 18) & ShiftLib.mask(6)),\n            l: uint8((expanderBits >> 12) & ShiftLib.mask(6)),\n            u: uint8((expanderBits >> 6) & ShiftLib.mask(6)),\n            d: uint8((expanderBits >> 0) & ShiftLib.mask(6)),\n            exists: true\n        });\n        res.version.calculatedReceivers = new IDotNugg.Coordinate[](8);\n\n        res.version.staticReceivers = new IDotNugg.Coordinate[](8);\n\n        for (uint256 i = 0; i < 8; i++) {\n            (uint256 _x, uint256 _y, bool exists) = Version.getReceiverAt(versions[versionIndex], i, false);\n            if (exists) {\n                res.version.staticReceivers[i].a = uint8(_x);\n                res.version.staticReceivers[i].b = uint8(_y);\n                res.version.staticReceivers[i].exists = true;\n            }\n        }\n\n        for (uint256 i = 0; i < 8; i++) {\n            (uint256 _x, uint256 _y, bool exists) = Version.getReceiverAt(versions[versionIndex], i, true);\n            if (exists) {\n                res.version.calculatedReceivers[i].a = uint8(_x);\n                res.version.calculatedReceivers[i].b = uint8(_y);\n                res.version.calculatedReceivers[i].exists = true;\n            }\n        }\n\n        // TODO - receivers?\n        res.xoffset = 0;\n        res.yoffset = 0;\n        res.receivers = new IDotNugg.Anchor[](res.receivers.length);\n        res.feature = uint8((versions[versionIndex].data >> 75) & ShiftLib.mask(3));\n        res.matrix.set(versions[versionIndex], width, height);\n    }\n\n    /**\n     * @notice done\n     * @dev\n     */\n    function updateReceivers(IDotNugg.Canvas memory canvas, IDotNugg.Mix memory mix) internal pure {\n        for (uint8 i = 0; i < mix.receivers.length; i++) {\n            IDotNugg.Anchor memory m = mix.receivers[i];\n            if (m.coordinate.exists) {\n                m.coordinate.a += mix.xoffset;\n                m.coordinate.b += mix.yoffset;\n                canvas.receivers[i] = m;\n            }\n        }\n    }\n\n    /**\n     * @notice done\n     * @dev\n     */\n    function mergeToCanvas(IDotNugg.Canvas memory canvas, IDotNugg.Mix memory mix) internal view {\n        // uint256 count;\n        uint256 count;\n        while (canvas.matrix.next() && mix.matrix.next()) {\n            uint256 canvasPixel = canvas.matrix.current();\n            uint256 mixPixel = mix.matrix.current();\n\n            // if (mixPixel != 0 || canvasPixel != 0) {\n            //     // assert(count++ < 100);\n            //     // mixPixel.log('mixPixel', mixPixel.z(), 'mixPixel.z()', canvasPixel.z(), 'canvasPixel.z()');\n            //     // canvasPixel.log('canvasPixel');\n            // }\n            // assert(mixPixel.e() && mixPixel.z() >= canvasPixel.z());\n\n            if (mixPixel.e() && mixPixel.z() >= canvasPixel.z()) {\n                // canvasPixel.z() = mixPixel.z();\n\n                canvas.matrix.setCurrent(Rgba.combine(canvasPixel, mixPixel));\n            }\n        }\n        canvas.matrix.moveBack();\n        canvas.matrix.resetIterator();\n        mix.matrix.resetIterator();\n    }\n\n    /**\n     * @notice poop\n     * @dev\n     */\n    function calculateReceivers(IDotNugg.Mix memory mix) internal pure {\n        Anchor.convertReceiversToAnchors(mix);\n    }\n\n    // you combine one by one, and as you combine, child refs get overridden\n\n    // function add(Combinable comb, )\n}\n// add parent refs, if any - will use ***REMOVED***s algo only for the canvas\n// the canvas will always be defined as the first, so if it isnt (will not happen for dotnugg), we define the center as all the child refs\n//  pick best version\n// figure out offset\n\n// function merge(Canvas memory canvas, Matrix memory versionMatrix) internal pure {\n//     for (int8 y = (canvas.matrix.data.length / 2) * -1; y <= canvas.matrix.data.length / 2; y++) {\n//         for (int8 x = (canvas.matrix.width / 2) * -1; x <= canvas.matrix[j].width / 2; x++) {\n//             Pixel memory canvas = canvas.matrix.at(x, y);\n//             Pixel memory addr = combinable.matrix.at(x, y);\n\n//             if (addr != 0 && addr.layer > canvas.layer) {\n//                 canvas.layer = addr.layer;\n//                 canvas.rgba = Colors.combine(canvas.rgba, add.rgba);\n//             }\n//         }\n//     }\n// }\n// Oh my god\n// Becky, look at her butt\n// Its so big\n// She looks like one of those rap guys girlfriends\n// Who understands those rap guys\n// They only talk to her because she looks like a total prostitute\n// I mean her butt\n// It's just so big\n// I can't believe it's so round\n// It's just out there\n// I mean, it's gross\n// Look, she's just so black\n\n// *rap*\n// I like big butts and I can not lie\n// You other brothers can't deny\n// That when a girl walks in with an itty bitty waist\n// And a round thing in your face\n// You get sprung\n// Wanna pull up tough\n// Cuz you notice that butt was stuffed\n// Deep in the jeans she's wearing\n// I'm hooked and I can't stop staring\n// Oh, baby I wanna get with ya\n// And take your picture\n// My homeboys tried to warn me\n// But that butt you got\n// Make Me so horney\n// Ooh, rump of smooth skin\n// You say you wanna get in my benz\n// Well use me use me cuz you aint that average groupy\n\n// I've seen them dancin'\n// The hell with romancin'\n// She's Sweat,Wet, got it goin like a turbo vette\n\n// I'm tired of magazines\n// Saying flat butts are the thing\n// Take the average black man and ask him that\n// She gotta pack much back\n\n// So Fellas (yeah) Fellas(yeah)\n// Has your girlfriend got the butt (hell yeah)\n// Well shake it, shake it, shake it, shake it, shake that healthy butt\n// Baby got back\n\n// (LA face with Oakland booty)\n\n// I like'em round and big\n// And when I'm throwin a gig\n// I just can't help myself\n// I'm actin like an animal\n// Now here's my scandal\n\n// I wanna get you home\n// And UH, double up UH UH\n// I aint talkin bout playboy\n// Cuz silicone parts were made for toys\n// I wannem real thick and juicy\n// So find that juicy double\n// Mixalot's in trouble\n// Beggin for a piece of that bubble\n// So I'm lookin' at rock videos\n// Knockin these bimbos walkin like hoes\n// You can have them bimbos\n// I'll keep my women like Flo Jo\n// A word to the thick soul sistas\n// I wanna get with ya\n// I won't cus or hit ya\n// But I gotta be straight when I say I wanna --\n// Til the break of dawn\n// Baby Got it goin on\n// Alot of pimps won't like this song\n// Cuz them punks lie to hit it and quit it\n// But I'd rather stay and play\n// Cuz I'm long and I'm strong\n// And I'm down to get the friction on\n\n// So ladies (yeah), Ladies (yeah)\n// Do you wanna roll in my Mercedes (yeah)\n// Then turn around\n// Stick it out\n// Even white boys got to shout\n// Baby got back\n\n// (LA face with the Oakland booty)\n\n// Yeah baby\n// When it comes to females\n// Cosmo ain't got nothin to do with my selection\n// 36-24-36\n// Only if she's 5'3\"\n\n// So your girlfriend throws a Honda\n// Playin workout tapes by Fonda\n// But Fonda ain't got a motor in the back of her Honda\n// My anaconda don't want none unless you've got buns hun\n// You can do side bends or sit-ups, but please don't lose that butt\n// Some brothers wanna play that hard role\n// And tell you that the butt ain't gold\n// So they toss it and leave it\n// And I pull up quick to retrieve it\n// So cosmo says you're fat\n// Well I ain't down with that\n// Cuz your waste is small and your curves are kickin\n// And I'm thinkin bout stickin\n// To the beanpole dames in the magazines\n// You aint it miss thing\n// Give me a sista I can't resist her\n// Red beans and rice did miss her\n// Some knucklehead tried to dis\n// Cuz his girls were on my list\n// He had game but he chose to hit 'em\n// And pulled up quick to get with 'em\n// So ladies if the butt is round\n// And you wanna triple X throw down\n// Dial 1-900-MIXALOT and kick them nasty thoughts\n// Baby got back\n// Baby got back\n// Little in tha middle but she got much back x4\n"
    },
    "contracts/src/logic/Matrix.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../interfaces/IDotNugg.sol';\nimport '../libraries/Bytes.sol';\nimport '../logic/Rgba.sol';\n\nimport '../types/Version.sol';\n\nlibrary Matrix {\n    using Bytes for bytes;\n    using Rgba for IDotNugg.Rgba;\n    using Event for uint256;\n    using Version for Version.Memory;\n\n    // function update(IDotNugg.Matrix memory matrix) internal pure returns (Version.Memory memory m) {\n    //     Version.initBigMatrix(m, matrix.width);\n\n    //     resetIterator(matrix);\n\n    //     for (uint256 index = 0; index < uint256(matrix.width) * uint256(matrix.height); index++) {\n    //         Matrix.next(matrix);\n    //         IDotNugg.Pixel memory pix = Matrix.current(matrix);\n\n    //         // if (pix.exists) {\n    //         uint256 color = (uint256(pix.rgba.r) << 24);\n    //         color |= (uint256(pix.rgba.g) << 16);\n    //         color |= (uint256(pix.rgba.b) << 8);\n    //         color |= (uint256(pix.rgba.a));\n    //         Version.setBigMatrixPixelAt(m, index, color);\n    //         // }\n    //     }\n\n    //     m.data |= (uint256(matrix.width) << 63);\n    //     m.data |= (uint256(matrix.height) << 69);\n    // }\n\n    function create(uint8 width, uint8 height) internal pure returns (IDotNugg.Matrix memory res) {\n        require(width % 2 == 1 && height % 2 == 1, 'ML:C:0');\n\n        Version.initBigMatrix(res.version, width);\n        res.version.setWidth(width, height);\n\n        // res.data = new IDotNugg.Pixel[][](height);\n        // for (uint8 i = 0; i < height; i++) {\n        //     res.data[i] = new IDotNugg.Pixel[](width);\n        // }\n    }\n\n    function moveTo(\n        IDotNugg.Matrix memory matrix,\n        uint8 xoffset,\n        uint8 yoffset,\n        uint8 width,\n        uint8 height\n    ) internal pure {\n        matrix.currentUnsetX = xoffset;\n        matrix.currentUnsetY = yoffset;\n        matrix.startX = xoffset;\n        matrix.width = width + xoffset;\n        matrix.height = height + yoffset;\n    }\n\n    function next(IDotNugg.Matrix memory matrix) internal pure returns (bool res) {\n        res = next(matrix, matrix.width);\n    }\n\n    function next(IDotNugg.Matrix memory matrix, uint8 width) internal pure returns (bool res) {\n        if (matrix.init) {\n            if (width <= matrix.currentUnsetX + 1) {\n                if (matrix.height == matrix.currentUnsetY + 1) {\n                    return false;\n                }\n                matrix.currentUnsetX = matrix.startX; // 0 by default\n                matrix.currentUnsetY++;\n            } else {\n                matrix.currentUnsetX++;\n            }\n        } else {\n            matrix.init = true;\n        }\n        res = true;\n    }\n\n    function current(IDotNugg.Matrix memory matrix) internal pure returns (uint256 res) {\n        res = matrix.version.getBigMatrixPixelAt(matrix.currentUnsetX, matrix.currentUnsetY);\n    }\n\n    function setCurrent(IDotNugg.Matrix memory matrix, uint256 pixel) internal pure {\n        matrix.version.setBigMatrixPixelAt(matrix.currentUnsetX, matrix.currentUnsetY, pixel);\n    }\n\n    function resetIterator(IDotNugg.Matrix memory matrix) internal pure {\n        matrix.currentUnsetX = 0;\n        matrix.currentUnsetY = 0;\n        matrix.startX = 0;\n        matrix.init = false;\n    }\n\n    function moveBack(IDotNugg.Matrix memory matrix) internal pure {\n        (uint256 width, uint256 height) = matrix.version.getWidth();\n        matrix.width = uint8(width);\n        matrix.height = uint8(height);\n    }\n\n    function set(\n        IDotNugg.Matrix memory matrix,\n        Version.Memory memory data,\n        uint256 groupWidth,\n        uint256 groupHeight\n    ) internal view {\n        matrix.height = uint8(groupHeight);\n        uint256 feature = data.getFeature();\n\n        for (uint256 y = 0; y < groupHeight; y++) {\n            for (uint256 x = 0; x < groupWidth; x++) {\n                next(matrix, uint8(groupWidth));\n                uint256 col = Version.getPixelAt(data, x, y);\n                if (col != 0) {\n                    (, uint256 color, uint256 zindex) = Version.getPalletColorAt(data, col);\n                    // (zindex).log('zindex', (zindex << 32), '<< 32', (feature << 36) | (zindex << 32) | color, 'whole');\n                    setCurrent(matrix, (feature << 36) | (zindex << 32) | color);\n                } else {\n                    setCurrent(matrix, 0x0000000000);\n                }\n            }\n        }\n\n        // require(totalLength % groupWidth == 0, 'MTRX:SET:0');\n        // require(totalLength / groupWidth == groupHeight, 'MTRX:SET:1');\n\n        matrix.width = uint8(groupWidth);\n        // // matrix.height = uint8(totalLength / groupWidth);\n\n        resetIterator(matrix);\n    }\n\n    function addRowsAt(\n        IDotNugg.Matrix memory matrix, /// cowboy hat\n        uint8 index,\n        uint8 amount\n    ) internal pure {\n        // require(index < matrix.data[0].length, 'MAT:ACA:0');\n        for (uint256 i = 0; i < matrix.height; i++) {\n            for (uint256 j = matrix.height; j > index; j--) {\n                if (j < index) break;\n                matrix.version.setBigMatrixPixelAt(i, j + amount, matrix.version.getBigMatrixPixelAt(i, j));\n            }\n            // \"<=\" is because this loop needs to run [amount] times\n            for (uint256 j = index + 1; j <= index + amount; j++) {\n                matrix.version.setBigMatrixPixelAt(i, j, matrix.version.getBigMatrixPixelAt(i, index));\n            }\n        }\n        matrix.height += amount;\n    }\n\n    function addColumnsAt(\n        IDotNugg.Matrix memory matrix, /// cowboy hat\n        uint8 index,\n        uint8 amount\n    ) internal pure {\n        // require(index < matrix.data[0].length, 'MAT:ACA:0');\n        for (uint256 i = 0; i < matrix.width; i++) {\n            for (uint256 j = matrix.width; j > index; j--) {\n                if (j < index) break;\n                matrix.version.setBigMatrixPixelAt(j + amount, i, matrix.version.getBigMatrixPixelAt(j, i));\n            }\n            // \"<=\" is because this loop needs to run [amount] times\n            for (uint256 j = index + 1; j <= index + amount; j++) {\n                matrix.version.setBigMatrixPixelAt(j, i, matrix.version.getBigMatrixPixelAt(index, i));\n            }\n        }\n        matrix.width += amount;\n    }\n}\n"
    },
    "contracts/src/logic/Svg.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../libraries/Uint.sol';\nimport '../../test/Event.sol';\n\nlibrary Svg {\n    using Uint256 for uint256;\n    using Event for uint256;\n\n    function getPixelAt(\n        uint256[] memory file,\n        uint256 x,\n        uint256 y,\n        uint256 width\n    ) internal pure returns (uint256 res) {\n        uint256 index = x + (y * width);\n\n        res = (file[index / 6] >> (40 * (index % 6))) & 0xffffffff;\n    }\n\n    function buildSvg(\n        uint256[] memory file,\n        uint256 width,\n        uint256 height\n    ) internal view returns (bytes memory res) {\n        bytes memory header = abi.encodePacked(\n            hex'3c7376672076696577426f783d2730203020', //\"<svg Box='0 0 \",\n            (10 * width).toString(),\n            hex'20', // ' ',\n            (10 * width).toString(),\n            hex'20272077696474683d27', //\"' width='\",\n            (10 * width).toString(),\n            hex'27206865696768743d27', //  \"' height='\",\n            (10 * width).toString(),\n            hex'2720786d6c6e733d27687474703a2f2f7777772e77332e6f72672f323030302f7376672720786d6c6e733a786c696e6b3d27687474703a2f2f7777772e77332e6f72672f313939392f786c696e6b273e5c6e' // \"' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'>\\n\"\n        );\n\n        bytes memory footer = hex'3c2f7376673e';\n\n        uint256 last = getPixelAt(file, 0, 0, width);\n        uint256 count = 1;\n\n        // bytes[] memory rects = new bytes[](35);\n        bytes memory body;\n\n        for (uint256 y = 0; y < height; y++) {\n            for (uint256 x = 0; x < height; x++) {\n                if (y == 0 && x == 0) x++;\n                uint256 curr = getPixelAt(file, x, y, width);\n                if (curr == last) {\n                    count++;\n                    continue;\n                } else {\n                    // curr.log('yup');\n                    // rects[index++] = getRekt(last, x - count, y, count, 1);\n                    body = abi.encodePacked(body, getRekt(last, (x - count) * 10, y * 10, 1 * 10, count * 10));\n                    last = curr;\n                    count = 1;\n                }\n            }\n            // rects[index++] = getRekt(last, 33 - count, y, count, 1);\n            body = abi.encodePacked(body, getRekt(last, (width - count) * 10, y * 10, 1 * 10, count * 10));\n            last = 0;\n            count = 0;\n        }\n\n        res = abi.encodePacked(header, body, footer);\n    }\n\n    function getRekt(\n        uint256 pixel,\n        uint256 x,\n        uint256 y,\n        uint256 xlen,\n        uint256 ylen\n    ) internal pure returns (bytes memory res) {\n        if (pixel & 0xff == 0) return '';\n\n        res = abi.encodePacked(\n            \"\\t<rect fill='#\",\n            pixel.toHexStringNoPrefix(4),\n            hex'2720783d27',\n            x.toAscii(),\n            hex'2720793d27',\n            y.toAscii(),\n            hex'27206865696768743d27',\n            xlen.toAscii(),\n            hex'272077696474683d27',\n            ylen.toAscii(),\n            \"'/>\\n\"\n        );\n    }\n}\n"
    },
    "contracts/src/v2/Merge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../types/Version.sol';\nimport '../../test/Event.sol';\n\nlibrary Merge {\n    // using Version for Version.Memory;\n    // using Event for uint256[];\n    // using Event for uint256;\n    // function begin(Version.Memory[][] memory versions, uint256 width) internal view returns (Version.Memory memory res) {\n    //     // figure out the order  - loop theorugh them \"backwards\" pixel by pixel, we can reduce the amount of times we have to loop through everything\n    //     for (uint256 i = 0; i < 8; i++) {\n    //         uint256 num = width / 2 + 1;\n    //         res.setReceiverAt(i, false, num, num);\n    //     }\n    //     uint256 sorter;\n    //     uint256 zcheck;\n    //     // TODO flip these loops - will be able to set receivers here\n    //     // finalize receivers\n    //     for (uint256 i = 0; i < versions.length; i++) {\n    //         uint256 z = versions[i][0].getZ();\n    //         z.log('z');\n    //         sorter = addToSort(sorter, i, z);\n    //         versions[i][0].receivers.log('versions[i][0].receivers');\n    //         for (uint256 j = 0; j < 8; j++) {\n    //             (uint256 x, uint256 y, bool exists) = versions[i][0].getReceiverAt(j, false);\n    //             if (!exists) continue;\n    //             zcheck.log('zcheck');\n    //             if (z > (zcheck >> (j * 3)) & ShiftLib.mask(3)) {\n    //                 zcheck = (zcheck & (ShiftLib.mask(3) << (j * 3))) | (z << (j * 3));\n    //                 res.setReceiverAt(j, false, x, y);\n    //             }\n    //         }\n    //     }\n    //     res.receivers.log('res.receivers');\n    //     for (uint256 i = 0; i < versions.length; i++) {\n    //         (bool negX, uint256 diffX, bool negY, uint256 diffY) = res.getDiffOfReceiverAt(versions[i][0]);\n    //         // negX.log('negX', diffX, 'diffX', i, 'i');\n    //         // negY.log('negY', diffY, 'diffY', i, 'i');\n    //         diffX.log('diffX');\n    //         diffX.log('diffY');\n    //         versions[i][0].setOffset(negX, diffX, negY, diffY);\n    //     }\n    //     res.initBigMatrix(width);\n    //     for (uint256 i = 0; i < width * width; i++) {\n    //         uint256 workingColor;\n    //         for (uint256 j = 0; j < versions.length; j++) {\n    //             // sorter.log('sorter', i, 'i', j, 'j');\n    //             (bool exists1, uint256 feature, ) = getFromSorter(sorter, j);\n    //             if (!exists1) break;\n    //             // if (i > 200) assert(false);\n    //             (bool exists2, uint256 key) = versions[feature][0].getPixelAtPositionWithOffset(i);\n    //             if (!exists2) continue;\n    //             (, uint256 color, ) = versions[feature][0].getPalletColorAt(key);\n    //             if (workingColor > 0) {\n    //                 // mix set with color\n    //                 break;\n    //             }\n    //             workingColor = color;\n    //             // workingColor.log('workingColor', feature, 'feature', key, 'key');\n    //             if (workingColor & 0xff == 0xff) break;\n    //             continue;\n    //         }\n    //         res.setBigMatrixPixelAt(i, workingColor);\n    //         // assert(false);\n    //     }\n    //     res.bigmatrix.log('bigmatrix');\n    //     // add pallet to end of res's pallet\n    //     // loop through each pixel in res\n    //     // loop through all versions (sorted) and add first color to the matrix\n    //     //\n    //     // (uint256 width, uint256 height) = res.getWidth();\n    //     // calculate offset, sort values values by z, and determine if we need to\n    //     // going deeper as far as a color is conserned is only doable when we are looping thorough\n    //     // for (uint256 i = 0; i < versions.length; i++) {\n    //     //     (uint256 x, uint256 y, uint256 z, ) = versions[i][0].getAnchor();\n    //     //     //\n    //     // }\n    //     // TODO decide if we want to use multiple versions, and then what to do about it\n    //     // loop through them and put all of them on the first one\n    //     // find the receivers to give all of them an offset\n    //     // just take highest level from each of them\n    //     // give all of them an offset\n    //     // for (uint256 )\n    // }\n    // function getFromSorter(uint256 input, uint256 index)\n    //     internal\n    //     pure\n    //     returns (\n    //         bool exists,\n    //         uint256 feature,\n    //         uint256 z\n    //     )\n    // {\n    //     uint256 curr = (input >> (index * 9)) & ShiftLib.mask(9);\n    //     exists = (curr >> 8) & 0x1 == 0x1;\n    //     if (exists) {\n    //         feature = (curr >> 4) & 0xf;\n    //         z = curr & 0xf;\n    //     }\n    // }\n    // function addToSort(\n    //     uint256 input,\n    //     uint256 inFeature,\n    //     uint256 inZ\n    // ) internal pure returns (uint256 res) {\n    //     res = input;\n    //     // 1 bit exists\n    //     // 4 bit feature\n    //     // 4 bit z\n\n    //     uint256 i;\n    //     for (i = 0; i < 8; i++) {\n    //         uint256 curr = (res >> (i * 9)) & ShiftLib.mask(9);\n    //         if (curr >> 8 == 0x1) {\n    //             // uint256 feautre = (curr >> 4) & 0xf;\n    //             uint256 z = curr & 0xf;\n    //             if (z <= inZ) {\n    //                 res = ((res << 9) & ~ShiftLib.mask(9 * i)) | (input & ShiftLib.mask(9 * (i)));\n    //                 res |= ((0x1 << 8) | (inFeature << 4) | inZ) << (9 * i);\n    //                 break;\n    //             }\n    //         } else {\n    //             res |= ((0x1 << 8) | (inFeature << 4) | inZ) << (9 * i);\n    //             break;\n    //         }\n    //     }\n\n    // }\n}\n"
    },
    "contracts/src/libraries/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\n/**\n * @title Base64\n * @author Nugg Labs - @danny7even & @dub6ix\n * @notice library for encoding bytes into base64\n */\nlibrary Base64 {\n    string internal constant _TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    string internal constant PREFIX_JSON = 'data:application/json;base64,';\n    string internal constant PREFIX_DOTNUGG = 'data:image/dotnugg;base64,';\n    string internal constant PREFIX_SVG = 'data:image/svg+xml;base64,';\n\n    /**\n     * @notice wrapper for _encode for svg data\n     * @param data bytes to encode\n     * @return base64 string representation of input bytes, prefixed with json base64 prefix\n     */\n    function encode(bytes memory data, string memory file) internal pure returns (string memory) {\n        return string(abi.encodePacked('data:', file, ';base64,', _encode(data)));\n    }\n\n    /**\n     * @notice Encodes some bytes in base64\n     * @param data bytes to encode\n     * @return base64 string representation of input bytes\n     * @dev Credit to Brecht Devos - <brecht@loopring.org> - under MIT license https://github.com/Brechtpd/base64/blob/main/base64.sol\n     * @dev modified for solidity v8\n     */\n    function _encode(bytes memory data) internal pure returns (bytes memory) {\n        if (data.length == 0) return '';\n\n        // load the table into memory\n        string memory table = _TABLE;\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n\n        // add some extra buffer at the end required for the writing\n        bytes memory result = new bytes(encodedLen + 32);\n\n        assembly {\n            // set the actual output length\n            mstore(result, encodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 3 bytes at a time\n            for {\n\n            } lt(dataPtr, endPtr) {\n\n            } {\n                dataPtr := add(dataPtr, 3)\n\n                // read 3 bytes\n                let input := mload(dataPtr)\n\n                // write 4 characters\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(6, input), 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(input, 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n            }\n\n            // padding with '='\n            switch mod(mload(data), 3)\n            case 1 {\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\n            }\n            case 2 {\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\n            }\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/src/logic/Rgba.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../libraries/Bytes.sol';\nimport '../interfaces/IDotNugg.sol';\nimport '../types/Pixel.sol';\n\nlibrary Rgba {\n    using Bytes for bytes;\n    using Pixel for uint256;\n    struct RGBA16 {\n        uint16 r;\n        uint16 g;\n        uint16 b;\n        uint16 a;\n    }\n\n    function combine(IDotNugg.Rgba memory base, IDotNugg.Rgba memory mix) internal pure {\n        // if (mix.a == 255 || base.a == 0) {\n        if (true) {\n            base.r = mix.r;\n            base.g = mix.g;\n            base.b = mix.b;\n            base.a = mix.a;\n            return;\n        }\n\n        RGBA16 memory baseRGB = RGBA16({r: uint16(base.r), g: uint16(base.g), b: uint16(base.b), a: uint16(base.a)});\n        RGBA16 memory mixRGB = RGBA16({r: uint16(mix.r), g: uint16(mix.g), b: uint16(mix.b), a: uint16(mix.a)});\n\n        // uint8 alpha = uint8(255 - (((255 - baseRGB.a) * (255 - mixRGB.a)) / 255));\n        base.r = uint8((baseRGB.r * (255 - mixRGB.a) + mixRGB.r * mixRGB.a) / 255);\n        base.g = uint8((baseRGB.g * (255 - mixRGB.a) + mixRGB.g * mixRGB.a) / 255);\n        base.b = uint8((baseRGB.b * (255 - mixRGB.a) + mixRGB.b * mixRGB.a) / 255);\n        base.a = 255;\n        //   return IDotNugg.Rgba({r: r, g: g, b: b, a: 255});\n    }\n\n    function combine(uint256 base, uint256 mix) internal pure returns (uint256 res) {\n        // if (mix.a == 255 || base.a == 0) {\n        if (true) {\n            res = mix;\n            return res;\n        }\n\n        // RGBA16 memory baseRGB = RGBA16({r: uint16(base.r()), g: uint16(base.g), b: uint16(base.b), a: uint16(base.a)});\n        // RGBA16 memory mixRGB = RGBA16({r: uint16(mix.r()), g: uint16(mix.g), b: uint16(mix.b), a: uint16(mix.a)});\n\n        // uint8 alpha = uint8(255 - (((255 - baseRGB.a) * (255 - mixRGB.a)) / 255));\n\n        // base.r() = uint8((base.r() * (255 - mix.a()) + mix.r() * mix.a()) / 255);\n        // base.g = uint8((base.g() * (255 - mix.a()) + mix.g() * mix.a()) / 255);\n        // base.b = uint8((base.b() * (255 - mix.a()) + mix.b() * mix.a()) / 255);\n        // base.a = 255;\n\n        //   return IDotNugg.Rgba({r: r, g: g, b: b, a: 255});\n    }\n\n    function toUint64(IDotNugg.Rgba memory base) internal pure returns (uint64 res) {\n        bytes memory input = abi.encodePacked(base.r, base.g, base.b, base.a);\n        return input.toUint64(0);\n    }\n\n    function toAscii(IDotNugg.Rgba memory base) internal pure returns (string memory res) {\n        bytes memory input = abi.encodePacked(base.r, base.g, base.b, base.a);\n        return input.toAscii();\n    }\n\n    function equalssss(IDotNugg.Rgba memory base, IDotNugg.Rgba memory next) internal pure returns (bool res) {\n        res = base.a == next.a && base.r == next.r && base.g == next.g && base.b == next.b;\n    }\n}\n"
    },
    "contracts/src/logic/Anchor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../interfaces/IDotNugg.sol';\nimport './Matrix.sol';\n\nlibrary Anchor {\n    using Matrix for IDotNugg.Matrix;\n    using Version for Version.Memory;\n\n    /*\n     * @notice AKA fuck\n     * @dev this is where we implement the logic you wrote in go\n     */\n\n    function convertReceiversToAnchors(IDotNugg.Mix memory mix) internal pure {\n        IDotNugg.Coordinate[] memory anchors;\n        uint8 stat = 0;\n        uint8 cal = 0;\n\n        for (uint8 i = 0; i < mix.version.staticReceivers.length; i++) {\n            IDotNugg.Coordinate memory coordinate;\n            if (mix.version.staticReceivers[i].exists) {\n                stat++;\n                coordinate = mix.version.staticReceivers[i];\n                mix.receivers[i].coordinate.a = coordinate.b;\n                mix.receivers[i].coordinate.b = coordinate.a;\n                mix.receivers[i].coordinate.exists = true;\n            } else if (mix.version.calculatedReceivers[i].exists) {\n                // if (mix.feature != 0) continue;\n\n                cal++;\n                if (anchors.length == 0) anchors = getAnchors(mix.matrix);\n                coordinate = calculateReceiverCoordinate(mix, mix.version.calculatedReceivers[i], anchors);\n                fledgeOutTheRluds(mix, coordinate, i);\n            }\n        }\n    }\n\n    // receiver := { feature: EYES, zindex: 2, yoffset: +2 }\n    // receiver := { feature: EARS, zindex: 2, yoffset: +2 }\n    // receiver := { feature: GLASSES, zindex: 2, yoffset: +2 }\n    // receiver := { feature: MOUTH, zindex: 3, yoffset: +0 }\n    // receiver := { feature: HAIR, zindex: 1, yoffset: +1 }\n    // receiver := { feature: SAUCE, zindex: 4, yoffset: +0 }\n    // receiver := { feature: HAT, zindex: 1, yoffset: +1 }\n    // receiver := { feature: SPECIAL, zindex: 0, yoffset: +0 }\n\n    function fledgeOutTheRluds(\n        IDotNugg.Mix memory mix,\n        IDotNugg.Coordinate memory coordinate,\n        uint8 index\n    ) internal pure {\n        IDotNugg.Rlud memory radii;\n\n        while (coordinate.a < mix.matrix.width - 1 && mix.matrix.version.bigMatrixHasPixelAt(coordinate.a + (radii.r + 1), coordinate.b)) {\n            radii.r++;\n        }\n        while (coordinate.a != 0 && coordinate.a >= (radii.l + 1) && mix.matrix.version.bigMatrixHasPixelAt(coordinate.a - (radii.l + 1), coordinate.b)) {\n            radii.l++;\n        }\n        while (coordinate.b != 0 && coordinate.b >= (radii.u + 1) && mix.matrix.version.bigMatrixHasPixelAt(coordinate.a, coordinate.b - (radii.u + 1))) {\n            radii.u++;\n        }\n        while (coordinate.b < mix.matrix.height - 1 && mix.matrix.version.bigMatrixHasPixelAt(coordinate.a, coordinate.b + (radii.d + 1))) {\n            radii.d++;\n        }\n\n        if (!mix.receivers[index].coordinate.exists) {\n            mix.receivers[index] = IDotNugg.Anchor({radii: radii, coordinate: coordinate});\n        }\n    }\n\n    function calculateReceiverCoordinate(\n        IDotNugg.Mix memory mix,\n        IDotNugg.Coordinate memory calculatedReceiver,\n        IDotNugg.Coordinate[] memory anchors\n    ) internal pure returns (IDotNugg.Coordinate memory coordinate) {\n        coordinate.a = anchors[calculatedReceiver.a].a;\n        coordinate.b = anchors[calculatedReceiver.a].b;\n        coordinate.exists = true;\n\n        if (calculatedReceiver.b < 32) {\n            coordinate.b = coordinate.b - calculatedReceiver.b;\n        } else {\n            coordinate.b = coordinate.b + (calculatedReceiver.b - 32);\n        }\n\n        while (!mix.matrix.version.bigMatrixHasPixelAt(coordinate.a, coordinate.b)) {\n            if (anchors[0].b > coordinate.b) {\n                coordinate.b++;\n            } else {\n                coordinate.b--;\n            }\n        }\n        return coordinate;\n    }\n\n    function getAnchors(IDotNugg.Matrix memory matrix) internal pure returns (IDotNugg.Coordinate[] memory anchors) {\n        (uint8 topOffset, uint8 bottomOffset, IDotNugg.Coordinate memory center) = getBox(matrix);\n\n        anchors = new IDotNugg.Coordinate[](5);\n\n        anchors[0] = center; // center\n\n        anchors[1] = IDotNugg.Coordinate({a: center.a, b: center.b - topOffset, exists: true}); // top\n\n        uint8 upperOffset = topOffset;\n        if (upperOffset % 2 != 0) {\n            upperOffset++;\n        }\n        anchors[2] = IDotNugg.Coordinate({a: center.a, b: center.b - (upperOffset / 2), exists: true}); // inner top\n\n        uint8 lowerOffset = bottomOffset;\n        if (lowerOffset % 2 != 0) {\n            lowerOffset++;\n        }\n        anchors[3] = IDotNugg.Coordinate({a: center.a, b: center.b + (lowerOffset / 2), exists: true}); // inner bottom\n\n        anchors[4] = IDotNugg.Coordinate({a: center.a, b: center.b + bottomOffset, exists: true}); // bottom\n    }\n\n    function getBox(IDotNugg.Matrix memory matrix)\n        internal\n        pure\n        returns (\n            uint8 topOffset,\n            uint8 bottomOffset,\n            IDotNugg.Coordinate memory center\n        )\n    {\n        center.a = (matrix.width) / 2;\n        center.b = (matrix.height) / 2;\n        center.exists = true;\n\n        bool topFound = false;\n        bool bottomFound = false;\n        bool sideFound = false;\n        bool shouldExpandSide = true;\n\n        topOffset = 1;\n        bottomOffset = 1;\n        uint8 sideOffset = 1;\n\n        bool allFound = false;\n\n        while (!allFound) {\n            if (shouldExpandSide = !shouldExpandSide && !sideFound) {\n                if (\n                    matrix.version.bigMatrixHasPixelAt(center.a - (sideOffset + 1), center.b - topOffset) &&\n                    // potential top left\n                    matrix.version.bigMatrixHasPixelAt(center.a + (sideOffset + 1), center.b - topOffset) &&\n                    // potential top right\n                    matrix.version.bigMatrixHasPixelAt(center.a - (sideOffset + 1), center.b + bottomOffset) &&\n                    // potential bot left\n                    matrix.version.bigMatrixHasPixelAt(center.a + (sideOffset + 1), center.b + bottomOffset)\n                    // potential bot right\n                ) {\n                    sideOffset++;\n                } else {\n                    sideFound = true;\n                }\n            }\n            if (!topFound) {\n                if (\n                    center.b - topOffset > 0 &&\n                    matrix.version.bigMatrixHasPixelAt(center.a - sideOffset, center.b - (topOffset + 1)) &&\n                    // potential top left\n                    matrix.version.bigMatrixHasPixelAt(center.a + sideOffset, center.b - (topOffset + 1))\n                    // potential top right\n                ) {\n                    topOffset++;\n                } else {\n                    topFound = true;\n                }\n            }\n            if (!bottomFound) {\n                if (\n                    center.b + bottomOffset < matrix.height - 1 &&\n                    matrix.version.bigMatrixHasPixelAt(center.a - sideOffset, center.b + (bottomOffset + 1)) &&\n                    // potential bot left\n                    matrix.version.bigMatrixHasPixelAt(center.a + sideOffset, center.b + (bottomOffset + 1))\n                    // potenetial bot right\n                ) {\n                    bottomOffset++;\n                } else {\n                    bottomFound = true;\n                }\n            }\n            if (bottomFound && topFound && sideFound) allFound = true;\n        }\n\n        if (topOffset != bottomOffset) {\n            uint8 newHeight = topOffset + bottomOffset + 1;\n            uint8 relativeCenter = (newHeight % 2 == 0 ? newHeight : newHeight + 1) / 2;\n            uint8 newCenter = relativeCenter + center.b - 1 - topOffset;\n            if (newCenter > center.b) {\n                uint8 diff = newCenter - center.b;\n                topOffset += diff;\n                bottomOffset > diff ? bottomOffset = bottomOffset - diff : bottomOffset = diff - bottomOffset;\n            } else {\n                uint8 diff = center.b - newCenter;\n                topOffset > diff ? topOffset = topOffset - diff : topOffset = diff - topOffset;\n                bottomOffset += diff;\n            }\n            center.b = newCenter;\n        }\n    }\n}\n// Whatcha gonna do with all that junk\n// All that junk inside your trunk\n// I'ma get get get get you drunk\n// Get you love drunk off my hump\n// My hump my hump my hump my hump my hump\n// My hump my hump my hump my lovely little lumps\n// Check it out\n// I drive these brothers crazy\n// I do it on the daily\n// They treat me really nicely\n// They buy me all these ice\n// Dolce and Gabbana\n// Fendi and Madonna\n// Caring they be sharin'\n// All their money got me wearing fly\n// Whether I ain't askin'\n// They say they love mah ass in\n// Seven jeans\n// True religion\n// I say no\n// But they keep givin'\n// So I keep on takin'\n// And no I ain't takin'\n// We can keep on datin'\n// Now keep on demonstratin'\n// My love my love my love my love\n// You love my lady lumps\n// My hump my hump my hump\n// My humps they got you\n// She's got me spending\n// Oh, spending all your money on me\n// And spending time on me\n// She's got me spending\n// Oh, spending all your money on me\n// Uh on me on me\n// Whatcha gonna do with all that junk\n// All that junk inside that trunk\n// I'm a get get get get you drunk\n// Get you love drunk off my hump\n// Whatcha gonna do with all that ass\n// All that ass inside your jeans\n// I'm a make make make make you scream\n// Make you scream make you scream\n// 'Cause of my humps my hump my hump my hump\n// My hump my hump my hump my lovely lady lumps\n// Check it out\n// I met a girl down at the disco\n// She said hey hey hey ya lets go\n// I can be ya baby, you could be my honey\n// Let's spend time not money\n// And mix your milk with my coco puff\n// Milky milky coco\n// Mix your milk with my coco puff\n// Milky milky\n// Right\n// They say I'm really sexy\n// The boys they wanna sex me\n// They always standin' next to me\n// Always dancin' next to me\n// Tryin' a feel my hump hump\n// Lookin' at my lump lump\n// You can look but you can't touch it\n// If you touch it\n// I'm a start some drama\n// You don't want no drama\n// No no drama no no no no drama\n// So don't pull on my hand boy\n// You ain't my man boy\n// I'm just tryin' a dance boy\n// And move my hump\n// My hump my hump my hump my hump\n// My hump my hump my hump my hump my hump my hump\n// My lovely lady lumps\n// My lovely lady lumps my lovely lady lumps\n// In the back and in the front\n// My loving got you\n// She's got me spending\n// Oh, spending all your money on me\n// And spending time on me\n// She's got me spending\n// Oh, spending all your money on me\n// Uh on me on me\n// Whatcha gonna do with all that junk\n// All that junk inside that trunk\n// I'm a get get get get you drunk\n// Get you love drunk off my hump\n// Whatcha gonna do with all that ass\n// All that ass inside your jeans\n// I'm a make make make make you scream\n// Make you scream make you scream\n// Whatcha gonna do with all that junk\n// All that junk inside that trunk\n// I'm a get get get get you drunk\n// Get you love drunk off this hump\n// Whatcha gonna do with all that breast\n// All that breast inside that shirt\n// I'm a make make make make you work\n// Make you work work make you work\n// She's got me spending\n// Oh, spending all your money on me\n// And spending time on me\n// She's got me spending\n// Oh, spending all your money on me\n// Uh on me on me\n"
    },
    "contracts/src/types/Descriptor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// 1.5 x each feature for a coordinate (0.75 x 2)\n// 2 byte each feature for expanders coordinate (16, 16, 16, 16)\n// 1 byte each feature for expanders amount (4, 4, 4, 4)\n\n// 3 | 1/2 bytes - base ---- 8 | .5 --- 8 | .5   ---- 1 vars\n\n// 8 | 1 bytes - head\n// 8 | 1 bytes - eyes\n// 8 | 1 bytes - mouth\n// 8 | 1 bytes - back\n// 8 | 1 bytes - hair\n// 8 | 1 bytes - neck ---- 48 | 6 --- 51 | 6.5    ----- 6 vars\n\n// 8 | 1 bytes - head\n// 8 | 1 bytes - eyes\n// 8 | 1 bytes - mouth\n// 8 | 1 bytes - back\n// 8 | 1 bytes - hair\n// 8 | 1 bytes - neck ---- 48 | 6  -- 99 | 12.5 ---- 6 vars\n\n// 12 | 1.5 bytes - head coordinate\n// 12 | 1.5 bytes - eyes coordinate\n// 12 | 1.5 bytes - mouth coordinate\n// 12 | 1.5 bytes - back coordinate\n// 12 | 1.5 bytes - hair coordinate\n// 12 | 1.5 bytes - neck coordinate ---- 159-    ----- 12 vars\n\n// 3            - expander 3 feat      ------- 3 vars\n\n// 3            - expander 1 feat\n// 24 | 3 bytes - expander 1\n// 3            - expander 2 feat\n// 24 | 3 bytes - expander 2\n// 24 | 3 bytes - expander 3       - 24 vars\n\nlibrary Descriptor {\n    // struct Memory {\n    //     IDotNugg.Rlud[] expanderOffset; // 0 - 8\n    //     IDotNugg.Rlud[] expanderOffsetDirection; // 0 - 1\n    //     IDotNugg.Rlud[] expanderAmount; // 0 - 3\n    //     IDotNugg.Coordinate[] anchors; // 0 - 63\n    // }\n\n    // function parse(uint256 input) internal pure returns (Memory memory m) {\n    //     m.expanderOffset = new IDotNugg.Rlud[](8);\n    //     m.expanderOffsetDirection = new IDotNugg.Rlud[](8);\n    //     m.expanderAmount = new IDotNugg.Rlud[](8);\n    //     m.anchors = new IDotNugg.Coordinate[](8);\n\n    //     uint256[] memory tmp = new uint256[](2);\n    //     tmp[0] = 1;\n    //     tmp[1] = input;\n\n    //     (, BitReader.Memory memory reader) = BitReader.init(tmp);\n\n    //     reader.select(99);\n\n    //     for (uint256 i = 1; i < 7; i++) {\n    //         m.anchors[i].a = uint8(reader.select(6));\n    //         m.anchors[i].b = uint8(reader.select(6));\n    //         m.anchors[i].exists = m.anchors[i].a != 0 || m.anchors[i].b != 0;\n    //     }\n    // }\n\n    function receiverOverride(uint256 input, uint256 feature)\n        internal\n        pure\n        returns (\n            bool exists,\n            uint256 x,\n            uint256 y\n        )\n    {\n        return (false, 15, 15);\n    }\n}\n"
    },
    "contracts/src/types/Pixel.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nlibrary Pixel {\n    function r(uint256 input) internal pure returns (uint256 res) {\n        res = (input >> 24) & 0xff;\n    }\n\n    function g(uint256 input) internal pure returns (uint256 res) {\n        res = (input >> 16) & 0xff;\n    }\n\n    function b(uint256 input) internal pure returns (uint256 res) {\n        res = (input >> 8) & 0xff;\n    }\n\n    function a(uint256 input) internal pure returns (uint256 res) {\n        res = input & 0xff;\n    }\n\n    function z(uint256 input) internal pure returns (uint256 res) {\n        res = (input >> 32) & 0xf;\n    }\n\n    function f(uint256 input) internal pure returns (uint256 res) {\n        res = (input >> 36) & 0xf;\n    }\n\n    function e(uint256 input) internal pure returns (bool res) {\n        res = input != 0x00;\n    }\n}\n"
    },
    "contracts/src/libraries/Bytes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport './Byte.sol';\n\n/**\n * @dev Bytes operations.\n */\nlibrary Bytes {\n    using Byte for bytes1;\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1, 'toUint8_outOfBounds');\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint4(bytes memory _bytes, uint256 _start) internal pure returns (uint8, uint8) {\n        uint8 tempUint = toUint8(_bytes, _start);\n        return (tempUint >> 4, tempUint & 0xf);\n    }\n\n    function toInt8(bytes memory _bytes, uint256 _start) internal pure returns (int8) {\n        uint8 tempUint = toUint8(_bytes, _start);\n        return (int8(~tempUint) + 1) * -1;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, 'toUint16_outOfBounds');\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, 'toUint64_outOfBounds');\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toAscii(bytes memory val) internal pure returns (string memory res) {\n        for (uint8 i = 0; i < val.length; i++) {\n            res = string(abi.encodePacked(res, val[i].toAscii()));\n        }\n    }\n}\n"
    },
    "contracts/src/libraries/Byte.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\n/**\n * @dev Bytes1 operations.\n */\nlibrary Byte {\n    bytes32 internal constant ALPHABET = '0123456789abcdef';\n\n    function toAscii(bytes1 value) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2);\n        for (uint256 i = 2; i > 0; i--) {\n            buffer[i - 1] = ALPHABET[uint8(value) & 0xf];\n            value >>= 4;\n        }\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/src/CompressedResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport './interfaces/IResolver.sol';\n\n/**\n * @title DotNugg V1 - onchain encoder/decoder for dotnugg files\n * @author Nugg Labs - @danny7even & @dub6ix\n * @notice yoU CAN'T HaVe ImAgES oN THe BlOCkcHAIn\n * @dev hold my margarita\n */\ncontract CompressedResolver is INuggFtProcessor {\n    IPostProcessResolver public immutable override postProcessor;\n\n    IProcessResolver public immutable override processor;\n\n    IPreProcessResolver public immutable override preProcessor;\n\n    constructor(address _preProcessor, address _processor) {\n        postProcessor = IPostProcessResolver(address(this));\n        preProcessor = IPreProcessResolver(_preProcessor);\n        processor = IProcessResolver(_processor);\n    }\n\n    function preProcess(bytes memory data) public view override returns (bytes memory _res) {\n        return preProcessor.preProcess(data);\n    }\n\n    function process(\n        uint256[][] memory files,\n        bytes memory data,\n        bytes memory preProcessorData\n    ) public view override returns (uint256[] memory resp) {\n        return processor.process(files, data, preProcessorData);\n    }\n\n    function postProcess(\n        uint256[] memory file,\n        bytes memory,\n        bytes memory\n    ) public pure override returns (bytes memory res) {\n        res = abi.encode(file);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public pure override(INuggFtProcessor) returns (bool) {\n        return\n            interfaceId == type(IPostProcessResolver).interfaceId ||\n            interfaceId == type(INuggFtProcessor).interfaceId ||\n            interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "contracts/src/erc165/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport './IERC165.sol';\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}