{
  "language": "Solidity",
  "sources": {
    "contracts/DotNugg.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport './logic/Decoder.sol';\nimport './logic/Calculator.sol';\n\nimport './libraries/Base64.sol';\nimport './interfaces/IDotNugg.sol';\nimport './interfaces/INuggIn.sol';\n\n/**\n * @title DotNugg V1 - onchain encoder/decoder for dotnugg files\n * @author Nugg Labs - @danny7even & @dub6ix\n * @notice yoU CAN'T HaVe ImAgES oN THe BlOCkcHAIn\n * @dev hold my margarita\n */\ncontract DotNugg is IDotNugg {\n    using Calculator for IDotNugg.Collection;\n    using Bytes for bytes;\n    using Uint256 for uint256;\n\n    function nuggify(\n        bytes memory _collection,\n        bytes[] memory _items,\n        address _resolver,\n        string memory name,\n        string memory,\n        uint256 tokenId,\n        bytes32 seed,\n        bytes memory data\n    ) public view override returns (string memory image) {\n        IFileResolver fileResolver = IFileResolver(_resolver);\n        IColorResolver colorResolver = IColorResolver(_resolver);\n\n        require(fileResolver.supportsInterface(type(IFileResolver).interfaceId), 'NUG:TURI:2');\n\n        IDotNugg.Collection memory collection = Decoder.parseCollection(_collection);\n\n        bytes[] memory selected = new bytes[](collection.numFeatures);\n\n        for (uint256 i = 0; i < _items.length; i++) {\n            selected[Decoder.parseItemFeatureId(_items[i])] = _items[i];\n        }\n\n        for (uint256 i = 0; i < collection.defaults.length; i++) {\n            uint8 featureId = Decoder.parseItemFeatureId(collection.defaults[i]);\n            if (selected[featureId].length == 0) {\n                selected[featureId] = collection.defaults[i];\n            }\n        }\n\n        IDotNugg.Matrix memory matrix = collection.combine(selected);\n\n        if (colorResolver.supportsInterface(type(IColorResolver).interfaceId)) {\n            colorResolver.resolveColor(matrix, data);\n        }\n        (bytes memory fileData, string memory fileType) = fileResolver.resolveFile(matrix, data);\n\n        image = Base64.encode(\n            bytes(\n                abi.encodePacked(\n                    '{\"name\":\"',\n                    name,\n                    '\",\"tokenId\":\"',\n                    tokenId.toString(),\n                    '\",\"description\":\"',\n                    uint256(seed).toString(),\n                    '\", \"image\": \"',\n                    Base64.encode(fileData, fileType),\n                    '\"}'\n                )\n            ),\n            'json'\n        );\n        //   image = fileData.toAscii();\n    }\n}\n"
    },
    "contracts/logic/Decoder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../interfaces/IDotNugg.sol';\n\nimport '../libraries/Bytes.sol';\nimport '../libraries/BytesLib.sol';\nimport '../libraries/Checksum.sol';\nimport '../libraries/Uint.sol';\nimport '../logic/Rgba.sol';\n\nimport '../test/Console.sol';\n\nlibrary Decoder {\n    using Bytes for bytes;\n    using Bytes for bytes;\n\n    using Checksum for bytes;\n    using BytesLib for bytes;\n\n    using Uint256 for uint256;\n    using Rgba for IDotNugg.Rgba;\n\n    // ┌──────────────────────────────────────────────────────────────┐\n    // │                                                              │\n    // │           _____       _ _           _   _                    │\n    // │          /  __ \\     | | |         | | (_)                   │\n    // │          | /  \\/ ___ | | | ___  ___| |_ _  ___  _ __         │\n    // │          | |    / _ \\| | |/ _ \\/ __| __| |/ _ \\| '_ \\        │\n    // │          | \\__/\\ (_) | | |  __/ (__| |_| | (_) | | | |       │\n    // │           \\____/\\___/|_|_|\\___|\\___|\\__|_|\\___/|_| |_|       │\n    // │                                                              │\n    // │   ┌─────┬────────────────────────────────────────────────┐   │\n    // │   │ 0-6 │  \"DOTNUGG\" (7 bytes in ascii)                  │   │\n    // │   ├─────┼────────────────────────────────────────────────┤   │\n    // │   │  x  │  file type (0x01) - (1 byte)                   │   │\n    // │   ├─────┼────────────────────────────────────────────────┤   │\n    // │   │  7  │  width / height (1 byte because square)        │   │\n    // │   ├─────┼────────────────────────────────────────────────┤   │\n    // │   │  8  │  numFeatures (1 byte)                          │   │\n    // │   ├─────┼────────────────────────────────────────────────┤   │\n    // │   │9-*  │  item data index array ([*][2]byte)            │   │\n    // │   ├─────┼────────────────────────────────────────────────┤   │\n    // │   │ *-* │  item array ([*][*]byte)                       │   │\n    // │   └─────┴────────────────────────────────────────────────┘   │\n    // │                                                              │\n    // └──────────────────────────────────────────────────────────────┘\n\n    function parseCollection(bytes memory data) internal view returns (IDotNugg.Collection memory res) {\n        res.width = data.toUint8(7);\n        res.height = res.width;\n\n        res.numFeatures = data.toUint8(8);\n        uint16 tmp = data.toUint16(9);\n        uint16[] memory itemIndexs = new uint16[]((tmp - 9) / 2);\n\n        itemIndexs[0] = tmp;\n        for (uint16 i = 1; i < itemIndexs.length; i++) {\n            itemIndexs[i] = data.toUint16(9 + i * 2);\n        }\n\n        res.defaults = new bytes[](itemIndexs.length);\n\n        for (uint16 i = 0; i < itemIndexs.length; i++) {\n            uint256 endIndex = i + 1 == itemIndexs.length ? data.length : itemIndexs[i + 1];\n            res.defaults[i] = data.slice(itemIndexs[i], endIndex - itemIndexs[i]);\n        }\n        return res;\n    }\n\n    function parseItems(bytes[] memory data, uint8 featureLen) internal view returns (IDotNugg.Item[] memory res) {\n        res = new IDotNugg.Item[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            if (data[i].length > 0) res[i] = parseItem(data[i], featureLen);\n        }\n    }\n\n    // ┌───────────────────────────────────────────────────────────────────┐\n    // │                                                                   │\n    // │                     _____ _                                       │\n    // │                    |_   _| |                                      │\n    // │                      | | | |_ ___ _ __ ___                        │\n    // │                      | | | __/ _ \\ '_ ` _ \\                       │\n    // │                     _| |_| ||  __/ | | | | |                      │\n    // │                     \\___/ \\__\\___|_| |_| |_|                      │\n    // │                                                                   │\n    // │                                                                   │\n    // │     ┌─────┬────────────────────────────────────────────────┐      │\n    // │     │ 0-6 │  \"DOTNUGG\" (7 bytes in ascii)                  │      │\n    // │     ├─────┼────────────────────────────────────────────────┤      │\n    // │     │ 7-8 │  checksum - (2 bytes)                          │      │\n    // │     ├─────┼────────────────────────────────────────────────┤      │\n    // │     │  9  │  feature key - (1 byte)                        │      │\n    // │     ├─────┼────────────────────────────────────────────────┤      │\n    // │     │10-11│  colors array index from 0 (uint16)            │      │\n    // │     ├─────┼────────────────────────────────────────────────┤      │\n    // │     │12-* │  version index array - ([*][2]byte)            │      │\n    // │     ├─────┼────────────────────────────────────────────────┤      │\n    // │     │ *-* │  color array - ([*][6]byte)                    │      │\n    // │     ├─────┼────────────────────────────────────────────────┤      │\n    // │     │ *-* │  version array ([*][*]byte)                    │      │\n    // │     └─────┴────────────────────────────────────────────────┘      │\n    // │                                                                   │\n    // │                                                                   │\n    // └───────────────────────────────────────────────────────────────────┘\n\n    function validateItem(bytes memory data) internal view {\n        require(data.length > 13, 'D:VI:0');\n        require(data.slice(0, 7).equal(abi.encodePacked('DOTNUGG')), 'D:VI:1');\n        require(data.slice(9, data.length - 9).fletcher16() == data.toUint16(7), 'D:VI:2');\n    }\n\n    function parseItem(bytes memory data, uint8 featureLen) internal view returns (IDotNugg.Item memory res) {\n        validateItem(data);\n\n        res.feature = parseItemFeatureId(data);\n\n        uint16 colorsIndex = data.toUint16(10);\n        uint16[] memory versionsIndexz = new uint16[]((colorsIndex - 12) / 2);\n\n\n        for (uint16 i = 0; i < versionsIndexz.length; i++) {\n            versionsIndexz[i] = data.toUint16(12 + i * 2);\n        }\n\n        res.pallet = new IDotNugg.Pixel[](1 + (versionsIndexz[0] - colorsIndex) / 5);\n        res.versions = new IDotNugg.Version[](versionsIndexz.length);\n\n\n        require(res.versions.length > 0, 'DEC:PI:0');\n        res.pallet[0] = IDotNugg.Pixel({rgba: IDotNugg.Rgba({r: 1, g: 1, b: 1, a: 0}), zindex: 0, exists: false});\n        for (uint16 i = 1; i < res.pallet.length; i++) {\n            res.pallet[i] = parsePixel(data, colorsIndex + 5 * (i - 1));\n\n        }\n\n        for (uint16 i = 0; i < versionsIndexz.length; i++) {\n            uint256 endIndex = i + 1 == versionsIndexz.length ? data.length : versionsIndexz[i + 1];\n            res.versions[i] = parseVersion(data, versionsIndexz[i], uint16(endIndex), featureLen);\n        }\n    }\n\n    function parseItemFeatureId(bytes memory data) internal view returns (uint8 res) {\n        res = uint8(data[9]);\n    }\n\n    // ┌──────────────────────────────────────────────────────────────┐\n    // │                                                              │\n    // │                                                              │\n    // │                    ______ _          _                       │\n    // │                    | ___ (_)        | |                      │\n    // │                    | |_/ /___  _____| |                      │\n    // │                    |  __/| \\ \\/ / _ \\ |                      │\n    // │                    | |   | |>  <  __/ |                      │\n    // │                    \\_|   |_/_/\\_\\___|_|                      │\n    // │                                                              │\n    // │                                                              │\n    // │   ┌─────┬────────────────────────────────────────────────┐   │\n    // │   │  0  │  zindex (int8)                                 │   │\n    // │   ├─────┼────────────────────────────────────────────────┤   │\n    // │   │ 1-4 │  rgba (4 bytes)                                │   │\n    // │   └─────┴────────────────────────────────────────────────┘   │\n    // │                                                              │\n    // └──────────────────────────────────────────────────────────────┘\n\n    function parsePixel(bytes memory _bytes, uint256 _start) internal view returns (IDotNugg.Pixel memory res) {\n        require(_bytes.length >= _start + 5, 'parsePixel_outOfBounds');\n\n\n\n        res.zindex = _bytes.toInt8(_start);\n\n\n        res.rgba = parseRgba(_bytes, _start + 1);\n        res.exists = true;\n    }\n\n    // ┌──────────────────────────────────────────────────────────────┐\n    // │                                                              │\n    // │                                                              │\n    // │                    ______      _                             │\n    // │                    | ___ \\    | |                            │\n    // │                    | |_/ /__ _| |__   __ _                   │\n    // │                    |    // _` | '_ \\ / _` |                  │\n    // │                    | |\\ \\ (_| | |_) | (_| |                  │\n    // │                    \\_| \\_\\__, |_.__/ \\__,_|                  │\n    // │                           __/ |                              │\n    // │                          |___/                               │\n    // │                                                              │\n    // │    ┌─────┬─────────────────────────────────────────────┐     │\n    // │    │  0  │  r (uint8)                                  │     │\n    // │    ├─────┼─────────────────────────────────────────────┤     │\n    // │    │  1  │  l (uint8)                                  │     │\n    // │    ├─────┼─────────────────────────────────────────────┤     │\n    // │    │  2  │  u (uint8)                                  │     │\n    // │    ├─────┼─────────────────────────────────────────────┤     │\n    // │    │  3  │  d (uint8)                                  │     │\n    // │    └─────┴─────────────────────────────────────────────┘     │\n    // │                                                              │\n    // │                                                              │\n    // └──────────────────────────────────────────────────────────────┘\n\n    function parseRgba(bytes memory _bytes, uint256 _start) internal view returns (IDotNugg.Rgba memory res) {\n        require(_bytes.length >= _start + 4, 'parsePixel_outOfBounds');\n        res.r = uint8(_bytes[_start + 0]);\n        res.g = uint8(_bytes[_start + 1]);\n        res.b = uint8(_bytes[_start + 2]);\n        res.a = uint8(_bytes[_start + 3]);\n    }\n\n    function parseRlud(bytes memory _bytes, uint256 _start) internal view returns (IDotNugg.Rlud memory res) {\n        // require(_bytes.length >= _start + 5, 'parseRlud_outOfBounds');\n        res.exists = bool(uint8(_bytes[_start + 0]) == 1);\n        if (res.exists) {\n            res.r = uint8(_bytes[_start + 1]);\n            res.l = uint8(_bytes[_start + 2]);\n            res.u = uint8(_bytes[_start + 3]);\n            res.d = uint8(_bytes[_start + 4]);\n        }\n    }\n\n    // ┌──────────────────────────────────────────────────────────────┐\n    // │                                                              │\n    // │                _   _               _                         │\n    // │               | | | |             (_)                        │\n    // │               | | | | ___ _ __ ___ _  ___  _ __              │\n    // │               | | | |/ _ \\ '__/ __| |/ _ \\| '_ \\             │\n    // │               \\ \\_/ /  __/ |  \\__ \\ | (_) | | | |            │\n    // │                \\___/ \\___|_|  |___/_|\\___/|_| |_|            │\n    // │                                                              │\n    // │                                                              │\n    // │   ┌─────┬────────────────────────────────────────────────┐   │\n    // │   │  0  │  width (1 bytes)                               │   │\n    // │   ├─────┼────────────────────────────────────────────────┤   │\n    // │   │ 1-2 │  anchor (2 bytes)                              │   │\n    // │   ├─────┼────────────────────────────────────────────────┤   │\n    // │   │ 3-7 │  expanders (2 bytes - rlud - 5 uint4s)         │   │\n    // │   ├─────┼────────────────────────────────────────────────┤   │\n    // │   │ 8-6 │  radii (2 bytes - rlud - 5 uint4s)             │   │\n    // │   ├─────┼────────────────────────────────────────────────┤   │\n    // │   │  7  │  groups index  (uint8)                         │   │\n    // │   ├─────┼────────────────────────────────────────────────┤   │\n    // │   │ 8-* │  receivers ([*][2] bytes)                      │   │\n    // │   ├─────┼────────────────────────────────────────────────┤   │\n    // │   │ *-* │  group array ([*][1]byte)                      │   │\n    // │   └─────┴────────────────────────────────────────────────┘   │\n    // │                                                              │\n    // └──────────────────────────────────────────────────────────────┘\n\n    function parseVersion(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _end,\n        uint8 featureLen\n    ) internal view returns (IDotNugg.Version memory res) {\n        require(_bytes.length >= _end && _start < _end, 'parsePixel_outOfBounds');\n\n\n        res.calculatedReceivers = new IDotNugg.Coordinate[](featureLen);\n        res.staticReceivers = new IDotNugg.Coordinate[](featureLen);\n        uint256 addr = 0;\n        res.width = _bytes.toUint8(_start + addr++);\n        res.height = _bytes.toUint8(_start + addr++);\n        res.anchor.coordinate.a = _bytes.toUint8(_start + addr++);\n        res.anchor.coordinate.b = _bytes.toUint8(_start + addr++);\n        res.expanders = parseRlud(_bytes, _start + addr++);\n        if (res.expanders.exists) addr += 4;\n        res.anchor.radii = parseRlud(_bytes, _start + addr++);\n        if (res.anchor.radii.exists) addr += 4;\n\n\n\n\n\n\n        uint16 groupsIndex = uint16(_start) + _bytes.toUint8(_start + addr++);\n\n        uint256 i = _start + addr++;\n\n\n        for (; i < groupsIndex; i += 2) {\n            (IDotNugg.Coordinate memory rec, uint8 feature, bool calculated) = parseReceiver(_bytes, i);\n\n\n            if (calculated) {\n                res.calculatedReceivers[feature] = rec;\n            } else {\n                //  require(feature < 16, String.fromUint256(i));\n                res.staticReceivers[feature] = rec;\n            }\n        }\n\n        res.data = _bytes.slice(groupsIndex, _end - groupsIndex);\n    }\n\n    // ┌────────────────────────────────────────────────────────────┐\n    // │                                                            │\n    // │             ______              _                          │\n    // │             | ___ \\            (_)                         │\n    // │             | |_/ /___  ___ ___ ___   _____ _ __           │\n    // │             |    // _ \\/ __/ _ \\ \\ \\ / / _ \\ '__|          │\n    // │             | |\\ \\  __/ (_|  __/ |\\ V /  __/ |             │\n    // │             \\_| \\_\\___|\\___\\___|_| \\_/ \\___|_|             │\n    // │                                                            │\n    // │                                                            │\n    // │  ┌─────┬────────────────────────────────────────────────┐  │\n    // │  │  0  │  preset | x (uint4) & yoffset | y (int4)       │  │\n    // │  ├─────┼────────────────────────────────────────────────┤  │\n    // │  │  1  │  type (1 byte)                                 │  │\n    // │  └─────┴────────────────────────────────────────────────┘  │\n    // │                                                            │\n    // └────────────────────────────────────────────────────────────┘\n\n    function parseReceiver(bytes memory _bytes, uint256 _start)\n        internal\n        view\n        returns (\n            IDotNugg.Coordinate memory res,\n            uint8 feature,\n            bool calculated\n        )\n    {\n        require(_bytes.length >= _start + 2, 'parseRlud_outOfBounds');\n        (res.a, res.b) = _bytes.toUint4(_start + 0);\n        res.exists = true;\n        int8 tmpfeat = _bytes.toInt8(_start + 1);\n\n        if (tmpfeat >= 0) {\n            feature = uint8(tmpfeat);\n        } else {\n            feature = uint8(tmpfeat * -1);\n            calculated = true;\n        }\n    }\n}\n"
    },
    "contracts/logic/Calculator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport './Matrix.sol';\nimport './Decoder.sol';\nimport './Rgba.sol';\nimport './Anchor.sol';\n\nimport '../interfaces/IDotNugg.sol';\n\nlibrary Calculator {\n    using Rgba for IDotNugg.Rgba;\n    using Matrix for IDotNugg.Matrix;\n\n    /**\n     * @notice\n     * @dev\n     */\n    function combine(IDotNugg.Collection memory collection, bytes[] memory inputs) internal view returns (IDotNugg.Matrix memory resa) {\n        IDotNugg.Canvas memory canvas;\n        canvas.matrix = Matrix.create(collection.width, collection.height);\n        canvas.receivers = new IDotNugg.Anchor[](collection.numFeatures);\n        IDotNugg.Coordinate memory coord;\n        coord.a = collection.width / 2;\n        coord.b = collection.width / 2;\n        coord.exists = true;\n        IDotNugg.Rlud memory r;\n        for (uint8 i = 0; i < collection.numFeatures; i++) {\n            canvas.receivers[i] = IDotNugg.Anchor({coordinate: coord, radii: r});\n        }\n        canvas.matrix.width = collection.width;\n        canvas.matrix.height = collection.height;\n\n        IDotNugg.Mix memory mix;\n        mix.matrix = Matrix.create(collection.width, collection.height);\n        mix.receivers = new IDotNugg.Anchor[](collection.numFeatures);\n\n        IDotNugg.Item[] memory items = Decoder.parseItems(inputs, collection.numFeatures);\n\n        for (uint8 i = 0; i < items.length; i++) {\n            if (items[i].versions.length > 0) {\n\n                setMix(mix, items[i], pickVersionIndex(canvas, items[i]));\n\n                formatForCanvas(canvas, mix);\n\n                postionForCanvas(canvas, mix);\n\n                mergeToCanvas(canvas, mix);\n\n                calculateReceivers(mix);\n\n                updateReceivers(canvas, mix);\n\n            }\n        }\n\n        return canvas.matrix;\n    }\n\n    /**\n     * @notice\n     * @devg\n     */\n    function postionForCanvas(IDotNugg.Canvas memory canvas, IDotNugg.Mix memory mix) internal view {\n        IDotNugg.Anchor memory receiver = canvas.receivers[mix.feature];\n        IDotNugg.Anchor memory anchor = mix.version.anchor;\n\n        uint8 xoffset = receiver.coordinate.a - anchor.coordinate.a;\n        uint8 yoffset = receiver.coordinate.b - anchor.coordinate.b;\n\n        canvas.matrix.moveTo(xoffset, yoffset, mix.matrix.width, mix.matrix.height);\n    }\n\n    /**\n     * @notice\n     * @dev\n     */\n    function formatForCanvas(IDotNugg.Canvas memory canvas, IDotNugg.Mix memory mix) internal view {\n        IDotNugg.Anchor memory receiver = canvas.receivers[mix.feature];\n        IDotNugg.Anchor memory anchor = mix.version.anchor;\n\n\n\n\n\n\n\n\n\n\n\n        if (mix.version.expanders.l != 0 && anchor.radii.l != 0 && anchor.radii.l <= receiver.radii.l) {\n            uint8 amount = receiver.radii.l - anchor.radii.l;\n            mix.matrix.addColumnsAt(mix.version.expanders.l - 1, amount);\n            anchor.coordinate.a += amount;\n            if (mix.version.expanders.r > 0) mix.version.expanders.r += amount;\n        }\n        if (mix.version.expanders.r != 0 && anchor.radii.r != 0 && anchor.radii.r <= receiver.radii.r) {\n            mix.matrix.addColumnsAt(mix.version.expanders.r - 1, receiver.radii.r - anchor.radii.r);\n        }\n        if (mix.version.expanders.d != 0 && anchor.radii.d != 0 && anchor.radii.d <= receiver.radii.d) {\n            uint8 amount = receiver.radii.d - anchor.radii.d;\n            mix.matrix.addRowsAt(mix.version.expanders.d, amount);\n            anchor.coordinate.b += amount;\n            if (mix.version.expanders.u > 0) mix.version.expanders.u += amount;\n        }\n        if (mix.version.expanders.u != 0 && anchor.radii.u != 0 && anchor.radii.u <= receiver.radii.u) {\n            mix.matrix.addRowsAt(mix.version.expanders.u, receiver.radii.u - anchor.radii.u);\n        }\n\n\n\n    }\n\n    /**\n     * @notice\n     * @dev\n     * makes the sorts versions\n     */\n    function pickVersionIndex(IDotNugg.Canvas memory canvas, IDotNugg.Item memory item) internal view returns (uint8) {\n        require(item.versions.length > 0, 'CALC:PVI:0');\n        if (item.versions.length == 1) {\n            return 0;\n        }\n        uint8 index = uint8(item.versions.length) - 1;\n\n        while (index > 0) {\n            if (checkRluds(item.versions[index].anchor.radii, canvas.receivers[item.feature].radii)) {\n                return index;\n            }\n            index = index - 1;\n        }\n\n        return 0;\n    }\n\n    function checkRluds(IDotNugg.Rlud memory r1, IDotNugg.Rlud memory r2) internal view returns (bool) {\n        return (r1.r <= r2.r && r1.l <= r2.l) || (r1.u <= r2.u && r1.d <= r2.d);\n    }\n\n    /**\n     * @notice\n     * @dev done\n     * makes the sorts versions\n     */\n    function setMix(\n        IDotNugg.Mix memory res,\n        IDotNugg.Item memory item,\n        uint8 versionIndex\n    ) internal view {\n        res.version = item.versions[versionIndex];\n        res.feature = item.feature;\n        res.receivers = new IDotNugg.Anchor[](res.receivers.length);\n\n        res.matrix.set(res.version.data, item.pallet, res.version.width, res.version.height);\n    }\n\n    /**\n     * @notice done\n     * @dev\n     */\n    function updateReceivers(IDotNugg.Canvas memory canvas, IDotNugg.Mix memory mix) internal view {\n        for (uint8 i = 0; i < mix.receivers.length; i++) {\n            IDotNugg.Anchor memory m = mix.receivers[i];\n            if (m.coordinate.exists) {\n                canvas.receivers[i] = m;\n            }\n        }\n        // for (uint8 i = 0 ; i < canvas.receivers.length; i++) {\n\n\n\n        // }\n    }\n\n    /**\n     * @notice done\n     * @dev\n     */\n    function mergeToCanvas(IDotNugg.Canvas memory canvas, IDotNugg.Mix memory mix) internal view {\n        while (canvas.matrix.next() && mix.matrix.next()) {\n            IDotNugg.Pixel memory canvasPixel = canvas.matrix.current();\n            IDotNugg.Pixel memory mixPixel = mix.matrix.current();\n\n\n\n\n            if (mixPixel.exists && mixPixel.zindex >= canvasPixel.zindex) {\n                canvasPixel.zindex = mixPixel.zindex;\n\n\n\n\n\n                canvasPixel.rgba.combine(mixPixel.rgba);\n\n\n\n            }\n        }\n        canvas.matrix.moveBack();\n        canvas.matrix.resetIterator();\n        mix.matrix.resetIterator();\n    }\n\n    /**\n     * @notice poop\n     * @dev\n     */\n    function calculateReceivers(IDotNugg.Mix memory mix) internal view {\n        Anchor.convertReceiversToAnchors(mix);\n    }\n\n    // you combine one by one, and as you combine, child refs get overridden\n\n    // function add(Combinable comb, )\n}\n// add parent refs, if any - will use remys algo only for the canvas\n// the canvas will always be defined as the first, so if it isnt (will not happen for dotnugg), we define the center as all the child refs\n//  pick best version\n// figure out offset\n\n// function merge(Canvas memory canvas, Matrix memory versionMatrix) internal view {\n//     for (int8 y = (canvas.matrix.data.length / 2) * -1; y <= canvas.matrix.data.length / 2; y++) {\n//         for (int8 x = (canvas.matrix.width / 2) * -1; x <= canvas.matrix[j].width / 2; x++) {\n//             Pixel memory canvas = canvas.matrix.at(x, y);\n//             Pixel memory addr = combinable.matrix.at(x, y);\n\n//             if (addr != 0 && addr.layer > canvas.layer) {\n//                 canvas.layer = addr.layer;\n//                 canvas.rgba = Colors.combine(canvas.rgba, add.rgba);\n//             }\n//         }\n//     }\n// }\n// Oh my god\n// Becky, look at her butt\n// Its so big\n// She looks like one of those rap guys girlfriends\n// Who understands those rap guys\n// They only talk to her because she looks like a total prostitute\n// I mean her butt\n// It's just so big\n// I can't believe it's so round\n// It's just out there\n// I mean, it's gross\n// Look, she's just so black\n\n// *rap*\n// I like big butts and I can not lie\n// You other brothers can't deny\n// That when a girl walks in with an itty bitty waist\n// And a round thing in your face\n// You get sprung\n// Wanna pull up tough\n// Cuz you notice that butt was stuffed\n// Deep in the jeans she's wearing\n// I'm hooked and I can't stop staring\n// Oh, baby I wanna get with ya\n// And take your picture\n// My homeboys tried to warn me\n// But that butt you got\n// Make Me so horney\n// Ooh, rump of smooth skin\n// You say you wanna get in my benz\n// Well use me use me cuz you aint that average groupy\n\n// I've seen them dancin'\n// The hell with romancin'\n// She's Sweat,Wet, got it goin like a turbo vette\n\n// I'm tired of magazines\n// Saying flat butts are the thing\n// Take the average black man and ask him that\n// She gotta pack much back\n\n// So Fellas (yeah) Fellas(yeah)\n// Has your girlfriend got the butt (hell yeah)\n// Well shake it, shake it, shake it, shake it, shake that healthy butt\n// Baby got back\n\n// (LA face with Oakland booty)\n\n// I like'em round and big\n// And when I'm throwin a gig\n// I just can't help myself\n// I'm actin like an animal\n// Now here's my scandal\n\n// I wanna get you home\n// And UH, double up UH UH\n// I aint talkin bout playboy\n// Cuz silicone parts were made for toys\n// I wannem real thick and juicy\n// So find that juicy double\n// Mixalot's in trouble\n// Beggin for a piece of that bubble\n// So I'm lookin' at rock videos\n// Knockin these bimbos walkin like hoes\n// You can have them bimbos\n// I'll keep my women like Flo Jo\n// A word to the thick soul sistas\n// I wanna get with ya\n// I won't cus or hit ya\n// But I gotta be straight when I say I wanna --\n// Til the break of dawn\n// Baby Got it goin on\n// Alot of pimps won't like this song\n// Cuz them punks lie to hit it and quit it\n// But I'd rather stay and play\n// Cuz I'm long and I'm strong\n// And I'm down to get the friction on\n\n// So ladies (yeah), Ladies (yeah)\n// Do you wanna roll in my Mercedes (yeah)\n// Then turn around\n// Stick it out\n// Even white boys got to shout\n// Baby got back\n\n// (LA face with the Oakland booty)\n\n// Yeah baby\n// When it comes to females\n// Cosmo ain't got nothin to do with my selection\n// 36-24-36\n// Only if she's 5'3\"\n\n// So your girlfriend throws a Honda\n// Playin workout tapes by Fonda\n// But Fonda ain't got a motor in the back of her Honda\n// My anaconda don't want none unless you've got buns hun\n// You can do side bends or sit-ups, but please don't lose that butt\n// Some brothers wanna play that hard role\n// And tell you that the butt ain't gold\n// So they toss it and leave it\n// And I pull up quick to retrieve it\n// So cosmo says you're fat\n// Well I ain't down with that\n// Cuz your waste is small and your curves are kickin\n// And I'm thinkin bout stickin\n// To the beanpole dames in the magazines\n// You aint it miss thing\n// Give me a sista I can't resist her\n// Red beans and rice did miss her\n// Some knucklehead tried to dis\n// Cuz his girls were on my list\n// He had game but he chose to hit 'em\n// And pulled up quick to get with 'em\n// So ladies if the butt is round\n// And you wanna triple X throw down\n// Dial 1-900-MIXALOT and kick them nasty thoughts\n// Baby got back\n// Baby got back\n// Little in tha middle but she got much back x4\n"
    },
    "contracts/libraries/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\n/**\n * @title Base64\n * @author Nugg Labs - @danny7even & @dub6ix\n * @notice library for encoding bytes into base64\n */\nlibrary Base64 {\n    string internal constant _TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    string internal constant _BASE64_PREFIX_JSON = 'data:application/json;base64,';\n    string internal constant _BASE64_PREFIX_DOTNUGG = 'data:image/dotnugg;base64,';\n    string internal constant _BASE64_PREFIX_SVGs = 'data:image/svg+xml;base64,';\n\n    /**\n     * @notice wrapper for _encode for svg data\n     * @param data bytes to encode\n     * @return base64 string representation of input bytes, prefixed with json base64 prefix\n     */\n    function encode(bytes memory data, string memory file) internal pure returns (string memory) {\n        return string(abi.encodePacked('data:', file, ';base64,', _encode(data)));\n    }\n\n    /**\n     * @notice Encodes some bytes in base64\n     * @param data bytes to encode\n     * @return base64 string representation of input bytes\n     * @dev Credit to Brecht Devos - <brecht@loopring.org> - under MIT license https://github.com/Brechtpd/base64/blob/main/base64.sol\n     * @dev modified for solidity v8\n     */\n    function _encode(bytes memory data) private pure returns (string memory) {\n        if (data.length == 0) return '';\n\n        // load the table into memory\n        string memory table = _TABLE;\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n\n        // add some extra buffer at the end required for the writing\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            // set the actual output length\n            mstore(result, encodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 3 bytes at a time\n            for {\n\n            } lt(dataPtr, endPtr) {\n\n            } {\n                dataPtr := add(dataPtr, 3)\n\n                // read 3 bytes\n                let input := mload(dataPtr)\n\n                // write 4 characters\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(6, input), 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(input, 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n            }\n\n            // padding with '='\n            switch mod(mload(data), 3)\n            case 1 {\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\n            }\n            case 2 {\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\n            }\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/interfaces/IDotNugg.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\ninterface IDotNugg {\n    function nuggify(\n        bytes memory _collection,\n        bytes[] memory _items,\n        address _resolver,\n        string memory name,\n        string memory description,\n        uint256 tokenId,\n        bytes32 seed,\n        bytes memory data\n    ) external view returns (string memory image);\n\n    struct Rlud {\n        bool exists;\n        uint8 r;\n        uint8 l;\n        uint8 u;\n        uint8 d;\n    }\n\n    struct Rgba {\n        uint8 r;\n        uint8 g;\n        uint8 b;\n        uint8 a;\n    }\n\n    struct Anchor {\n        Rlud radii;\n        Coordinate coordinate;\n    }\n\n    struct Coordinate {\n        uint8 a; // anchorId\n        uint8 b; // yoffset\n        bool exists;\n    }\n\n    struct Collection {\n        uint8 width;\n        uint8 height;\n        uint8 numFeatures;\n        bytes[] defaults;\n    }\n\n    struct Item {\n        uint8 feature;\n        Pixel[] pallet;\n        Version[] versions;\n    }\n\n    struct Version {\n        uint8 width;\n        uint8 height;\n        Anchor anchor;\n        // these must be in same order as canvas receivers, respectively\n        Coordinate[] calculatedReceivers; // can be empty\n        Coordinate[] staticReceivers; // can be empty\n        Rlud expanders;\n        bytes data;\n    }\n\n    struct Canvas {\n        Matrix matrix;\n        Anchor[] receivers;\n    }\n\n    struct Mix {\n        uint8 feature;\n        Version version;\n        Matrix matrix;\n        Anchor[] receivers;\n    }\n\n    struct Pixel {\n        int8 zindex;\n        Rgba rgba;\n        bool exists;\n    }\n\n    struct Pallet {\n        Pixel[] pixels;\n    }\n\n    struct Matrix {\n        uint8 width;\n        uint8 height;\n        Pixel[][] data;\n        uint8 currentUnsetX;\n        uint8 currentUnsetY;\n        bool init;\n        uint8 startX;\n    }\n}\n"
    },
    "contracts/interfaces/INuggIn.sol": {
      "content": "pragma solidity 0.8.4;\n\nimport '../erc165/IERC165.sol';\nimport './IDotNugg.sol';\n\ninterface IColorResolver is IERC165 {\n    function resolveColor(IDotNugg.Matrix memory matrix, bytes memory data) external pure returns (bytes memory res);\n\n    function supportsInterface(bytes4 interfaceId) external view override returns (bool);\n}\n\ninterface IFileResolver is IERC165 {\n    function resolveFile(IDotNugg.Matrix memory matrix, bytes memory data) external view returns (bytes memory, string memory fileType);\n\n    function supportsInterface(bytes4 interfaceId) external view override returns (bool);\n}\n"
    },
    "contracts/libraries/Bytes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport './Byte.sol';\n\n/**\n * @dev Bytes operations.\n */\nlibrary Bytes {\n    using Byte for bytes1;\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1, 'toUint8_outOfBounds');\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint4(bytes memory _bytes, uint256 _start) internal pure returns (uint8, uint8) {\n        uint8 tempUint = toUint8(_bytes, _start);\n        return (tempUint >> 4, tempUint & 0xf);\n    }\n\n    function toInt8(bytes memory _bytes, uint256 _start) internal pure returns (int8) {\n        uint8 tempUint = toUint8(_bytes, _start);\n        return (int8(~tempUint) + 1) * -1;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, 'toUint16_outOfBounds');\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, 'toUint64_outOfBounds');\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toAscii(bytes memory val) internal pure returns (string memory res) {\n        for (uint8 i = 0; i < val.length; i++) {\n            res = string(abi.encodePacked(res, val[i].toAscii()));\n        }\n    }\n}\n"
    },
    "contracts/libraries/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity >=0.8.0 <0.9.0;\n\nlibrary BytesLib {\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory) {\n        require(_length + 31 >= _length, 'slice_overflow');\n        require(_bytes.length >= _start + _length, 'slice_outOfBounds');\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                    // the next line is the loop condition:\n                    // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}\n"
    },
    "contracts/libraries/Checksum.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\n/**\n * @dev Bytes1 operations.\n */\n\nlibrary Checksum {\n    function fletcher16(bytes memory data) internal pure returns (uint16 res) {\n        uint16 sum1 = 0;\n        uint16 sum2 = 0;\n        for (uint256 index = 0; index < data.length; index++) {\n            sum1 = (sum1 + uint8(data[index])) % 255;\n            sum2 = (sum2 + sum1) % 255;\n        }\n\n        res = (sum2 << 8) | sum1;\n    }\n}\n"
    },
    "contracts/libraries/Uint.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\n/*\n * @dev Uint operations.\n */\nlibrary Uint8 {\n    function toByte(uint8 u) internal pure returns (bytes1 res) {\n        res = bytes1(u);\n    }\n\n    function toString(uint8 u) internal pure returns (string memory res) {\n        res = Uint256.toString(uint256(u));\n    }\n}\n\n/*\n * @dev Uint operations.\n */\nlibrary Uint256 {\n    bytes16 private constant _HEX_SYMBOLS = '0123456789abcdef';\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return '0';\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0x00';\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = '0';\n        buffer[1] = 'x';\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, 'Strings: hex length insufficient');\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/logic/Rgba.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.4;\n\nimport '../libraries/Bytes.sol';\nimport '../interfaces/IDotNugg.sol';\nimport '../test/Console.sol';\n\nlibrary Rgba {\n    using Bytes for bytes;\n\n    struct RGBA16 {\n        uint16 r;\n        uint16 g;\n        uint16 b;\n        uint16 a;\n    }\n\n    function combine(IDotNugg.Rgba memory base, IDotNugg.Rgba memory mix) internal view {\n        if (mix.a == 255 || base.a == 0) {\n            base.r = mix.r;\n            base.g = mix.g;\n            base.b = mix.b;\n            base.a = mix.a;\n            return;\n        }\n\n        RGBA16 memory baseRGB = RGBA16({r: uint16(base.r), g: uint16(base.g), b: uint16(base.b), a: uint16(base.a)});\n        RGBA16 memory mixRGB = RGBA16({r: uint16(mix.r), g: uint16(mix.g), b: uint16(mix.b), a: uint16(mix.a)});\n\n        // uint8 alpha = uint8(255 - (((255 - baseRGB.a) * (255 - mixRGB.a)) / 255));\n        base.r = uint8((baseRGB.r * (255 - mixRGB.a) + mixRGB.r * mixRGB.a) / 255);\n        base.g = uint8((baseRGB.g * (255 - mixRGB.a) + mixRGB.g * mixRGB.a) / 255);\n        base.b = uint8((baseRGB.b * (255 - mixRGB.a) + mixRGB.b * mixRGB.a) / 255);\n        base.a = 255;\n        //   return IDotNugg.Rgba({r: r, g: g, b: b, a: 255});\n    }\n\n    function toUint64(IDotNugg.Rgba memory base) internal view returns (uint64 res) {\n        bytes memory input = abi.encodePacked(base.r, base.g, base.b, base.a);\n        return input.toUint64(0);\n    }\n\n    function toAscii(IDotNugg.Rgba memory base) internal view returns (string memory res) {\n        bytes memory input = abi.encodePacked(base.r, base.g, base.b, base.a);\n        return input.toAscii();\n    }\n\n    function equalssss(IDotNugg.Rgba memory base, IDotNugg.Rgba memory next) internal view returns (bool res) {\n        res = base.a == next.a && base.r == next.r && base.g == next.g && base.b == next.b;\n    }\n}\n"
    },
    "contracts/test/Console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _sendLogPayload(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal view {\n        _sendLogPayload(abi.encodeWithSignature('log()'));\n    }\n\n    function logInt(int256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(int)', p0));\n    }\n\n    function logUint(uint256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint)', p0));\n    }\n\n    function logString(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string)', p0));\n    }\n\n    function logBool(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool)', p0));\n    }\n\n    function logAddress(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address)', p0));\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes)', p0));\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes1)', p0));\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes2)', p0));\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes3)', p0));\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes4)', p0));\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes5)', p0));\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes6)', p0));\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes7)', p0));\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes8)', p0));\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes9)', p0));\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes10)', p0));\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes11)', p0));\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes12)', p0));\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes13)', p0));\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes14)', p0));\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes15)', p0));\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes16)', p0));\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes17)', p0));\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes18)', p0));\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes19)', p0));\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes20)', p0));\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes21)', p0));\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes22)', p0));\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes23)', p0));\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes24)', p0));\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes25)', p0));\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes26)', p0));\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes27)', p0));\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes28)', p0));\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes29)', p0));\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes30)', p0));\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes31)', p0));\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes32)', p0));\n    }\n\n    function log(uint256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint)', p0));\n    }\n\n    function log(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string)', p0));\n    }\n\n    function log(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool)', p0));\n    }\n\n    function log(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address)', p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,uint)', p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,string)', p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,bool)', p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,address)', p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,uint)', p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,string)', p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,bool)', p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,address)', p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,uint)', p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,string)', p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,bool)', p0, p1));\n    }\n\n    function log(bool p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,address)', p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,uint)', p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,string)', p0, p1));\n    }\n\n    function log(address p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,bool)', p0, p1));\n    }\n\n    function log(address p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,address)', p0, p1));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,uint,uint)', p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,uint,string)', p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,uint,bool)', p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,uint,address)', p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,string,uint)', p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,string,string)', p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,string,bool)', p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,string,address)', p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,bool,uint)', p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,bool,string)', p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,bool,bool)', p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,bool,address)', p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,address,uint)', p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,address,string)', p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,address,bool)', p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,address,address)', p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,uint,uint)', p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,uint,string)', p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,uint,bool)', p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,uint,address)', p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,string,uint)', p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,string,string)', p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,string,bool)', p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,string,address)', p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,bool,uint)', p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,bool,string)', p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,bool,bool)', p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,bool,address)', p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,address,uint)', p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,address,string)', p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,address,bool)', p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,address,address)', p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,uint,uint)', p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,uint,string)', p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,uint,bool)', p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,uint,address)', p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,string,uint)', p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,string,string)', p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,string,bool)', p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,string,address)', p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,bool,uint)', p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,bool,string)', p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,bool,bool)', p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,bool,address)', p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,address,uint)', p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,address,string)', p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,address,bool)', p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,address,address)', p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,uint,uint)', p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,uint,string)', p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,uint,bool)', p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,uint,address)', p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,string,uint)', p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,string,string)', p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,string,bool)', p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,string,address)', p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,bool,uint)', p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,bool,string)', p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,bool,bool)', p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,bool,address)', p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,address,uint)', p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,address,string)', p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,address,bool)', p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,address,address)', p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,uint,uint,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,uint,uint,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,uint,uint,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,uint,uint,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,uint,string,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,uint,string,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,uint,string,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,uint,string,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,uint,bool,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,uint,bool,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,uint,bool,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,uint,bool,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,uint,address,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,uint,address,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,uint,address,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,uint,address,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,string,uint,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,string,uint,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,string,uint,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,string,uint,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,string,string,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,string,string,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,string,string,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,string,string,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,string,bool,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,string,bool,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,string,bool,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,string,bool,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,string,address,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,string,address,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,string,address,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,string,address,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,bool,uint,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,bool,uint,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,bool,uint,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,bool,uint,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,bool,string,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,bool,string,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,bool,string,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,bool,string,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,bool,bool,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,bool,bool,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,bool,bool,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,bool,bool,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,bool,address,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,bool,address,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,bool,address,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,bool,address,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,address,uint,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,address,uint,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,address,uint,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,address,uint,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,address,string,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,address,string,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,address,string,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,address,string,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,address,bool,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,address,bool,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,address,bool,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,address,bool,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,address,address,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,address,address,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,address,address,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,address,address,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,uint,uint,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,uint,uint,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,uint,uint,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,uint,uint,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,uint,string,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,uint,string,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,uint,string,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,uint,string,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,uint,bool,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,uint,bool,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,uint,bool,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,uint,bool,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,uint,address,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,uint,address,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,uint,address,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,uint,address,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,string,uint,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,string,uint,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,string,uint,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,string,uint,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,string,string,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,string,string,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,string,string,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,string,string,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,string,bool,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,string,bool,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,string,bool,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,string,bool,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,string,address,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,string,address,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,string,address,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,string,address,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,bool,uint,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,bool,uint,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,bool,uint,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,bool,uint,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,bool,string,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,bool,string,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,bool,string,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,bool,string,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,bool,bool,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,bool,bool,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,bool,bool,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,bool,bool,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,bool,address,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,bool,address,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,bool,address,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,bool,address,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,address,uint,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,address,uint,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,address,uint,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,address,uint,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,address,string,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,address,string,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,address,string,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,address,string,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,address,bool,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,address,bool,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,address,bool,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,address,bool,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,address,address,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,address,address,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,address,address,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,address,address,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,uint,uint,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,uint,uint,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,uint,uint,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,uint,uint,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,uint,string,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,uint,string,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,uint,string,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,uint,string,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,uint,bool,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,uint,bool,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,uint,bool,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,uint,bool,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,uint,address,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,uint,address,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,uint,address,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,uint,address,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,string,uint,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,string,uint,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,string,uint,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,string,uint,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,string,string,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,string,string,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,string,string,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,string,string,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,string,bool,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,string,bool,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,string,bool,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,string,bool,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,string,address,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,string,address,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,string,address,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,string,address,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,bool,uint,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,bool,uint,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,bool,uint,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,bool,uint,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,bool,string,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,bool,string,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,bool,string,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,bool,string,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,bool,bool,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,bool,bool,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,bool,bool,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,bool,bool,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,bool,address,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,bool,address,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,bool,address,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,bool,address,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,address,uint,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,address,uint,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,address,uint,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,address,uint,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,address,string,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,address,string,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,address,string,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,address,string,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,address,bool,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,address,bool,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,address,bool,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,address,bool,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,address,address,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,address,address,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,address,address,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,address,address,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,uint,uint,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,uint,uint,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,uint,uint,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,uint,uint,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,uint,string,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,uint,string,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,uint,string,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,uint,string,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,uint,bool,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,uint,bool,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,uint,bool,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,uint,bool,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,uint,address,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,uint,address,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,uint,address,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,uint,address,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,string,uint,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,string,uint,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,string,uint,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,string,uint,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,string,string,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,string,string,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,string,string,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,string,string,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,string,bool,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,string,bool,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,string,bool,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,string,bool,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,string,address,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,string,address,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,string,address,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,string,address,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,bool,uint,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,bool,uint,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,bool,uint,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,bool,uint,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,bool,string,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,bool,string,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,bool,string,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,bool,string,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,bool,bool,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,bool,bool,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,bool,bool,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,bool,bool,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,bool,address,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,bool,address,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,bool,address,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,bool,address,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,address,uint,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,address,uint,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,address,uint,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,address,uint,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,address,string,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,address,string,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,address,string,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,address,string,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,address,bool,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,address,bool,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,address,bool,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,address,bool,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,address,address,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,address,address,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,address,address,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,address,address,address)', p0, p1, p2, p3));\n    }\n}\n"
    },
    "contracts/libraries/Byte.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\n/**\n * @dev Bytes1 operations.\n */\nlibrary Byte {\n    bytes32 internal constant ALPHABET = '0123456789abcdef';\n\n    function toAscii(bytes1 value) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2);\n        for (uint256 i = 2; i > 0; i--) {\n            buffer[i - 1] = ALPHABET[uint8(value) & 0xf];\n            value >>= 4;\n        }\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/logic/Matrix.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../interfaces/IDotNugg.sol';\nimport '../libraries/Bytes.sol';\nimport '../logic/Rgba.sol';\n\nimport '../test/Console.sol';\n\nlibrary Matrix {\n    using Bytes for bytes;\n    using Rgba for IDotNugg.Rgba;\n\n    function create(uint8 width, uint8 height) internal view returns (IDotNugg.Matrix memory res) {\n        require(width % 2 == 1 && height % 2 == 1, 'ML:C:0');\n\n        res.data = new IDotNugg.Pixel[][](height);\n        for (uint8 i = 0; i < height; i++) {\n            res.data[i] = new IDotNugg.Pixel[](width);\n        }\n    }\n\n    function moveTo(\n        IDotNugg.Matrix memory matrix,\n        uint8 xoffset,\n        uint8 yoffset,\n        uint8 width,\n        uint8 height\n    ) internal view {\n        matrix.currentUnsetX = xoffset;\n        matrix.currentUnsetY = yoffset;\n        matrix.startX = xoffset;\n        matrix.width = width + xoffset;\n        matrix.height = height + yoffset;\n    }\n\n    function next(IDotNugg.Matrix memory matrix) internal view returns (bool res) {\n        res = next(matrix, matrix.width);\n    }\n\n    function next(IDotNugg.Matrix memory matrix, uint8 width) internal view returns (bool res) {\n        if (matrix.init) {\n            if (width <= matrix.currentUnsetX + 1) {\n                if (matrix.height == matrix.currentUnsetY + 1) {\n                    return false;\n                }\n                matrix.currentUnsetX = matrix.startX; // 0 by default\n                matrix.currentUnsetY++;\n            } else {\n                matrix.currentUnsetX++;\n            }\n        } else {\n            matrix.init = true;\n        }\n        res = true;\n    }\n\n    function current(IDotNugg.Matrix memory matrix) internal view returns (IDotNugg.Pixel memory res) {\n\n\n        res = matrix.data[matrix.currentUnsetY][matrix.currentUnsetX];\n    }\n\n    function setCurrent(IDotNugg.Matrix memory matrix, IDotNugg.Pixel memory pix) internal view {\n        matrix.data[matrix.currentUnsetY][matrix.currentUnsetX] = pix;\n    }\n\n    function resetIterator(IDotNugg.Matrix memory matrix) internal view {\n        matrix.currentUnsetX = 0;\n        matrix.currentUnsetY = 0;\n        matrix.startX = 0;\n        matrix.init = false;\n    }\n\n    function moveBack(IDotNugg.Matrix memory matrix) internal view {\n        matrix.width = uint8(matrix.data[0].length);\n        matrix.height = uint8(matrix.data.length);\n    }\n\n    function reset(IDotNugg.Matrix memory matrix) internal view {\n        for (; next(matrix); ) if (current(matrix).exists) delete matrix.data[matrix.currentUnsetY][matrix.currentUnsetX];\n        matrix.width = 0;\n        matrix.height = 0;\n        resetIterator(matrix);\n    }\n\n    function set(\n        IDotNugg.Matrix memory matrix,\n        bytes memory data,\n        IDotNugg.Pixel[] memory pallet,\n        uint8 groupWidth,\n        uint8 groupHeight\n    ) internal view {\n        uint256 totalLength = 0;\n        matrix.height = groupHeight;\n        for (uint256 i = 0; i < data.length; i++) {\n            (uint8 colorKey, uint8 len) = data.toUint4(i);\n            len++;\n\n            totalLength += len;\n            for (uint256 j = 0; j < len; j++) {\n                next(matrix, groupWidth);\n                setCurrent(matrix, pallet[colorKey]);\n\n            }\n\n        }\n\n\n\n\n\n        require(totalLength % groupWidth == 0, 'MTRX:SET:0');\n        require(totalLength / groupWidth == groupHeight, 'MTRX:SET:1');\n\n        matrix.width = groupWidth;\n        matrix.height = uint8(totalLength / groupWidth);\n\n        resetIterator(matrix);\n    }\n\n    function addRowsAt(\n        IDotNugg.Matrix memory matrix,\n        uint8 index,\n        uint8 amount\n    ) internal view {\n        require(index < matrix.data.length, 'MAT:ARA:0');\n        for (uint256 j = matrix.width; j > index; j--) {\n            if (j < index) break;\n            if (matrix.data[j].length > 0) matrix.data[j + amount] = matrix.data[j];\n        }\n        // \"<=\" is because this loop needs to run [amount] times\n        for (uint256 j = index + 1; j <= index + amount; j++) {\n            //\n            matrix.data[j] = matrix.data[index];\n        }\n        matrix.height += amount;\n    }\n\n    function addColumnsAt(\n        IDotNugg.Matrix memory matrix, /// cowboy hat\n        uint8 index,\n        uint8 amount\n    ) internal view {\n        require(index < matrix.data[0].length, 'MAT:ACA:0');\n        for (uint256 i = 0; i < matrix.width; i++) {\n            for (uint256 j = matrix.width; j > index; j--) {\n                if (j < index) break;\n                //  if (matrix.data[i][j].exists) @note - do not completly understand this.. but it fixes a bug\n                matrix.data[i][j + amount] = matrix.data[i][j];\n            }\n            // \"<=\" is because this loop needs to run [amount] times\n            for (uint256 j = index + 1; j <= index + amount; j++) {\n                matrix.data[i][j] = matrix.data[i][index];\n            }\n        }\n        matrix.width += amount;\n    }\n}\n"
    },
    "contracts/logic/Anchor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../interfaces/IDotNugg.sol';\nimport './Matrix.sol';\nimport '../test/Console.sol';\n\nlibrary Anchor {\n    using Matrix for IDotNugg.Matrix;\n\n    /*\n     * @notice AKA fuck\n     * @dev this is where we implement the logic you wrote in go\n     */\n\n    function convertReceiversToAnchors(IDotNugg.Mix memory mix) internal view {\n        IDotNugg.Coordinate[] memory anchors;\n        uint8 stat = 0;\n        uint8 cal = 0;\n\n        for (uint8 i = 0; i < mix.version.calculatedReceivers.length; i++) {\n            IDotNugg.Coordinate memory coordinate;\n            if (mix.version.staticReceivers[i].exists) {\n                stat++;\n                coordinate = mix.version.staticReceivers[i];\n            } else if (mix.version.calculatedReceivers[i].exists) {\n                cal++;\n                if (anchors.length == 0) anchors = getAnchors(mix.matrix);\n                coordinate = calculateReceiverCoordinate(mix, mix.version.calculatedReceivers[i], anchors);\n                fledgeOutTheRluds(mix, coordinate, i);\n            }\n        }\n\n\n\n    }\n\n    // receiver := { feature: EYES, zindex: 2, yoffset: +2 }\n    // receiver := { feature: EARS, zindex: 2, yoffset: +2 }\n    // receiver := { feature: GLASSES, zindex: 2, yoffset: +2 }\n    // receiver := { feature: MOUTH, zindex: 3, yoffset: +0 }\n    // receiver := { feature: HAIR, zindex: 1, yoffset: +1 }\n    // receiver := { feature: SAUCE, zindex: 4, yoffset: +0 }\n    // receiver := { feature: HAT, zindex: 1, yoffset: +1 }\n    // receiver := { feature: SPECIAL, zindex: 0, yoffset: +0 }\n\n    function fledgeOutTheRluds(\n        IDotNugg.Mix memory mix,\n        IDotNugg.Coordinate memory coordinate,\n        uint8 index\n    ) internal view {\n        IDotNugg.Rlud memory radii;\n        while (coordinate.a < mix.matrix.width - 1 && mix.matrix.data[coordinate.b][coordinate.a + (radii.r + 1)].exists) {\n            radii.r++;\n        }\n        while (coordinate.a != 0 && mix.matrix.data[coordinate.b][coordinate.a - (radii.l + 1)].exists) {\n            radii.l++;\n        }\n        while (coordinate.b != 0 && mix.matrix.data[coordinate.b - (radii.u + 1)][coordinate.a].exists) {\n            radii.u++;\n        }\n        while (coordinate.b < mix.matrix.height - 1 && mix.matrix.data[coordinate.b + (radii.d + 1)][coordinate.a].exists) {\n            radii.d++;\n        }\n\n        if (!mix.receivers[index].coordinate.exists) {\n            mix.receivers[index] = IDotNugg.Anchor({radii: radii, coordinate: coordinate});\n        }\n\n\n\n\n    }\n\n    function calculateReceiverCoordinate(\n        IDotNugg.Mix memory mix,\n        IDotNugg.Coordinate memory calculatedReceiver,\n        IDotNugg.Coordinate[] memory anchors\n    ) internal view returns (IDotNugg.Coordinate memory coordinate) {\n        coordinate.a = anchors[calculatedReceiver.a].a;\n        coordinate.b = anchors[calculatedReceiver.a].b;\n        coordinate.exists = true;\n\n        if (calculatedReceiver.b < 8) {\n            coordinate.b = coordinate.b - calculatedReceiver.b;\n        } else {\n            coordinate.b = coordinate.b + (8 - calculatedReceiver.b);\n        }\n\n        while (!mix.matrix.data[coordinate.b][coordinate.a].exists) {\n            if (anchors[0].b > coordinate.b) {\n                coordinate.b++;\n            } else {\n                coordinate.b--;\n            }\n        }\n        return coordinate;\n    }\n\n    function getAnchors(IDotNugg.Matrix memory matrix) internal view returns (IDotNugg.Coordinate[] memory anchors) {\n        (uint8 topOffset, uint8 bottomOffset, IDotNugg.Coordinate memory center) = getBox(matrix);\n\n        anchors = new IDotNugg.Coordinate[](5);\n\n        anchors[0] = center; // center\n\n        anchors[1] = IDotNugg.Coordinate({a: center.a, b: center.b - topOffset, exists: true}); // top\n\n        uint8 upperOffset = topOffset;\n        if (upperOffset % 2 != 0) {\n            upperOffset++;\n        }\n        anchors[2] = IDotNugg.Coordinate({a: center.a, b: center.b - (upperOffset / 2), exists: true}); // inner top\n\n        uint8 lowerOffset = bottomOffset;\n        if (lowerOffset % 2 != 0) {\n            lowerOffset++;\n        }\n        anchors[3] = IDotNugg.Coordinate({a: center.a, b: center.b + (lowerOffset / 2), exists: true}); // inner bottom\n\n        anchors[4] = IDotNugg.Coordinate({a: center.a, b: center.b + bottomOffset, exists: true}); // inner bottom\n    }\n\n    function getBox(IDotNugg.Matrix memory matrix)\n        internal\n        view\n        returns (\n            uint8 topOffset,\n            uint8 bottomOffset,\n            IDotNugg.Coordinate memory center\n        )\n    {\n        center.a = (matrix.width) / 2;\n        center.b = (matrix.height) / 2;\n        center.exists = true;\n\n        bool topFound = false;\n        bool bottomFound = false;\n        bool sideFound = false;\n        bool shouldExpandSide = true;\n\n        topOffset = 1;\n        bottomOffset = 1;\n        uint8 sideOffset = 1;\n\n        bool allFound = false;\n\n        while (!allFound) {\n            if (shouldExpandSide = !shouldExpandSide && !sideFound) {\n                if (\n                    matrix.data[center.b - topOffset][center.a - (sideOffset + 1)].exists && // potential top left\n                    matrix.data[center.b - topOffset][center.a + (sideOffset + 1)].exists && // potential top right\n                    matrix.data[center.b + bottomOffset][center.a - (sideOffset + 1)].exists && // potential bot left\n                    matrix.data[center.b + bottomOffset][center.a + (sideOffset + 1)].exists // potential bot right\n                ) {\n                    sideOffset++;\n                } else {\n                    sideFound = true;\n                }\n            }\n            if (!topFound) {\n                if (\n                    center.b - topOffset > 0 &&\n                    matrix.data[center.b - (topOffset + 1)][center.a - sideOffset].exists && // potential top left\n                    matrix.data[center.b - (topOffset + 1)][center.a + sideOffset].exists // potential top right\n                ) {\n                    topOffset++;\n                } else {\n                    topFound = true;\n                }\n            }\n            if (!bottomFound) {\n                if (\n                    center.b + bottomOffset < matrix.height - 1 &&\n                    matrix.data[center.b + (bottomOffset + 1)][center.a - sideOffset].exists && // potential bot left\n                    matrix.data[center.b + (bottomOffset + 1)][center.a + sideOffset].exists // potenetial bot right\n                ) {\n                    bottomOffset++;\n                } else {\n                    bottomFound = true;\n                }\n            }\n            if (bottomFound && topFound && sideFound) allFound = true;\n        }\n\n        if (topOffset != bottomOffset) {\n            uint8 newHeight = topOffset + bottomOffset + 1;\n            uint8 relativeCenter = (newHeight % 2 == 0 ? newHeight : newHeight + 1) / 2;\n            uint8 newCenter = relativeCenter + center.b - 1 - topOffset;\n            if (newCenter > center.b) {\n                uint8 diff = newCenter - center.b;\n                topOffset += diff;\n                bottomOffset > diff ? bottomOffset = bottomOffset - diff : bottomOffset = diff - bottomOffset;\n            } else {\n                uint8 diff = center.b - newCenter;\n                topOffset > diff ? topOffset = topOffset - diff : topOffset = diff - topOffset;\n                bottomOffset += diff;\n            }\n            center.b = newCenter;\n        }\n    }\n}\n// Whatcha gonna do with all that junk\n// All that junk inside your trunk\n// I'ma get get get get you drunk\n// Get you love drunk off my hump\n// My hump my hump my hump my hump my hump\n// My hump my hump my hump my lovely little lumps\n// Check it out\n// I drive these brothers crazy\n// I do it on the daily\n// They treat me really nicely\n// They buy me all these ice\n// Dolce and Gabbana\n// Fendi and Madonna\n// Caring they be sharin'\n// All their money got me wearing fly\n// Whether I ain't askin'\n// They say they love mah ass in\n// Seven jeans\n// True religion\n// I say no\n// But they keep givin'\n// So I keep on takin'\n// And no I ain't takin'\n// We can keep on datin'\n// Now keep on demonstratin'\n// My love my love my love my love\n// You love my lady lumps\n// My hump my hump my hump\n// My humps they got you\n// She's got me spending\n// Oh, spending all your money on me\n// And spending time on me\n// She's got me spending\n// Oh, spending all your money on me\n// Uh on me on me\n// Whatcha gonna do with all that junk\n// All that junk inside that trunk\n// I'm a get get get get you drunk\n// Get you love drunk off my hump\n// Whatcha gonna do with all that ass\n// All that ass inside your jeans\n// I'm a make make make make you scream\n// Make you scream make you scream\n// 'Cause of my humps my hump my hump my hump\n// My hump my hump my hump my lovely lady lumps\n// Check it out\n// I met a girl down at the disco\n// She said hey hey hey ya lets go\n// I can be ya baby, you could be my honey\n// Let's spend time not money\n// And mix your milk with my coco puff\n// Milky milky coco\n// Mix your milk with my coco puff\n// Milky milky\n// Right\n// They say I'm really sexy\n// The boys they wanna sex me\n// They always standin' next to me\n// Always dancin' next to me\n// Tryin' a feel my hump hump\n// Lookin' at my lump lump\n// You can look but you can't touch it\n// If you touch it\n// I'm a start some drama\n// You don't want no drama\n// No no drama no no no no drama\n// So don't pull on my hand boy\n// You ain't my man boy\n// I'm just tryin' a dance boy\n// And move my hump\n// My hump my hump my hump my hump\n// My hump my hump my hump my hump my hump my hump\n// My lovely lady lumps\n// My lovely lady lumps my lovely lady lumps\n// In the back and in the front\n// My loving got you\n// She's got me spending\n// Oh, spending all your money on me\n// And spending time on me\n// She's got me spending\n// Oh, spending all your money on me\n// Uh on me on me\n// Whatcha gonna do with all that junk\n// All that junk inside that trunk\n// I'm a get get get get you drunk\n// Get you love drunk off my hump\n// Whatcha gonna do with all that ass\n// All that ass inside your jeans\n// I'm a make make make make you scream\n// Make you scream make you scream\n// Whatcha gonna do with all that junk\n// All that junk inside that trunk\n// I'm a get get get get you drunk\n// Get you love drunk off this hump\n// Whatcha gonna do with all that breast\n// All that breast inside that shirt\n// I'm a make make make make you work\n// Make you work work make you work\n// She's got me spending\n// Oh, spending all your money on me\n// And spending time on me\n// She's got me spending\n// Oh, spending all your money on me\n// Uh on me on me\n"
    },
    "contracts/erc165/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/test/SystemTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../../contracts/libraries/BytesLib.sol';\nimport '../../contracts/logic/Rgba.sol';\nimport '../../contracts/logic/Decoder.sol';\nimport '../../contracts/libraries/Base64.sol';\n\nimport '../../contracts/interfaces/INuggIn.sol';\nimport '../../contracts/test/Console.sol';\n\nimport '../logic/Matrix.sol';\n\ncontract SystemTest {\n    using BytesLib for bytes;\n    //  using Rgba for IDotNugg.Rgba;\n\n    bytes sample1 =\n        hex'444f544e554747c7cc00000e002c00f19325e500eb8a12e500f9b042e500c96619e500a84b1ee500f49f35e52121101000001720fe20ff20fd32fa11fc40f912fb00f80f0f0f0f0f0f0f0f0f0f0e5d0f005130633322520f5030653224500f5031663222500f5031673222500d5131661035500d50336536500d50346535500d50346535500d503111306634500d5034661033500d5035651132500d50346733500d50346a30500d50356a500d50356a500e5032116a500e50341068510e5034116224500f504033601027500f50402032632341500f50412031632341500f522031612341510f025b0f0f0f0f0f0f0f0f0e';\n\n    bytes sample2 =\n        hex'444f544e554747c072050010001a003903000000990300eae19911050803010c06010001040404000f05140a112211041102122012021f1f1313060905010e06020001040405000f05160a1809122212041101142014011f1f17';\n\n    bytes sample3 =\n        hex'444f544e5547475295030010001a0038020000009902e100e19909040401010505000001050500000f1300142112211121100010211400130d050601010707000001090900000f140215221002102211221422112210021022150214';\n\n    bytes sample4 =\n        hex'444f544e5547478ca8030010001f004802f85c0f9902fb1a069902ffdb3c990a040401010406000001030300000f01100310021020021020011020302100203021001020021020010f050601010509000001050500000f0110061004102010041020100210203023001020302300102010041020100410061003';\n\n    bytes sampleCollection =\n        hex'444f544e5547472109000d004d444f544e55474753d9020010001a002601000000ff01ffffffff0702030000000711021302110b030500010606000001090900000f2204231020042010230422444f544e554747dc75060010001a0022010000009901ffffffff0301010000000712050302010000071500200010001200';\n\n    function tfizzle(IDotNugg _contract, IFileResolver _resolver) public view returns (string memory res) {\n        //   IDotNugg.Item memory item = Decoder.parseItem(sample1);\n        //   IDotNugg.Matrix memory mat = Matrix.create(33, 33);\n        //   Matrix.set(mat, item.versions[0].data, item.pallet, item.versions[0].width);\n        bytes[] memory sampleItems = new bytes[](3);\n\n        sampleItems[0] = sample1;\n        sampleItems[1] = sample2;\n        sampleItems[2] = sample3;\n        //   sampleItems[3] = sample4;\n\n        //   res = _contract.nuggify(sampleCollection, sampleItems, address(_resolver), '');\n        IDotNugg.Matrix memory temp = Matrix.create(17, 5);\n        IDotNugg.Item memory t2 = Decoder.parseItem(sample2, 10);\n        Matrix.set(temp, t2.versions[0].data, t2.pallet, t2.versions[0].width, t2.versions[0].height);\n        (bytes memory tmp, string memory file) = _resolver.resolveFile(temp, '');\n        //   (bytes memory byt, string memory file) = _resolver.resolveFile(temp, '');\n        res = Base64.encode(tmp, file);\n        //   General.convert(sampleCollection, sampleItems, address(0), '');\n        //   assertTrue(item.feature == 0);\n        //   assertTrue(item.versions.length == 1);\n        //   assertTrue(item.versions[0].width == 33);\n\n        //   assertTrue(item.pallet.length == 7);\n        //   IDotNugg.Matrix memory mat = Matrix.create(33, 33);\n\n        //   Matrix.set(mat, item.versions[0].data, item.pallet, item.versions[0].width);\n\n        //   assertTrue(mat.width == 33);\n        //  IDotNugg.Item memory item = Decoder.parseItem(sample1);\n    }\n\n    function tfull(IDotNugg _contract, IFileResolver _resolver) public view returns (string memory res) {\n        //   IDotNugg.Item memory item = Decoder.parseItem(sample1);\n        //   IDotNugg.Matrix memory mat = Matrix.create(33, 33);\n        //   Matrix.set(mat, item.versions[0].data, item.pallet, item.versions[0].width);\n        bytes[] memory sampleItems = new bytes[](4);\n\n        sampleItems[0] = sample1;\n        sampleItems[1] = sample2;\n        sampleItems[2] = sample3;\n        sampleItems[3] = sample4;\n\n        res = _contract.nuggify(sampleCollection, sampleItems, address(_resolver), 'the name', 'the desc', 245, hex'02', '');\n        //   IDotNugg.Matrix memory temp = Matrix.create(17, 5);\n        //   IDotNugg.Item memory t2 = Decoder.parseItem(sample2, 10);\n        //   Matrix.set(temp, t2.versions[0].data, t2.pallet, t2.versions[0].width, t2.versions[0].height);\n        //   (bytes memory tmp, string memory file) = _resolver.resolveFile(temp, '');\n        //   //   (bytes memory byt, string memory file) = _resolver.resolveFile(temp, '');\n        //   res = Base64.encode(tmp, file);\n        //   General.convert(sampleCollection, sampleItems, address(0), '');\n        //   assertTrue(item.feature == 0);\n        //   assertTrue(item.versions.length == 1);\n        //   assertTrue(item.versions[0].width == 33);\n\n        //   assertTrue(item.pallet.length == 7);\n        //   IDotNugg.Matrix memory mat = Matrix.create(33, 33);\n\n        //   Matrix.set(mat, item.versions[0].data, item.pallet, item.versions[0].width);\n\n        //   assertTrue(mat.width == 33);\n        //  IDotNugg.Item memory item = Decoder.parseItem(sample1);\n    }\n}\n"
    },
    "contracts/test/NuggInTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../../contracts/libraries/BytesLib.sol';\nimport '../../contracts/logic/Rgba.sol';\nimport '../../contracts/logic/Decoder.sol';\nimport '../../contracts/interfaces/INuggIn.sol';\nimport '../../contracts/test/Console.sol';\n\nimport '../logic/Matrix.sol';\n\ncontract NuggInTest {\n    using BytesLib for bytes;\n    //  using Rgba for IDotNugg.Rgba;\n\n    bytes sample1 =\n        hex'6e6e6e6e75676709c800000e002c00f19325e500eb8a12e500f9b042e500c96619e500a84b1ee500f49f35e52121000000001723fe23ff23fd23fa23fc23f923fb23f80f0f0f0f0f0f0f0f0f0f0e5c0f015130633222520f005030653124500f005031653222500f005031663222500e5131651035500e50336436500e50346435500e50346435500e503111306534500e5034651033500e5035641132500e50346633500e50346930500e503569500e503569500f50321169500f50341067510f5034116124500f00504033601026500f0050402032622341500f0050412031622341500f00522031612241510f035a0f0f0f0f0f0f0f0f0f';\n\n    bytes sample2 =\n        hex'6e6e6e6e7567670613050010001a003100000000990000eae1991105090500000705140a112211041102122012021f1f1313060a0600000705160a1809122212041101142014011f1f17';\n\n    bytes sample3 =\n        hex'6e6e6e6e756767289c030010001a0035000000009900e100e1990a04060200000700130015211221100010211000102110001300130e05080300000700140214001022100210221222142210001022100210221000140214';\n\n    bytes sample4 =\n        hex'6e6e6e6e7567672e66030010001f004000f85c0f9900fb1a069900ffdb3c990a04070300000701100310021020021020011020302100203021001020021020010f0507030000070110061004102010041020100210203023001020302300102010041020100410061003';\n\n    bytes sampleCollection =\n        hex'6e6e6e6e7567672109000d00456e6e6e6e7567672ab3020010001a002600000000ff00ffffffff0702040100000711021302110b03060100000722042310200420102304226e6e6e6e7567673431060010001a0022000000009900ffffffff03010201000007120501030100000714';\n\n    function tfizzle(IDotNugg _contract, IFileResolver _resolver) public {\n        //   IDotNugg.Item memory item = Decoder.parseItem(sample1);\n        //   IDotNugg.Matrix memory mat = Matrix.create(33, 33);\n        //   Matrix.set(mat, item.versions[0].data, item.pallet, item.versions[0].width);\n        bytes[] memory sampleItems = new bytes[](1);\n\n        sampleItems[0] = sample1;\n        //   sampleItems[1] = sample2;\n        //   sampleItems[2] = sample3;\n        //   sampleItems[3] = sample4;\n\n        string memory res = _contract.nuggify(sampleCollection, sampleItems, address(_resolver), 'the name', 'the desc', 245, hex'02', '');\n\n        //   General.convert(sampleCollection, sampleItems, address(0), '');\n        //   assertTrue(item.feature == 0);\n        //   assertTrue(item.versions.length == 1);\n        //   assertTrue(item.versions[0].width == 33);\n\n        //   assertTrue(item.pallet.length == 7);\n        //   IDotNugg.Matrix memory mat = Matrix.create(33, 33);\n\n        //   Matrix.set(mat, item.versions[0].data, item.pallet, item.versions[0].width);\n\n        //   assertTrue(mat.width == 33);\n        //  IDotNugg.Item memory item = Decoder.parseItem(sample1);\n    }\n}\n"
    },
    "contracts/test/DecoderTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../../contracts/libraries/BytesLib.sol';\nimport '../../contracts/logic/Rgba.sol';\nimport '../../contracts/logic/Decoder.sol';\nimport '../../contracts/interfaces/INuggIn.sol';\nimport '../../contracts/test/Console.sol';\nimport '../../contracts/logic/Matrix.sol';\nimport '../../contracts/libraries/Base64.sol';\n\ncontract DecoderTest {\n    using BytesLib for bytes;\n    //  using Rgba for IDotNugg.Rgba;\n    bytes sample1 =\n        hex'444f544e55474783c800000e002c00f19325e500eb8a12e500f9b042e500c96619e500a84b1ee500f49f35e52121101000001722fe22ff22fd30fa11fc40f911fb00f80f0f0f0f0f0f0f0f0f0f0e5c0f015130633222520f005030653124500f005031653222500f005031663222500e5131651035500e50336436500e50346435500e50346435500e503111306534500e5034651033500e5035641132500e50346633500e50346930500e503569500e503569500f50321169500f50341067510f5034116124500f00504033601026500f0050402032622341500f0050412031622341500f00522031612241510f035a0f0f0f0f0f0f0f0f0f';\n\n    bytes sample2 =\n        hex'444f544e5547477d0f050010001a003100000000990000eae1991105080400000705140a112211041102122012021f1f131306090500000705160a1809122212041101142014011f1f17';\n\n    bytes sample3 =\n        hex'444f544e5547479cbe030010001a0039000000009900e100e1990a0405010001040401020b00130015211221100010211000102110001300130e0507010001050501030b00140214001022100210221222142210001022100210221000140214';\n\n    bytes sample4 =\n        hex'444f544e554747337f030010001f004400f85c0f9900fb1a069900ffdb3c99090304010001030301020b01100310021020021020011020302100203021001020021020010e0406010001050501030b0110061004102010041020100210203023001020302300102010041020100410061003';\n\n    bytes sampleCollection =\n        hex'444f544e5547472109000d0045444f544e554747d3af020010001a002600000000ff00ffffffff0702030000000711021302110b0305000000072204231020042010230422444f544e5547470e2d060010001a0022000000009900ffffffff03010100000007120501020000000714';\n\n    function tfizzle(IDotNugg _contract, IFileResolver _resolver) public {\n        //   IDotNugg.Item memory item = Decoder.parseItem(sample1);\n        //   IDotNugg.Matrix memory mat = Matrix.create(33, 33);\n        //   Matrix.set(mat, item.versions[0].data, item.pallet, item.versions[0].width);\n        //   bytes[] memory sampleItems = new bytes[](1);\n\n        //   sampleItems[0] = sample1;\n        //   sampleItems[1] = sample2;\n        //   sampleItems[2] = sample3;\n        //   sampleItems[3] = sample4;\n\n        IDotNugg.Item memory item = Decoder.parseItem(sample1, 30);\n        IDotNugg.Matrix memory matrix = Matrix.create(33, 33);\n        Matrix.set(matrix, item.versions[0].data, item.pallet, item.versions[0].width, item.versions[0].height);\n        (bytes memory res, string memory file) = _resolver.resolveFile(matrix, '');\n        string memory image = Base64.encode(res, file);\n        //   string memory res = _contract.nuggify(sampleCollection, sampleItems, address(_resolver), '');\n\n        //   General.convert(sampleCollection, sampleItems, address(0), '');\n        //   assertTrue(item.feature == 0);\n        //   assertTrue(item.versions.length == 1);\n        //   assertTrue(item.versions[0].width == 33);\n\n        //   assertTrue(item.pallet.length == 7);\n        //   IDotNugg.Matrix memory mat = Matrix.create(33, 33);\n\n        //   Matrix.set(mat, item.versions[0].data, item.pallet, item.versions[0].width);\n\n        //   assertTrue(mat.width == 33);\n        //  IDotNugg.Item memory item = Decoder.parseItem(sample1);\n    }\n}\n"
    },
    "contracts/resolvers/SvgFileResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '.././interfaces/IDotNugg.sol';\nimport '.././interfaces/INuggIn.sol';\nimport '.././erc165/IERC165.sol';\nimport '../../contracts/logic/Rgba.sol';\nimport '../../contracts/logic/Matrix.sol';\nimport '../../contracts/libraries/Uint.sol';\n\n// import '../erc165/ERC165.sol';\n\n// /**\n//  * @dev Bytes1 operations.\n//  */\ncontract SvgFileResolver is IFileResolver {\n    using Rgba for IDotNugg.Rgba;\n    using Uint256 for uint256;\n\n    using Matrix for IDotNugg.Matrix;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view override(IFileResolver) returns (bool) {\n        return interfaceId == type(IFileResolver).interfaceId || interfaceId == type(IERC165).interfaceId;\n    }\n\n    function resolveFile(IDotNugg.Matrix memory matrix, bytes memory data) public view override returns (bytes memory res, string memory fileType) {\n        uint256 svgWidth = uint256(matrix.width) * 10;\n        bytes memory header = abi.encodePacked(\n            \"<svg viewBox='0 0 \",\n            svgWidth.toString(),\n            ' ',\n            svgWidth.toString(),\n            \"' width='\",\n            svgWidth.toString(),\n            \"' height='\",\n            svgWidth.toString(),\n            \"' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'>\\n\"\n        );\n        bytes memory rects = getSvgRects(matrix, 10);\n        return (abi.encodePacked(header, rects, '</svg>'), 'svg');\n    }\n\n    function getSvgRects(IDotNugg.Matrix memory matrix, uint256 pixelWidth) internal view returns (bytes memory res) {\n        IDotNugg.Rgba memory lastRgba;\n        uint8 lastX;\n\n        //   uint256 xtracker;\n        uint256 count = 1;\n        while (matrix.next()) {\n            if ((lastRgba.equalssss(matrix.current().rgba) && matrix.currentUnsetX < matrix.data[matrix.currentUnsetY].length)) {\n                //  lastRgba = matrix.current().rgba;\n                count++;\n                continue;\n            }\n            if (lastRgba.a != 0) {\n                res = abi.encodePacked(res, getRekt(lastRgba, lastX * pixelWidth, matrix.currentUnsetY * pixelWidth, pixelWidth, count * pixelWidth));\n            }\n            lastRgba = matrix.current().rgba;\n            lastX = matrix.currentUnsetX;\n            // xtracker = 0;\n            count = 1;\n        }\n\n        res = abi.encodePacked(res, getRekt(matrix.current().rgba, lastX * pixelWidth, matrix.currentUnsetY * pixelWidth, pixelWidth, count * pixelWidth));\n\n        //   while (!done) {\n        //       lastPix = matrix.current();\n        //       while (!done) {\n        //           if (!matrix.next()) {\n        //               done = true;\n        //               break;\n        //           }\n        //           if (!lastPix.rgba.equalssss(matrix.current().rgba)) break;\n\n        //           count++;\n        //           if (count == matrix.width - 1) break;\n        //       }\n        //       if (lastPix.rgba.a != 0) {\n        //           if (matrix.currentUnsetX < count) {\n        //               uint256 diff = count - matrix.currentUnsetX;\n\n\n\n        //               res = abi.encodePacked(\n        //                   res,\n        //                   getRekt(lastPix.rgba, (matrix.width - diff) * pixelWidth, (matrix.currentUnsetY - 1) * pixelWidth, pixelWidth, diff * pixelWidth),\n        //                   getRekt(lastPix.rgba, 0, (matrix.currentUnsetY) * pixelWidth, pixelWidth, (count - diff) * pixelWidth)\n        //               );\n        //               //  res = abi.encodePacked(res, getRekt(lastPix.rgba, 0, (lastPix.currentUnsetY) * pixelWidth, pixelWidth, (count - diff) * pixelWidth));\n        //           } else {\n        //               res = abi.encodePacked(\n        //                   res,\n        //                   getRekt(lastPix.rgba, (matrix.width - count) * pixelWidth, (matrix.currentUnsetY - 1) * pixelWidth, pixelWidth, count * pixelWidth)\n        //               );\n        //           }\n        //       }\n        //   }\n    }\n\n    function getRekt(\n        IDotNugg.Rgba memory rgba,\n        uint256 x,\n        uint256 y,\n        uint256 xlen,\n        uint256 ylen\n    ) internal view returns (bytes memory res) {\n        if (rgba.a == 0) return '';\n        //   (rgba, ) = rgba.combine(IDotNugg.Rgba({r: 0, g: 255, b: 0, a: 99}));\n        res = abi.encodePacked(\n            \"\\t<rect fill='#\",\n            rgba.toAscii(),\n            \"' x='\",\n            x.toString(),\n            \"' y='\",\n            y.toString(),\n            \"' height='\",\n            xlen.toString(),\n            \"' width='\",\n            ylen.toString(),\n            \"'/>\\n\"\n        );\n    }\n}\n"
    },
    "contracts/resolvers/GroupNuggIn.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '.././interfaces/IDotNugg.sol';\nimport '.././interfaces/INuggIn.sol';\nimport '.././erc165/IERC165.sol';\nimport '../../contracts/logic/Rgba.sol';\nimport '../../contracts/logic/Matrix.sol';\nimport '../../contracts/libraries/Uint.sol';\n\n// import '../erc165/ERC165.sol';\n\n// /**\n//  * @dev Bytes1 operations.\n//  */\ncontract GroupNuggIn is IFileResolver {\n    using Rgba for IDotNugg.Rgba;\n    using Uint256 for uint256;\n\n    using Matrix for IDotNugg.Matrix;\n\n    function combineBros(uint8 n1, uint8 n2) internal view returns (bytes1 res) {\n        uint8 one = n1 << 4;\n        res = bytes1(one | n2);\n\n\n\n\n\n\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view override(IFileResolver) returns (bool) {\n        return interfaceId == type(IFileResolver).interfaceId || interfaceId == type(IERC165).interfaceId;\n    }\n\n    function resolveFile(IDotNugg.Matrix memory matrix, bytes memory) public view override returns (bytes memory res, string memory fileType) {\n        bytes memory rects = getSvgRects(matrix, 10);\n        return (rects, 'groups');\n    }\n\n    function getPixelIndex(IDotNugg.Pixel[] memory mapper, IDotNugg.Pixel memory pixel) internal view returns (uint8 res) {\n        if (pixel.rgba.a == 0) return 0;\n        for (uint8 i = 1; i < mapper.length; i++) {\n            if (mapper[i].rgba.equalssss(pixel.rgba)) {\n                return i;\n            }\n            if (!mapper[i].exists) {\n                //  mapper[i] = pixel;\n                res = i;\n                break;\n            }\n        }\n\n        mapper[res] = pixel;\n        mapper[res].exists = true;\n    }\n\n    function getSvgRects(IDotNugg.Matrix memory matrix, uint256) internal view returns (bytes memory res) {\n        IDotNugg.Pixel memory lastPixel;\n        uint8 lastX;\n\n        IDotNugg.Pixel[] memory mapper = new IDotNugg.Pixel[](50);\n\n        bytes memory tmp = new bytes(1000);\n\n        //   uint256 xtracker;\n\n        uint256 restracker = 0;\n        uint8 count = 1;\n        while (matrix.next()) {\n            if (lastPixel.rgba.equalssss(matrix.current().rgba) && count < 256) {\n                //  lastPixel = matrix.current().rgba;\n                count++;\n                continue;\n            }\n            // if (lastPixel.rgba.a != 0) {\n            tmp[restracker++] = bytes1(getPixelIndex(mapper, lastPixel));\n            tmp[restracker++] = bytes1(count - 1);\n            // res = abi.encodePacked(res, combineBros(getPixelIndex(mapper, lastPixel), count));\n            // }\n            lastPixel = matrix.current();\n            lastX = matrix.currentUnsetX;\n            // xtracker = 0;\n            count = 1;\n        }\n\n        //   res = abi.encodePacked(res, combineBros(getPixelIndex(mapper, lastPixel), count));\n        tmp[restracker++] = bytes1(getPixelIndex(mapper, lastPixel));\n        tmp[restracker++] = bytes1(count - 1);\n\n        res = new bytes(restracker + 1);\n        for (uint256 i = 0; i < res.length; i++) {\n            res[i] = tmp[i];\n        }\n\n        //   while (!done) {\n        //       lastPix = matrix.current();\n        //       while (!done) {\n        //           if (!matrix.next()) {\n        //               done = true;\n        //               break;\n        //           }\n        //           if (!lastPix.rgba.equalssss(matrix.current().rgba)) break;\n\n        //           count++;\n        //           if (count == matrix.width - 1) break;\n        //       }\n        //       if (lastPix.rgba.a != 0) {\n        //           if (matrix.currentUnsetX < count) {\n        //               uint256 diff = count - matrix.currentUnsetX;\n\n\n\n        //               res = abi.encodePacked(\n        //                   res,\n        //                   getRekt(lastPix.rgba, (matrix.width - diff) * pixelWidth, (matrix.currentUnsetY - 1) * pixelWidth, pixelWidth, diff * pixelWidth),\n        //                   getRekt(lastPix.rgba, 0, (matrix.currentUnsetY) * pixelWidth, pixelWidth, (count - diff) * pixelWidth)\n        //               );\n        //               //  res = abi.encodePacked(res, getRekt(lastPix.rgba, 0, (lastPix.currentUnsetY) * pixelWidth, pixelWidth, (count - diff) * pixelWidth));\n        //           } else {\n        //               res = abi.encodePacked(\n        //                   res,\n        //                   getRekt(lastPix.rgba, (matrix.width - count) * pixelWidth, (matrix.currentUnsetY - 1) * pixelWidth, pixelWidth, count * pixelWidth)\n        //               );\n        //           }\n        //       }\n        //   }\n    }\n\n    //  function getRekt(\n    //      IDotNugg.Rgba memory rgba,\n    //      uint256 x,\n    //      uint256 y,\n    //      uint256 xlen,\n    //      uint256 ylen\n    //  ) internal view returns (bytes memory res) {\n    //      if (rgba.a == 0) return '';\n    //      //   (rgba, ) = rgba.combine(IDotNugg.Rgba({r: 0, g: 255, b: 0, a: 99}));\n    //      res = abi.encodePacked(\n    //          \"\\t<rect fill='#\",\n    //          rgba.toAscii(),\n    //          \"' x='\",\n    //          x.toString(),\n    //          \"' y='\",\n    //          y.toString(),\n    //          \"' height='\",\n    //          xlen.toString(),\n    //          \"' width='\",\n    //          ylen.toString(),\n    //          \"'/>\\n\"\n    //      );\n    //  }\n}\n"
    },
    "contracts/resolvers/DotNuggFileResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '.././interfaces/IDotNugg.sol';\nimport '.././interfaces/INuggIn.sol';\nimport '.././erc165/IERC165.sol';\nimport '../../contracts/logic/Rgba.sol';\nimport '../../contracts/logic/Matrix.sol';\nimport '../../contracts/libraries/Uint.sol';\n\ncontract DotNuggFileResolver is IFileResolver {\n    using Rgba for IDotNugg.Rgba;\n    using Uint256 for uint256;\n\n    using Matrix for IDotNugg.Matrix;\n\n    function combineBros(bytes1 n1, bytes1 n2) internal pure returns (bytes1 res) {\n        return (n1 << 4) | n2;\n        //   assembly {\n        //       mstore(res, or(shl(mload(n1), 4), mload(n2)))\n        //   }\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public pure override(IFileResolver) returns (bool) {\n        return interfaceId == type(IFileResolver).interfaceId || interfaceId == type(IERC165).interfaceId;\n    }\n\n    function resolveFile(IDotNugg.Matrix memory matrix, bytes memory) public view override returns (bytes memory res, string memory fileType) {\n        bytes memory rects = encode(matrix);\n        return (rects, 'dotnugg');\n    }\n\n    function getPixelIndex(IDotNugg.Pixel[] memory pallet, IDotNugg.Pixel memory pixel) internal view returns (uint8 res, bool wasCached) {\n        if (pixel.rgba.a == 0) return (0, true);\n        for (uint8 i = 1; i < pallet.length; i++) {\n            if (pallet[i].rgba.equalssss(pixel.rgba)) {\n                return (i, true);\n            }\n            if (!pallet[i].exists) {\n                //  pallet[i] = pixel;\n                res = i;\n                break;\n            }\n        }\n\n        pallet[res] = pixel;\n        pallet[res].exists = true;\n\n        return (res, false);\n    }\n\n    function encode(IDotNugg.Matrix memory matrix) internal view returns (bytes memory res) {\n        IDotNugg.Pixel memory lastPixel;\n\n        IDotNugg.Pixel[] memory pallet = new IDotNugg.Pixel[](50);\n\n        bytes memory colorKeys = new bytes(1000);\n        bytes memory lengths = new bytes(1000);\n\n        uint256 coltracker = 0;\n        uint256 lentracker = 0;\n        uint256 pallettracker = 1;\n\n        uint8 count = 1;\n        while (matrix.next()) {\n            if (lastPixel.rgba.equalssss(matrix.current().rgba) && count < 16) {\n                count++;\n                continue;\n            }\n            (uint8 key_, bool cached_) = getPixelIndex(pallet, lastPixel);\n            if (!cached_) pallettracker++;\n            colorKeys[coltracker++] = bytes1(key_);\n            lengths[lentracker++] = bytes1(count - 1);\n\n            lastPixel = matrix.current();\n            count = 1;\n        }\n\n        (uint8 key, bool cached) = getPixelIndex(pallet, lastPixel);\n        if (!cached) pallettracker++;\n        colorKeys[coltracker++] = bytes1(key);\n        lengths[lentracker++] = bytes1(count - 1);\n\n        res = new bytes(coltracker + pallettracker * 4 + lentracker / 2 + 12 + 1);\n\n        uint256 index = 0;\n\n        res[index++] = 0x64; // [0] - D\n        res[index++] = 0x6f; // [1] - O\n        res[index++] = 0x74; // [2] - T\n        res[index++] = 0x6e; // [3] - N\n        res[index++] = 0x75; // [4] - U\n        res[index++] = 0x67; // [5] - G\n        res[index++] = 0x67; // [6] - G\n\n        res[index++] = 0; // [7] - FREE\n        res[index++] = bytes1(matrix.width); // [8] - width\n\n        uint256 colorKeysIndex = index + (pallettracker + 1) * 4;\n        uint256 lengthIndex = colorKeysIndex + coltracker;\n\n        res[index++] = bytes1(uint8(colorKeysIndex >> 8));\n        res[index++] = bytes1(uint8(0xff & colorKeysIndex));\n\n        res[index++] = bytes1(uint8(lengthIndex >> 8));\n        res[index++] = bytes1(uint8(0xff & lengthIndex));\n\n        for (uint256 i = 0; i < pallettracker; i++) {\n            res[index++] = bytes1(pallet[i].rgba.r);\n            res[index++] = bytes1(pallet[i].rgba.g);\n            res[index++] = bytes1(pallet[i].rgba.b);\n            res[index++] = bytes1(pallet[i].rgba.a);\n        }\n\n        for (uint256 i = 0; i < coltracker; i++) {\n            res[index++] = colorKeys[i];\n        }\n\n        for (uint256 i = 0; i < lentracker; i += 2) {\n            res[index++] = combineBros(lengths[i], lengths[i + 1]);\n        }\n    }\n\n\n}\n"
    },
    "contracts/erc165/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport './IERC165.sol';\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}